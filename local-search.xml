<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小芝士|简化OpenCL API梳理说明</title>
    <link href="/2025/04/13/opencl-base-api/"/>
    <url>/2025/04/13/opencl-base-api/</url>
    
    <content type="html"><![CDATA[<p>OpenCL（Open Computing Language，开放计算语言）：从软件视角看，它是用于异构平台编程的框架；从规范视角看，它是异构并行计算的行业标准，由Khronos Group来维护。</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20250413203220258.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20250413203220258"></p><p>很多组织会基于OpenCL的规范去维护自己的一套runtime api，比如基于OpenCL3.0的<a href="https://github.com/pocl/pocl">PoCL</a>，我在实现的时候也大多是借鉴这个仓库，他是为了应对CPU和Level Zero GPU目标实现的OpenCL实现，再比如Amd、Intel、Nvdia的硬件平台都有基于OpenCL标准的实现。</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20250413203239113.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20250413203239113"></p><p>我们实验室自己的硬件也需要这样一套基于OpenCL标准的基础api实现。我梳理了一下，需要重点实现的API以及对应功能如下：</p><h1 id="基础API说明"><a href="#基础API说明" class="headerlink" title="基础API说明"></a>基础API说明</h1><p>对于我们实验室的硬件来说，期望实现的功能主要有：</p><ol><li>可以面向单platform、单context、多device的异构编程模型；</li><li>支持单个device拥有多个DDR内存的场景；</li><li>场景相对单一，因此api设计可以相对简单，不追求完备的OpenCL标准实现，但需要实现满足我们硬件需求的Interface。</li></ol><h2 id="API-List"><a href="#API-List" class="headerlink" title="API List"></a>API List</h2><p>为了应对上述场景，需要实现的基础API主要有以下几个：</p><table><thead><tr><th>API名称</th><th>功能描述</th></tr></thead><tbody><tr><td>clGetPlatformIDs</td><td>获取平台ID</td></tr><tr><td>clGetDeviceIDs</td><td>获取设备ID</td></tr><tr><td>clCreateContext</td><td>创建上下文</td></tr><tr><td>clCreateCommandQueue</td><td>创建命令队列</td></tr><tr><td>clCreateBuffer</td><td>创建缓冲区</td></tr><tr><td>clEnqueueWriteBuffer</td><td>写入缓冲区</td></tr><tr><td>clEnqueueReadBuffer</td><td>读取缓冲区</td></tr><tr><td>clEnqueueTask</td><td>任务入队</td></tr><tr><td>clSetKernelArg</td><td>设置内核参数</td></tr><tr><td>clCreateKernel</td><td>创建内核</td></tr><tr><td>clReleaseKernel</td><td>释放内核</td></tr><tr><td>clReleaseMemObject</td><td>释放内存对象</td></tr><tr><td>clReleaseCommandQueue</td><td>释放命令队列</td></tr><tr><td>clReleaseContext</td><td>释放上下文</td></tr><tr><td>clReleaseEvent</td><td>释放事件</td></tr></tbody></table><h2 id="Datastruct-List"><a href="#Datastruct-List" class="headerlink" title="Datastruct List"></a>Datastruct List</h2><p>原有OpenCL的数据结构很复杂，面对我们的应用场景，可以实现以下的数据结构：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">cl_context&#123;<br>    cl_device_id* devices<span class="hljs-comment">;</span><br>    unsigned int num_devices<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">cl_device_id&#123;<br>    cl_device_type device_type<span class="hljs-comment">;</span><br>    cl_ulong global_mem_size<span class="hljs-comment">;</span><br>    void *data<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">cl_command_queue&#123;<br>    cl_context context<span class="hljs-comment">;</span><br>    cl_device_id device<span class="hljs-comment">;</span><br>    cl_command_queue_properties properties<span class="hljs-comment">;</span><br>    cl_event event<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">cl_mem&#123;<br>    cl_context context<span class="hljs-comment">;</span><br>    size_t size<span class="hljs-comment">;</span><br>    void* mem_ptr<span class="hljs-comment">;</span><br>    u64 mem_addr<span class="hljs-comment">;</span><br>    void *data<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">cl_kernel&#123;<br>    cl_context context;<br>    cl_program <span class="hljs-function"><span class="hljs-keyword">program</span></span>;<br>    const <span class="hljs-built_in">char</span>* <span class="hljs-keyword">name</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些比较基础的cl数据结构，都是以快速实现功能为目的设计。如果是针对下面这种情况则是完全够用。</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20250413204118276.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20250413204118276"></p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>实验室具体代码暂时是闭源的，后续要是可以补充会放上。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ai-infra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intership｜Paddle的amp pass（混合精度 pass）新旧迭代中遇到的问题</title>
    <link href="/2024/10/28/amp-pass/"/>
    <url>/2024/10/28/amp-pass/</url>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>一直都想要参加一些大项目的开源活动，同时自己也想在 AI inference 上获得更深入的了解，一直在寻找这样一个可以参与的机会。机缘巧合之下在今年参与了 paddle pass 组件的开发，虽然只是其中一个很小的 pass，但是在其中也是收获满满～</p><p>paddle现在的 amp pass还不支持 PIR 的直接使用，就需要经过下面的流程：</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20241028225011825.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20241028225011825"></p><p>对于一个新生的 PIR 来说，一直使用旧的 pass 去做转化显然是不理想也不能接受的，于是从支持旧 IR 的 pass 到支持PIR 的 pass 就要有一个转化的工作。旧 IR 从一种相对落后的实现迭代到现在的 PIR，有许多工作需要补充，就像 paddle 说的，“PIR灵活可扩展，在底层抽象了一套高度可扩展的基础组件，涵盖Type、Attribute、Op、Trait和Interface，并引入了Dialect的概念，赋予开发者灵活扩展与自由定制的能力，从而提供了全面且稳健的语义表达能力。在模型表示层，通过多Dialect的模块化管理和统一多端表示，实现了训练与推理一体化的全架构统一表示，实现了算子和编译器的无缝衔接，支持自动优化和多硬件适配。在图变换层，通过统一底层模块并简化基础概念，向用户提供了低成本、易用且高性能的开发体验，以及丰富且可插拔的Pass优化机制。飞桨PIR坚守静态单赋值（SSA）原则，确保模型等价于一个有向无环图，并采用Value和Operation对计算图进行抽象，其中Operation代表节点，Value代表边”。</p><p>在我实际使用中，也的确发现了 PIR 相较于旧 IR 的很多优势。如果 amp pass 可以直接工作在PIR 上，那么流程就会变为下面这样：</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20241028230357527.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20241028230357527"></p><p>对于这套流程来说，最终态就是从 PIR model 直接经过 PIR pass 送入执行器推理。</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>旧 IR 的 amp pass 执行流程如下：</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20241028230622643.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20241028230622643"></p><p>在使用了PIR 后，其中的一些步骤就可以省略。由于PIR 的 SSA 特性，每 个变量只有唯一的赋值点， 所以我们可以把用来设置 Op 唯一标志的这步省略。由于PIR 中引入的这一套Value 和 Operation 的抽象，我们在设置权重和输入输出的精度时不用 在分开做，插入 cast op 也就不 需要再等前两个做完再做。融合 到 ProcessBlock 里，通过修改 op 的attribute 里的精度相关设置以及，设置输出中的 Type 来完成相关功能。PIR amp pass 就变成了下面这样（灰色是可以融合或者删除的步骤）：</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20241028230809409.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20241028230809409"></p><p>对于 PIR 的 pass 来说，不需要关心上层的实现机制，只需要利用 paddle pir pass 的两种开发机制：DRR 和 Pattern rewrite</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20241028231427016.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20241028231427016"></p><p>PR 机制只需要可以选择直接继承 pir::Pass，然后自定义接口 Run 去实现匹配功能，比如下面官方给出的常量折叠 pass：</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20241028231642830.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20241028231642830"></p><p>由此可见，amp pass 的开发也可以借鉴这一点，只需要聚焦 pass 的顶层实现，由于目前的 ir 可能会存在一种循环嵌套的可能性，由此 pass 的实现可以如下,采用Pattern Rewriter机制 ，只要实现CanApplyOn 就可以 End 控制 Run 函数访问到最外层的 op，然后进入后通过递归处理就可以就可以实现对所有 op 的<strong>深度优先遍历</strong>，解决多层循环嵌套的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(pir::Operation* op)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    SubBlockRun(op-&gt;GetParentProgram()-&gt;block());<br>    AddStatistics(op_run_low_precision_.size());<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CanApplyOn</span><span class="hljs-params">(pir::Operation* op)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> op-&gt;num_regions() &gt; <span class="hljs-number">0</span> &amp;&amp; op-&gt;isa&lt;pir::ModuleOp&gt;() &amp;&amp; place_ == paddle::PlaceType::kGPU &amp;&amp;<br>         (precision_mode_ == phi::DataType::FLOAT16 ||<br>          precision_mode_ == phi::DataType::BFLOAT16);<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SubOpRun</span><span class="hljs-params">(pir::Operation* op)</span></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; region : *op) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; block : region) &#123;<br>      SubBlockRun(&amp;block); <span class="hljs-comment">//subblock</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SubBlockRun</span><span class="hljs-params">(pir::Block* block)</span></span>&#123;<br>  GetOpPrecision(block);<br>  UpdateOpPrecision(block);<br>  pir::Builder builder = pir::Builder(context_, block);<br>  ProcessBlock(block, builder);<br>  cached_cast_ops_.clear();<br>  op_should_not_handle_.clear();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; op : *block) &#123;<br>    SubOpRun(&amp;op);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在完成开发工作之后，还参与到了该 pass 的性能测试中。主要是利用下面这种形式展开性能测试，用paddle自己的 profile 工具，生成可转化的 json 文件，去导出 timeline 、转化成 mysql 去分析。最初没有发现 perfetto 的转化db 文件的功能， 但是后面了解到，用 sql 工具处理数据可以得到很神奇的效果。后面也想补充一篇关于 perfetto 使用的技巧，互联网上关于这个真的很缺，ai inferencer 真的很伤。</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20241028232128061.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20241028232128061"></p><p>通过这种方式，发现了在使用 paddle-inference-demo 的使用问题并解决，最后得到了下面比较好的 tipc测试结果。</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20241028234113104.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20241028234113104"></p><p>最终在多次代码更新加性能测试后，初步“收敛”了这个 amp pass。</p><h1 id="去往"><a href="#去往" class="headerlink" title="去往"></a>去往</h1><p>这次的工作对我自己的研究生路途也有很重要的启发：</p><ul><li><p>一种优秀的 IR 对于训推工作来说有巨大的便利性，便利性就可能体现在代码编写上或者调试中。在以往我常用的推理框架中不具备这种特性导致推理流程进行的不是很顺畅。</p></li><li><p>接触到 paddle推理的开发，让我对整个推理流程有了新的认识，推理需要精心设计数据的流动，最终在更优的计算资源和时延控制下，产生精确的结果，让算法真正从理论走向实践。</p></li><li><p>优秀的开源项目的确存在一种传承关系，远乐导师的帮助让我快速的融入这个课题，更是让我对 paddle 推理相关有了更深的认识，未来会有更多机会加入到优秀的项目之中。</p></li></ul><p>Code: <a href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/pir/transforms/general/auto_mixed_precision_pass.cc">https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/pir/transforms/general/auto_mixed_precision_pass.cc</a></p>]]></content>
    
    
    <categories>
      
      <category>Intership</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Ai-infra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小技巧｜异构计算中C++ host 部分的性能测试（普通C++程序也适用）</title>
    <link href="/2024/04/08/cu2/"/>
    <url>/2024/04/08/cu2/</url>
    
    <content type="html"><![CDATA[<p>​    在对项目的某个功能模块进行优化的时候，刚开始都是使用封装好的 Timer 类去测试（再最后也放上 Timer 类的代码），但是只有添加了 Timer 的地方才可以记录到时间，这个记录的粒度非常不好控制，比如测试了整个函数体用时的话，函数体之内用时占比就还需要更详细的测试。</p><h1 id="FlameGraph"><a href="#FlameGraph" class="headerlink" title="FlameGraph"></a>FlameGraph</h1><p>​    以往在device 端进行测试的时候可以使用 Xilinx 自带的工具查看 timeline，host端优化的时候没有考虑使用类似的工具。这次发现了一个基于 linux  profiling工具 perf 的图形化分析工具FlameGraph。下图是我在该项目的FlameGraph输出。</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240703154209489.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20240703154209489"></p><p>​    可以看到这个主函数注意包含了三个线程，为什么图中线程是看起来串行的？那是因为火焰图并不包含时序的信息。主要信息如下：</p><ol><li>纵向（Y 轴）高低不平，表示的是函数调用栈的深度。每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</li><li>横向（X 轴）表示该函数执行消耗的时间，<strong>横向上会按照字母顺序排序</strong>，而且如果是同样的调用会做合并（注意：如果一个函数在 X 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长，所以这里不是严格意义上的执行消耗的时间），所以一个横向宽度越大的函数调用，一般很可能是程序的瓶颈。</li><li>火焰图的颜色是随机分配的，并不是颜色越深就是越瓶颈。因为火焰图表示的是 CPU 的繁忙程度，所以一般都是暖色调。我们需要留意的就是那些比较宽大的火苗。只要有”平顶”，就表示该函数可能存在性能问题。但是更多的可能需要看我们对于这个函数的执行时间是否符合我们的预期，根据提前计算好的预期去规划。</li></ol><p>​    因为目前我只需要分析 host 端的时间，所以只需要输On-CPU 火焰图（device 端有另外的工具）。下面是生成命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -E perf record -F 99 -g -- ./run.exe yolov5_v4L32Y7_post.xclbin.u50<br>sudo perf script &gt; out.perf<br><span class="hljs-built_in">cd</span> FlameGraph-master/<br>./stackcollapse-perf.pl ../out.perf &gt; out.folded<br>./flamegraph.pl out.folded &gt; flamegraph.svg<br></code></pre></td></tr></table></figure><p>​    可以看到我们在目标路径生成了flamegraph.svg，由于是 svg 所以我们可以同该图进行交互，比如我现在需要清楚 detection 线程做的操作，点击放大相关信息，如下图。</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240703155418747.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20240703155418747"></p><p>再依次放大到我们的瓶颈函数 detection_yolov5</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240703155512018.png?imageMogr2/format/webp/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hb294aW4uY24v/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/5/shadow/0/batch/1/degree/34" alt="image-20240703155512018"></p><p>可以看到我红框圈出来的瓶颈（图中已经不是瓶颈了，被我优化过了）。</p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>这个 Timer 是我之前从小彭老师那里拿到的，实现的非常好，主要原理是利用 RAII，自动管理对象的生命周期，不需要手动记录开始和结束时间，在构造和析构函数中记录时间，提供了一种方便的方式来测量代码块的执行时间，并且可以收集统计数据，方便开发者分析代码性能瓶颈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string_view&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopeProfiler</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ClockType = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Record</span> &#123;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *tag;<br>        <span class="hljs-keyword">int</span> us;<br>    &#125;;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Record&gt; records;<br><br>    ClockType::time_point beg;<br>    ClockType::time_point end;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *tag;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ScopeProfiler</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *tag, ClockType::time_point beg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">(ClockType::time_point end)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    ScopeProfiler(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *tag_) : ScopeProfiler(tag_, ClockType::now()) &#123;&#125;<br>    ~ScopeProfiler() &#123; onDestroy(ClockType::now()); &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Record&gt; <span class="hljs-keyword">const</span> &amp;<span class="hljs-title">getRecords</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> records; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;out = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>)</span></span>;<br>&#125;;<br><br>ScopeProfiler::ScopeProfiler(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *tag_, ScopeProfiler::ClockType::time_point beg_)<br>    : beg(beg_), tag(tag_)<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ScopeProfiler::onDestroy</span><span class="hljs-params">(ScopeProfiler::ClockType::time_point end)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> diff = end - beg;<br>    <span class="hljs-keyword">int</span> us = <span class="hljs-built_in">std</span>::chrono::duration_cast&lt;<span class="hljs-built_in">std</span>::chrono::microseconds&gt;(diff).count();<br>    records.push_back(&#123;tag, us&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ScopeProfiler::printLog</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;out)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (records.size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Statistic</span> &#123;</span><br>        <span class="hljs-keyword">int</span> max_us = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> min_us = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> total_us = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count_rec = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *tag = <span class="hljs-literal">nullptr</span>;<br>    &#125;;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::string_view, Statistic&gt; stats;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span> &amp;[tag, us]: records) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;stat = stats[tag];<br>        stat.total_us += us;<br>        stat.max_us = <span class="hljs-built_in">std</span>::max(stat.max_us, us);<br>        stat.min_us = !stat.count_rec ? us : <span class="hljs-built_in">std</span>::min(stat.min_us, us);<br>        stat.count_rec++;<br>        stat.tag = tag;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatisticCompare</span> &#123;</span><br>        <span class="hljs-keyword">using</span> value_type = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">std</span>::string_view, Statistic&gt;;<br>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(value_type <span class="hljs-keyword">const</span> &amp;lhs, value_type <span class="hljs-keyword">const</span> &amp;rhs)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> lhs.second.total_us &gt; rhs.second.total_us;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">std</span>::string_view, Statistic&gt;, StatisticCompare&gt; sortstats(stats.begin(), stats.end());<br><br>    <span class="hljs-keyword">auto</span> dump = [&amp;out] (<span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> w) &#123;<br>        <span class="hljs-keyword">auto</span> tpwv = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w - <span class="hljs-number">1</span>; i++) tpwv *= <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span> (val &gt; tpwv) &#123;<br>            <span class="hljs-keyword">if</span> (val / <span class="hljs-number">1000</span> &gt; tpwv / <span class="hljs-number">10</span>) &#123;<br>                out &lt;&lt; <span class="hljs-built_in">std</span>::setw(w - <span class="hljs-number">1</span>) &lt;&lt; val / <span class="hljs-number">1000000</span> &lt;&lt; <span class="hljs-string">&#x27;M&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                out &lt;&lt; <span class="hljs-built_in">std</span>::setw(w - <span class="hljs-number">1</span>) &lt;&lt; val / <span class="hljs-number">1000</span> &lt;&lt; <span class="hljs-string">&#x27;k&#x27;</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            out &lt;&lt; <span class="hljs-built_in">std</span>::setw(w) &lt;&lt; val;<br>        &#125;<br>    &#125;;<br><br>    out &lt;&lt; <span class="hljs-string">&quot;   avg   |   min   |   max   |  total  | cnt | tag\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span> &amp;[tag, stat]: sortstats) &#123;<br>        dump(stat.total_us / stat.count_rec, <span class="hljs-number">9</span>); out &lt;&lt; <span class="hljs-string">&#x27;|&#x27;</span>;<br>        dump(stat.min_us, <span class="hljs-number">9</span>); out &lt;&lt; <span class="hljs-string">&#x27;|&#x27;</span>;<br>        dump(stat.max_us, <span class="hljs-number">9</span>); out &lt;&lt; <span class="hljs-string">&#x27;|&#x27;</span>;<br>        dump(stat.total_us, <span class="hljs-number">9</span>); out &lt;&lt; <span class="hljs-string">&#x27;|&#x27;</span>;<br>        dump(stat.count_rec, <span class="hljs-number">5</span>); out &lt;&lt; <span class="hljs-string">&#x27;|&#x27;</span>;<br>        out &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; tag &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GUNC__) || defined(__clang__)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DefScopeProfiler ScopeProfiler _scopeProfiler(__PRETTY_FUNCTION__);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(_MSC_VER)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DefScopeProfiler ScopeProfiler _scopeProfiler(__FUNCSIG__);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DefScopeProfiler ScopeProfiler _scopeProfiler(__func__);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-keyword">static</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GUNC__) || defined(__clang__)</span><br>__attribute__((noinline))<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(_MSC_VER)</span><br>__declspec(noinline)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doNotOptimize</span><span class="hljs-params">(T <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">const</span> &amp;t)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printScopeProfiler</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;out = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>)</span> </span>&#123;<br>    ScopeProfiler::printLog(out);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intership｜LLM应用从训练到构建</title>
    <link href="/2024/03/27/llm/"/>
    <url>/2024/03/27/llm/</url>
    
    <content type="html"><![CDATA[<p>以下有很多东西已脱密处理，可读性会降低。在咨询+1 得到同意后，把一些流程记录下来。</p><h1 id="1-LLM预训练中的参数设置以及训练设置"><a href="#1-LLM预训练中的参数设置以及训练设置" class="headerlink" title="1 LLM预训练中的参数设置以及训练设置"></a>1 LLM预训练中的参数设置以及训练设置</h1><h2 id="1-1-参数设置"><a href="#1-1-参数设置" class="headerlink" title="1.1 参数设置"></a>1.1 参数设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CUDA_VISIBLE_DEVICES=0 python src/train_bash.py \ --stage sft \ --model_name_or_path /model/baichuan2/Baichuan2-7B-chat \ --do_train \ --dataset classify\ --template baichuan2 \ --finetuning_type lora \ --lora_target all \ --output_dir /cephfs/home/aooxin/LLM/LLM_model/classify_3_1_1 \ --overwrite_cache \ --per_device_train_batch_size 1 \ --per_device_eval_batch_size 1 \ --gradient_accumulation_steps 4 \ --lr_scheduler_type cosine \ --logging_steps 10 \ --save_steps 100 \ --lora_rank 64 \ --lora_alpha 128 \ --learning_rate 5e-5 \ --num_train_epochs 300 \ --plot_loss \ --fp16<br></code></pre></td></tr></table></figure><ul><li>stage：指令监督微调</li><li>model_name_or_path：模型我们选择Baichuan2</li><li>finetuning_type：选择lora</li><li>per_device_eval_batch_size：目前使用的3090只支持1 batch per gpu</li><li>learning_rate：经过多次尝试后，发现5e-5的学习率比较适合我们的任务</li><li>num_train_epochs：训练轮次可以根据数据量的多少来设置</li></ul><h2 id="1-2-训练加速"><a href="#1-2-训练加速" class="headerlink" title="1.2 训练加速"></a>1.2 训练加速</h2><p>加速可以选择<a href="https://huggingface.co/docs/accelerate/index">Accelerate</a>、<a href="https://github.com/microsoft/DeepSpeed">DeepSpeed</a><br>在这里我们选择了DeepSpeed，DeepSpeed可以通过zero技术增加通信代价来减少显存消耗，但是我们的3090每张卡可以单独放下一个batch，所以我们使用zero 0的设置，实际上就为普通的DDP多卡并行。不同Zero的设置大致效果如下：</p><blockquote><p>速度上：阶段 0 (DDP) &gt; 阶段 1 &gt; 阶段 2 &gt; 阶段 3<br>显存上：阶段 0 (DDP) &lt; 阶段 1 &lt; 阶段 2 &lt;  阶段 3 </p></blockquote><p>需要增加以下依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">deepspeed==0.12.3<br>transformers==4.34.1<br>datasets==2.14.7<br>tiktoken==0.5.1<br>peft==0.6.2<br>trl==0.7.1<br></code></pre></td></tr></table></figure><p>zero 0的deepspeed配置文件如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><br>    <span class="hljs-attr">&quot;bf16&quot;</span>: &#123;<br><br>        <span class="hljs-attr">&quot;enabled&quot;</span>: <span class="hljs-literal">false</span><br><br>    &#125;,<br><br>    <span class="hljs-attr">&quot;fp16&quot;</span>: &#123;<br><br>        <span class="hljs-attr">&quot;enabled&quot;</span>: <span class="hljs-literal">true</span><br><br>    &#125;,<br><br>    <span class="hljs-attr">&quot;zero_optimization&quot;</span>: &#123;<br><br>        <span class="hljs-attr">&quot;stage&quot;</span>: <span class="hljs-number">0</span><br><br>    &#125;,<br><br>    <span class="hljs-attr">&quot;gradient_clipping&quot;</span>: <span class="hljs-number">1.0</span>,<br><br>    <span class="hljs-attr">&quot;train_batch_size&quot;</span>: <span class="hljs-string">&quot;auto&quot;</span>,<br><br>    <span class="hljs-attr">&quot;train_micro_batch_size_per_gpu&quot;</span>: <span class="hljs-number">1</span>,<br><br>    <span class="hljs-attr">&quot;gradient_accumulation_steps&quot;</span>: <span class="hljs-number">4</span>,<br><br>    <span class="hljs-attr">&quot;steps_per_print&quot;</span>: <span class="hljs-number">2000000</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用deepspeed对应的训练启动命令也要修改，如果使用单机8卡的机器，可以使用以下命令启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">deepspeed --include=<span class="hljs-string">&quot;localhost:0,1,2,3,4,5,6,7&quot;</span> src/train_bash.py --stage sft --model_name_or_path /model/baichuan2/Baichuan2-7B-chat --do_train --dataset classify --template baichuan2 --finetuning_type lora --lora_target all --output_dir /cephfs/home/aooxin/LLM/LLM_model/classify_3_1_1 --overwrite_cache --per_device_train_batch_size 1 --per_device_eval_batch_size 1 --gradient_accumulation_steps 4 --lr_scheduler_type cosine --logging_steps 10 --save_steps 100 --lora_rank 64 --lora_alpha 128 --learning_rate 5e-5 --num_train_epochs 300 --plot_loss --fp16 --deepspeed /root/ds_config.json<br></code></pre></td></tr></table></figure><h2 id="1-3-完整一次训练流程"><a href="#1-3-完整一次训练流程" class="headerlink" title="1.3 完整一次训练流程"></a>1.3 完整一次训练流程</h2><h3 id="1-3-1-训练"><a href="#1-3-1-训练" class="headerlink" title="1.3.1 训练"></a>1.3.1 训练</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">deepspeed --include=<span class="hljs-string">&quot;localhost:0,1,2,3,4,5,6,7&quot;</span> src/train_bash.py --stage sft --model_name_or_path /model/baichuan2/Baichuan2-7B-chat --do_train --dataset classify --template baichuan2 --finetuning_type lora --lora_target all --output_dir /cephfs/home/aooxin/LLM/LLM_model/classify_3_1_1 --overwrite_cache --per_device_train_batch_size 1 --per_device_eval_batch_size 1 --gradient_accumulation_steps 4 --lr_scheduler_type cosine --logging_steps 10 --save_steps 100 --lora_rank 64 --lora_alpha 128 --learning_rate 5e-5 --num_train_epochs 300 --plot_loss --fp16 --deepspeed /root/ds_config.json<br></code></pre></td></tr></table></figure><h3 id="1-3-2-导出"><a href="#1-3-2-导出" class="headerlink" title="1.3.2 导出"></a>1.3.2 导出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python src/export_model.py \ --model_name_or_path /model/baichuan2/Baichuan2-7B-chat \ --template baichuan2 \ --finetuning_type lora \ --checkpoint_dir /cephfs/home/aooxin/LLM/LLM_model/classify_3_2_p1check_p4/ \ --output_dir /cephfs/home/aooxin/LLM/LLM_model/model_classify_3_2_p1check_p4 \ --fp16<br></code></pre></td></tr></table></figure><h3 id="1-3-3-量化"><a href="#1-3-3-量化" class="headerlink" title="1.3.3 量化"></a>1.3.3 量化</h3><p>目前资源够使用，没有使用量化模型的步骤，如需，可以使用chatglm进行量化</p><h3 id="1-3-4-api部署"><a href="#1-3-4-api部署" class="headerlink" title="1.3.4 api部署"></a>1.3.4 api部署</h3><p>需要对api_demo.py进行修改，修改如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> uvicorn<br><br><span class="hljs-keyword">from</span> llmtuner <span class="hljs-keyword">import</span> ChatModel, create_app<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br><br>    chat_model = ChatModel()<br><br>    app = create_app(chat_model)<br><br>    port = <span class="hljs-built_in">int</span>(os.getenv(<span class="hljs-string">&quot;PORT&quot;</span>, <span class="hljs-number">8000</span>))<br><br>    uvicorn.run(app, host=<span class="hljs-string">&quot;0.0.0.0&quot;</span>, port=port, workers=<span class="hljs-number">1</span>)<br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    main()<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PORT=8000 python src/api_demo.py \ --model_name_or_path /cephfs/home/aooxin/LLM/LLM_model/model_classify_3_8_p1check_p4check_str \ --template baichuan2 \ --finetuning_type lora<br></code></pre></td></tr></table></figure><h1 id="2-数据集构造"><a href="#2-数据集构造" class="headerlink" title="2 数据集构造"></a>2 数据集构造</h1><h2 id="2-1-构造样式"><a href="#2-1-构造样式" class="headerlink" title="2.1 构造样式"></a>2.1 构造样式</h2><p>由于我们实现的功能有几种，所以数据集的构造也有一定的细微差别，主要体现在input prompt上</p><h3 id="2-1-1-每种类型格式"><a href="#2-1-1-每种类型格式" class="headerlink" title="2.1.1 每种类型格式"></a>2.1.1 每种类型格式</h3><ul><li><p>prompt构造</p><p>  <strong>此处删除</strong></p><h3 id="2-1-2-构造原因"><a href="#2-1-2-构造原因" class="headerlink" title="2.1.2 构造原因"></a>2.1.2 构造原因</h3><p>分为3种</p></li><li><p>input中不需要额外prompt：比如classify和extract，这两种llm的实现不需要外界额外信息，因此不需要额外的prompt。</p></li><li><p>input中需要一种额外prompt：比如head和point，这两种的实现只需要少量外界额外信息，因此只需要补充上额外的信息即可。</p></li><li><p>input中需要两种额外prompt：比如line和surface，这两种军标中，每个小的军标都可能存在不同的算法，所以需要在额外基础信息的情况下，加上军标的补充说明去训练，比如下面这两种军标，存在完全不同的计算方法，所以针对某种军标需要单独设计数据去参与训练。</p><ul><li>作战分界线中，0为不含1为含</li><li>燕尾箭头中，通过起点、经过点、终点确定，由于起点需要两个点，所以需根据南北、东西走向确定，如果是南北，则在起点的经度上进行+-0.005；如果是东西，则在起点的纬度上+-0.005</li></ul></li></ul><h2 id="2-2-完整构造流程"><a href="#2-2-完整构造流程" class="headerlink" title="2.2 完整构造流程"></a>2.2 完整构造流程</h2><p>一次完整的构造流程分为生成数据-&gt;校准数据-&gt;转化数据</p><h3 id="2-2-1-生成数据"><a href="#2-2-1-生成数据" class="headerlink" title="2.2.1 生成数据"></a>2.2.1 生成数据</h3><p>生成数据我们使用<strong>gpt-4-turbo-preview</strong>，之所以使用gpt-4-turbo-preview是因为它相比于其他模型具有限定json格式输出的功能，其tokens长度也完全足够我们使用。与gpt4相比，他的单位tokens也更便宜，如下，gpt3.5没有限制json输出的功能，综合来讲选择gpt-4-turbo-preview比较合理。</p><table><thead><tr><th>Model</th><th>Input</th><th>Output</th></tr></thead><tbody><tr><td>gpt-4-0125-preview</td><td>$10.00 / 1M tokens</td><td>$30.00 / 1M tokens</td></tr><tr><td><strong>gpt-4-1106-preview</strong></td><td><strong>$10.00 / 1M tokens</strong></td><td><strong>$30.00 / 1M tokens</strong></td></tr><tr><td>gpt-4-1106-vision-preview</td><td>$10.00 / 1M tokens</td><td>$30.00 / 1M tokens</td></tr><tr><td>gpt-4</td><td>$30.00 / 1M tokens</td><td>$60.00 / 1M tokens</td></tr><tr><td>gpt-4-32k</td><td>$60.00 / 1M tokens</td><td>$120.00 / 1M tokens</td></tr><tr><td>gpt-3.5-turbo-0125</td><td>$0.50 / 1M tokens</td><td>$1.50 / 1M tokens</td></tr><tr><td>gpt-3.5-turbo-instruct</td><td>$1.50 / 1M tokens</td><td>$2.00 / 1M tokens</td></tr><tr><td>classify的生成代码如下，其余的代码在gitlab中</td><td></td><td></td></tr><tr><td>另外在生成数据的时候，可能要注意以下几点：</td><td></td><td></td></tr></tbody></table><ol><li><p>可以人工给出的信息，尽量提前给出：大模型可能会有很强的某种数据的倾向，尽管这些倾向有时候看起来匪夷所思，比如示例军标我们给出一个直升机，让他随机，他就可能倾向于战斗机等等的其他种类的飞机，而忽略其他军标，所以随机数据上减少对gpt的使用，比如ID可以使用uuid，军标可以通过python随机提前给出，这样gpt生成的效果会更好。</p></li><li><p>信息与信息有强相关性，就要一并给出：军标有中文和英文，生成数据的时候就要一并给出，不能让gpt自己猜测，防止生成的数据训练出来的模型未来也使用猜测的英文。</p></li><li><p>数学逻辑特别要注意：比如某点南北展开，对应我们的点需要纬度上+-0.005，这样的在生成的时候可以分开生成，先强制全部生成南北的，后续我们重新给出东西的例子，再重新生成东西。可以避免后续的矫正。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv<br><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><br>  <br>  <br><br><span class="hljs-comment"># Load environment variables</span><br><br>load_dotenv()<br><br>  <br><br><span class="hljs-comment"># Initialize OpenAI client</span><br><br>client = OpenAI(<br><br>    api_key=os.environ.get(<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>),<br><br>)<br><br>folder_path = <span class="hljs-string">&#x27;data&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Number of data entries to generate</span><br><br>n = <span class="hljs-number">50</span>  <span class="hljs-comment"># Adjust n to the desired number of data entries</span><br><br>  <br><br><span class="hljs-comment"># Loop to generate and print n data entries</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(n)):<br><br>    <span class="hljs-comment"># Define the prompt for each iteration</span><br><br>    prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    生成第<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>条数据。以下是一个示例和指令：</span><br><span class="hljs-string"></span><br><span class="hljs-string">    我给你一个例子，需要生成新的json数据</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#123;&#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;instruction&quot; : &quot;*******&quot;,</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;input&quot; : &quot;*********&quot;,</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;output&quot;:</span><br><span class="hljs-string"></span><br><span class="hljs-string">        &#123;&#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">            ******</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#125;&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    请生成更多这样的json数据,注意*****</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>  <br><br>    <span class="hljs-comment"># Generate the completion for the current iteration</span><br><br>    chat_completion = client.chat.completions.create(<br><br>        messages=[<br><br>            &#123;<br><br>                <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br><br>                <span class="hljs-string">&quot;content&quot;</span>: prompt,<br><br>            &#125;<br><br>        ],<br><br>        model=<span class="hljs-string">&quot;gpt-4-turbo-preview&quot;</span>,<br><br>        response_format=&#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;json_object&quot;</span> &#125;,<br><br>    )<br><br>    file_path = os.path.join(folder_path, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>.json&#x27;</span>)<br><br>    generated_content = chat_completion.choices[<span class="hljs-number">0</span>].message.content <span class="hljs-keyword">if</span> chat_completion.choices <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;No response&#x27;</span><br><br>    <span class="hljs-comment"># Save the generated data to a JSON file</span><br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br><br>        <span class="hljs-comment"># Assuming generated_content is a string in JSON format, directly write it</span><br><br>        file.write(generated_content)<br><br></code></pre></td></tr></table></figure><p>生成好之后需要对数据进行拼接，将多个json拼接成一个完整的即可。</p></li></ol><h3 id="2-2-2-校准数据"><a href="#2-2-2-校准数据" class="headerlink" title="2.2.2 校准数据"></a>2.2.2 校准数据</h3><p>校准数据就需要按照每种数据的需求，对关键点进行人工判断，修改出错的地方。</p><h3 id="2-2-3-转化数据"><a href="#2-2-3-转化数据" class="headerlink" title="2.2.3 转化数据"></a>2.2.3 转化数据</h3><p>经过测试，如果直接将json作为output输入给训练程序效果会不好。<br>可以使用json.dumps将output转化为字符串即可。</p><h1 id="3-后端实现"><a href="#3-后端实现" class="headerlink" title="3 后端实现"></a>3 后端实现</h1><p>在langchain和直接使用代码自己实现功能的两种选择中，选择直接自己用python实现相关功能，原因是：一是langchain中的向量数据库的知识库形式并不精准，在我们的应用中不能起到好的效果，二是如果使用langchain调用api没有必要，白白增加了一层应用，不如自己手动调用。<br>这里列举几个langchain使用的例子：<strong>针对特定文档的问答</strong>：根据给定的文档回答问题，使用这些文档中的信息来创建答案。<strong>Agents</strong>：开发可以决定行动、采取这些行动、观察结果并继续执行直到完成的代理。可以看出langchain是可以完成多agents功能，但是目前我们的任务流水执行暂时不需要让模型去选择调用哪个api，数据是单向流动，未来如果考虑减少使用到的模型的数量可能就需要使用langchain来做。</p><h2 id="3-1-服务器api"><a href="#3-1-服务器api" class="headerlink" title="3.1 服务器api"></a>3.1 服务器api</h2><p>服务器api这里需要实现一些查询功能以及计算的后处理功能。我选择Flask实现</p><p>查询部分：<br>    查询部分的内容非常清楚，如下表</p><table><thead><tr><th>端点</th><th>方法</th><th>参数/请求体</th><th>返回内容</th><th>状态码</th></tr></thead><tbody><tr><td><code>/get_location</code></td><td>GET</td><td><code>address</code>: 地名列表，逗号分隔</td><td>JSON格式的地点信息列表</td><td>200: 成功<br>404: 未找到数据</td></tr><tr><td><code>/get_jb</code></td><td>GET</td><td><code>name</code>: 军标名称列表，逗号分隔</td><td>JSON格式的军标信息列表</td><td>200: 成功<br>404: 未找到数据</td></tr><tr><td><code>/add_location</code></td><td>POST</td><td>JSON: 包含<code>地名</code>、<code>经度</code>、<code>纬度</code>和<code>高度</code>字段</td><td>确认信息</td><td>201: 成功添加<br>400: 请求中缺少JSON或数据</td></tr><tr><td><code>/update_location</code></td><td>POST</td><td>JSON: 包含<code>地名</code>、<code>经度</code>、<code>纬度</code>和<code>高度</code>字段</td><td>确认信息</td><td>200: 成功更新<br>400: 请求中缺少JSON或数据<br>404: 未找到地点</td></tr><tr><td><code>/get_id</code></td><td>GET</td><td>无</td><td>JSON格式，包含生成的随机ID</td><td>200: 成功</td></tr></tbody></table><p>计算部分：<br>    计算部分我在这里举个例子：<strong>此处已删除</strong></p><h2 id="3-2-大模型api"><a href="#3-2-大模型api" class="headerlink" title="3.2 大模型api"></a>3.2 大模型api</h2><table><thead><tr><th>端点</th><th>方法</th><th>摘要</th><th>请求体需求</th><th>响应类型及数据结构</th></tr></thead><tbody><tr><td><code>/v1/models</code></td><td>GET</td><td>列出模型</td><td>无</td><td>200: 成功，返回<code>ModelList</code></td></tr><tr><td><code>/v1/chat/completions</code></td><td>POST</td><td>创建聊天完成</td><td>需要，<code>ChatCompletionRequest</code></td><td>200: 成功，返回<code>ChatCompletionResponse</code><br>422: 验证错误</td></tr></tbody></table><p>使用python对大模型进行调用即可</p><h2 id="3-3-本地python"><a href="#3-3-本地python" class="headerlink" title="3.3 本地python"></a>3.3 本地python</h2><p>本地python对于各个大模型、服务器api按照流水进行使用即可，可以注意以下几点：</p><ol><li><p>在写整体的流水线处理的时候，因为每次调用都是<strong>输入文本-&gt;扩展prompt+调用插件-&gt;调用llm-&gt;结果的后处理</strong>。可以注意代码的复用，避免重复，未来也可以更好地扩展。</p></li><li><p>因为每次调用模型都要花费时间，所以加入日志记录模块可以很快的找到是输入、扩展prompt还是后处理哪一步出错了，日志中可以按我们处理的流程记录每一个文件生成的经过。</p></li><li><p>在遇到：营指挥所、指挥所 这种选择问题，可以考虑加入分词，比如jieba。预先创建分词数据库，使用最长前缀匹配可以很好的解决这种问题。在这个应用中，可以想到分词的功能可能不止这点，比如说在最初的文本输入后，实际上可以使用传统分词将所有的军标先提取出来，这样我们就得到了军标们和最初文本，然后每一次输入大模型的都是完整的文本，和军标之一，这样可以巧妙避免前后文相关的情况，但是同时对数据集的构造制造了更大的难度。</p></li></ol><h1 id="4-不足"><a href="#4-不足" class="headerlink" title="4 不足"></a>4 不足</h1><ol><li><strong>数据集数量影响模型效果</strong>：特别是在line、surface中，不同军标都需要有一部分自己的数据集，生成合理的数据集是一个庞大的任务。</li><li><strong>每种计算需要单独设计z</strong>：对于坐标的复杂计算，需要单独设计计算方式。</li><li><strong>需要再增加一个llm专门用于对坐标的解释</strong>：比如有的坐标和南北方位有关，但是南北的表示又有很多不同，所以需要设计一个llm对类似的坐标方位进行一个固定的转化，目前demo阶段并未设计实现。</li><li><strong>需要一种统一的文件</strong>：llm的表现和数据集的形式强相关，如果换一种文件输入，原来的数据集就需要重新生成，导致应用可用性会降低。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Intership</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notebook｜CUDA学习笔记</title>
    <link href="/2024/03/17/cu-1/"/>
    <url>/2024/03/17/cu-1/</url>
    
    <content type="html"><![CDATA[<p>最近一直在做高性能计算的事，但是从来没了解过 CUDA 相关的内容，刚好看到小彭老师的课，记录一下学到的东西。</p><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><ul><li>Cmake中启用 CUDA 支持<ul><li>最新版的 CMake（3.18 以上），只需在 LANGUAGES 后面加上 CUDA 即可启用。然后在 add_executable 里直接加你的 .cu 文件，和 .cpp 一样。</li></ul></li><li>CUDA 编译器兼容 C++17<ul><li>原来在使用 OpenCL 的使用，如果使用 vivado 的 HLS，host 和 device 的语法不能完全兼容，传递参数和参数的使用很不方便。</li><li>并且host 代码和 device 代码写在同一个文件内，这是 OpenCL 做不到的。</li></ul></li><li>编写一段在 GPU 上运行的代码<ul><li>CUDA 的核函数编写很方便，前面加上 __global__ 修饰符，即可让他在 GPU 上执行。但是调用的时候需要用 kernel&lt;&lt;&lt;1, 1&gt;&gt;&gt;() 这样的三重尖括号语法。</li><li>另外GPU 与 CPU 之间的通信是<strong>异步</strong>的，所以需要调用cudaDeviceSynchronize()。让 CPU 陷入等待，等 GPU 完成队列的所有任务后再返回。从而能够在 main 退出前等到 kernel 在 GPU 上执行完。同样因为这个异步通信，不能有返回值。</li><li>__device__ 则用于定义设备函数，他在 GPU 上执行，但是从 GPU 上调用的，而且不需要三重尖括号，和普通函数用起来一样，可以有参数，有返回值。host 可以调用 global；global 可以调用 device；device 可以调用 device。要注意的是默认情况下 GPU 函数必须定义在同一个文件里。如果你试图分离声明和定义，调用另一个文件里的 __device__ 或 __global__ 函数，就会出错。</li><li>inline 在现代 C++ 中的效果是声明一个函数为 weak 符号，和性能优化意义上的内联无关。CUDA 编译器提供了一个“私货”关键字：__inline__ 来声明一个函数为内联。</li><li>同样的，__hos__ 则相反，将函数定义在 CPU 上。如果不指定设备修饰符的话，就是默认 CPU 函数。如果这两个修饰符连用，就是 CPU、GPU 都可以调用。另外<strong>constexpr</strong>会自动变成CPU、GPU 都可以调用的函数。但是实际上也并不能完全替代，constexpr毕竟是代表着编译期间求职，遇到 print 一类的就不是很好使。</li><li>另外从 Kelper 架构开始，核函数调用核函数是被支持的__global__ 里可以调用另一个 __global__。</li></ul></li><li>通过 #ifdef 指令针对 CPU 和 GPU 生成不同的代码<ul><li>CUDA 具有多段编译的特点，一段代码他会先送到 CPU 上的编译器，再送到 GPU 的编译器，最后链接成同一个文件。GPU 的编译模式下，会定义__CUDA_ARCH__这个宏（host、device 混用的话，这个宏有点方便） __CUDA_ARCH__是一个整数，代表GPU 的架构版本号是多少。像下面的就可以控制不同版本使用不同的代码。</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702162016228.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702162016228"></li><li>可以用 CMAKE_CUDA_ARCHITECTURES 这个变量，设置要针对哪个架构生成 GPU 指令码。如果不指定，编译器默认的版本号是 52，他是针对 GTX900 系列显卡的。也可以指定多个版本号，之间用分号分割。</li></ul></li></ul><h1 id="线程与板块"><a href="#线程与板块" class="headerlink" title="线程与板块"></a>线程与板块</h1><ul><li>三重尖括号<ul><li>&lt;&lt;&lt;板块数量，每个板块中的线程数量&gt;&gt;&gt;</li></ul></li><li>板块、线程<ul><li>板块的编号可以用 blockIdx.x 获取。板块的总数可以用 gridDim.x 获取。</li><li>板块之间是高度并行的，不保证执行的先后顺序。</li><li>当前线程在板块中的编号：threadIdx</li><li>当前板块中的线程数量：blockDim</li><li>当前板块的编号：blockIdx</li><li>总的板块数量：gridDim</li><li>从属关系：线程＜板块＜网格</li><li>实际上 GPU 的板块相当于 CPU 的线程，GPU 的线程相当于 CPU 的SIMD，可以这样理解，但不完全等同。</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702163845832.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702163845832"></li></ul></li><li>CUDA 也支持三维的板块和线程区间。<ul><li>只要在三重尖括号内指定的参数改成 dim3 类型即可。dim3 的构造函数就是接受三个无符号整数（unsigned int）非常简单。</li><li>实际上一维的 &lt;&lt;&lt;m, n&gt;&gt;&gt; 不过是 &lt;&lt;&lt;dim3(m, 1, 1), dim3(n, 1, 1)&gt;&gt;&gt; 的简写而已。同样二维也是支持的。</li></ul></li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul><li>如何从核函数里返回数据？<ul><li>由于调用是异步的，所以不能直接通过 return来返回数据。那怎么得到数据呢？</li><li>可以通过指针，但是要确定在同一块设备上，GPU 上就要是显存分配的空间。</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702165733213.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702165733213"></li><li>但是反之，如果这个操作处理完了怎么取得这个值？CPU 显然也无法直接访问 GPU 显存上的变量。因此可以用 cudaMemcpy，他能够在 GPU 和 CPU 内存之间拷贝数据。这里我们希望把 GPU 上的内存数据拷贝到 CPU 内存上，也就是从设备内存(device)到主机内存(host)，因此第四个参数指定为 cudaMemcpyDeviceToHost。同理，还有 cudaMemcpyHostToDevice 和 cudaMemcpyDeviceToDevice。要注意的是cudaMemcpy 会自动同步</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702165944038.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702165944038"></li></ul></li><li>统一内存地址技术<ul><li>比较新的显卡上面支持统一内存地址技术。只需把 cudaMalloc 换成 cudaMallocManaged 即可，释放时也是通过 cudaFree。这样分配出来的地址，不论在 CPU 还是 GPU 上都是一模一样的，都可以访问。而且拷贝也会自动按需进行（当从 CPU 访问时），无需手动调用 cudaMemcpy，大大方便了编程人员，特别是含有指针的一些数据结构。统一内存是从 Pascal 架构开始支持的，也就是 GTX9 开头及以上。虽然方便，但并非完全没有开销，有条件的话还是尽量用分离的设备内存和主机内存吧。</li></ul></li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>分配数组<ul><li>如 malloc 一样，可以用 cudaMalloc 配合 n * sizeof(int)，分配一个大小为 n 的整型数组。这样就会有 n 个连续的 int 数据排列在内存中，而 arr 则是指向其起始地址。然后把 arr 指针传入 kernel，即可在里面用 arr[i] 访问他的第 i 个元素。</li><li>可以利用 GPU 的优势，多个线程并行的给数组赋值<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702184800416.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702184800416"></li></ul></li></ul></li><li>网格跨步循环<ul><li>无论调用者指定了多少个线程（blockDim），都能自动根据给定的 n 区间循环，不会越界，也不会漏掉几个元素。这样一个 for 循环非常符合 CPU 上常见的 parallel for 的习惯，又能自动匹配不同的 blockDim，看起来非常方便。下面是只考虑线程的网格跨步循环。<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702185050587.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702185050587"></li></ul></li><li>当然同样的也可以考虑不同板块<ul><li>核函数内部，用之前说到的 blockDim.x * blockIdx.x + threadIdx.x 来获取线程在整个网格中编号。因此，我们可以用 n / 128 作为 gridDim，这样总的线程数刚好的 n，实现了每个线程负责处理一个元素。</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702185413346.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702185413346"></li><li>但是上面的话，如果不是可以被整除的话，最后几个数会被遗忘。所以选择向上取整的方法去做。</li><li>下面是线程板块都考虑的网格跨步循环<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702185615377.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702185615377"></li></ul></li></ul></li></ul></li></ul><h1 id="C-封装"><a href="#C-封装" class="headerlink" title="C++封装"></a>C++封装</h1><ul><li><p>sdt::vector的第二参数</p><ul><li><p>有两个模板参数：std::vector&lt;T, AllocatorT&gt;，（我之前在写推理器的时候也使用到了类似的，只是不清楚原来vector 已经自带了）下面是我原来写的内存分配器的代码，分配 cuda 的也类似。</p></li><li><pre><code class="c++">class CpuAllocator : public DeviceAllocator &#123;    public:        explicit CpuAllocator() : DeviceAllocator(DeviceType::kDeviceCPU) &#123;&#125;        void *allocate(size_t size) override;        void deallocate(void *ptr) override;        DeviceType device_type() override;    &#125;;void *CpuAllocator::allocate(size_t size) &#123;        void *ptr = nullptr;        if (size &gt; 0) &#123;            ptr = malloc(size);        &#125;        return ptr;    &#125;    void CpuAllocator::deallocate(void *ptr) &#123;        if (ptr) &#123;            free(ptr);        &#125;    &#125;</code></pre></li><li><p>回到 vector，他的第二个模板参数std::allocator&lt;T&gt;同样负责分配和释放内存，初始化 T 对象等。它具有如下几个成员函数</p><ul><li>T *allocate(size_t n)            // 分配长度为n，类型为T的数组，返回其起始地址</li><li>void deallocate(T *p, size_t n)    // 释放长度为n，起始地址为p，类型为T的数组</li></ul></li><li><p>默认的成员函数会调用标准 malloc 和 free 去分配和释放内存空间，所以我们去替换标准 allocator 就可以使得 vector 可以分配和释放显存。</p></li><li><p>另外要注意如果初始化，会调用 CPU 的初始化，所以需要禁用这个vector初始化，所以只需要判断是不是有参数和是否是传统 C 语言类型，如果是就跳过即可，如下图。</p></li><li><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702190722784.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702190722784"></p></li></ul></li><li><p>核函数可以是一个模板函数</p><ul><li>CUDA 的优势在于对 C++ 的完全支持。所以 __global__ 修饰的核函数自然也是可以为模板函数的。</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702190855097.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702190855097"></li></ul></li><li><p>核函数可以实现函数式编程</p><ul><li>需要注意三点：这里的 Func 不可以是 Func const &amp;，那样会变成一个指向 CPU 内存地址的指针，从而出错。所以 CPU 向 GPU 的传参必须按值传；做参数的这个函数必须是一个有着成员函数 operator() 的类型，即 functor 类。而不能是独立的函数，否则报错。；这个函数必须标记为 __device__，即 GPU 上的函数，否则会变成 CPU 上的函数。<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702191105203.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702191105203"></li></ul></li><li>另外也可以用 lambda 表达式，但是需要开启--extended-lambda编译开关<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702191157761.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702191157761"></li><li>另外如果用 [&amp;] 捕获变量是会出错的，毕竟这时候捕获到的是堆栈（CPU内存）上的变量 arr 本身，而不是 arr 所指向的内存地址（GPU内存）这个 lambda 表达式的捕获有点复杂。也不可以直接使用[=] 按值捕获（因为vector 的拷贝是深拷贝（绝大多数C++类都是深拷贝，除了智能指针和原始指针）。这样只会把 vector 整个地拷贝到 GPU 上！而不是浅拷贝其起始地址指针。）</li><li><strong>正确的捕获做法是先获取 arr.data() 的值到 arr_data 变量，然后用 [=] 按值捕获 arr_data，函数体里面也通过 arr_data 来访问 arr。因为 data() 返回一个起始地址的原始指针，而原始指针是浅拷贝的，所以可以拷贝到 GPU 上，让他访问。这样和之前作为核函数参数是一样的，不过是作为 Func 结构体统一传入了。</strong><ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702191643122.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702191643122"></li></ul></li></ul></li></ul></li></ul><h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><ul><li>经典案例，并行的求 sin 值<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702191810745.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702191810745"></li><li>可以看到上面就是很标准的跨步网格循环。</li><li>sinf 是 sin 的 float 型。__sinf 是GPU intrinstics，精度相当于 GLSL 里的那种。适合对精度要求不高，但有性能要求的图形学任务。很快但是相比较而言不准确。如果开启了<strong>--use_fast_math</strong>编译器选项，那么所有对 sinf 的调用都会自动被替换成 __sinf。</li></ul></li><li><strong>SAXPY</strong>（Scalar A times X Plus Y）<ul><li>标量 A 乘 X 加 Y。</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702192407003.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702192407003"></li></ul></li></ul><h1 id="thrust库"><a href="#thrust库" class="headerlink" title="thrust库"></a>thrust库</h1><p>thrust 库是 nvidia 对stl 的 cuda 化，thrust 模板函数的特点：根据容器类型，自动决定在 CPU 还是 GPU 执行</p><ul><li><p>CUDA 官方提供的 thrust::universal_vector</p><ul><li>universal_vector 会在统一内存上分配，因此不论 GPU 还是 CPU 都可以直接访问到。因此就用他们的好啦。</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702192610954.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702192610954"></li></ul></li><li><p>device_vector和 host_vector</p><ul><li>而 device_vector 则是在 GPU 上分配内存，host_vector 在 CPU 上分配内存。</li><li>但是优势在于可以通过 = 运算符在 device_vector 和 host_vector 之间拷贝数据，他会自动帮你调用 cudaMemcpy，非常智能。</li></ul></li><li><p>thrust::generate</p><ul><li>thrust 提供了很多类似于标准库里的模板函数，比如 thrust::generate(b, e, f) 对标 std::generate，用于批量调用 f() 生成一系列（通常是随机）数，写入到 [b, e) 区间。</li></ul></li><li><p>thrust::for_each</p><ul><li>还有 thrust::for_each(b, e, f) 对标 std::for_each。他会把 [b, e) 区间的每个元素 x 调用一遍 f(x)。这里的 x 实际上是一个引用。如果 b 和 e 是常值迭代器则是个常引用，可以用 cbegin()，cend() 获取常值迭代器。</li><li>当然还有 thrust::reduce，thrust::sort，thrust::find_if，thrust::count_if，thrust::reverse，thrust::inclusive_scan 等。</li></ul><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1></li></ul><p>并行操作总会带来锁的问题</p><ul><li>数组求和<ul><li>如何并行地对数组进行求和操作？</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702193117078.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" style="zoom:50%;" /></li><li>显而易见，取数与计算并写回不是原子操作导致了这个问题。因此使用 CUDA 提供的atomicAdd就可以处理这个问题：atomicAdd(dst, src) 和 *dst += src 差不多。<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702194636012.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702194636012"></li></ul></li></ul></li><li>还有不少其他的原子操作，以后遇到再补充<ul><li>atomicAdd(dst, src)：<em>dst += src</em></li><li><em>atomicSub(dst, src)：</em>dst -= src</li><li>atomicOr(dst, src)：<em>dst |= src</em></li><li><em>atomicAnd(dst, src)：</em>dst &amp;= src</li><li>atomicXor(dst, src)：<em>dst ^= src</em></li><li><em>atomicMax(dst, src)：</em>dst = std::max(<em>dst, src)</em></li><li><em>atomicMin(dst, src)：</em>dst = std::min(*dst, src)</li></ul></li><li>原子操作最直观带来的就是速度问题。</li></ul><h1 id="板块与共享内存"><a href="#板块与共享内存" class="headerlink" title="板块与共享内存"></a>板块与共享内存</h1><ul><li>为什么需要分出板块的概念呢？<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702195410450.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702195410450"></li><li>GPU 是由多个流式多处理器（SM）组成的。每个 SM 可以处理一个或多个板块。SM 又由多个流式单处理器（SP）组成。每个 SP 可以处理一个或多个线程。每个 SM 都有自己的一块共享内存（shared memory），他的性质类似于 CPU 中的缓存——和主存相比很小，但是很快，用于缓冲临时数据。通常板块数量总是大于 SM 的数量，这时英伟达驱动就会在多个 SM 之间调度你提交的各个板块。正如操作系统在多个 CPU 核心之间调度线程那样。不过有一点不同，GPU 不会像 CPU 那样做时间片轮换——板块一旦被调度到了一个 SM 上，就会一直执行，直到他执行完退出，这样的好处是不存在保存和切换上下文（寄存器，共享内存等）的开销，毕竟 GPU 的数据量比较大，禁不起这样切换来切换去。一个 SM 可同时运行多个板块，这时多个板块共用同一块共享内存（每块分到的就少了）。而板块内部的每个线程，则是被进一步调度到 SM 上的每个 SP。</li></ul></li><li>无原子操作的求和<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702200028885.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702200028885"></li><li>声明 sum 为比原数组小 1024 倍的数组。然后在 GPU 上启动 n / 1024 个线程，每个负责原数组中 1024 个数的求和，然后写入到 sum 的对应元素中去。因为每个线程都写入了不同的地址，所以不存在任何冲突，也不需要原子操作了。然后求出的大小为 n / 1024 的数组，已经足够小了，可以直接在 CPU 上完成最终的求和。也就是 GPU 先把数据尺寸缩减 1024 倍到 CPU 可以接受的范围内，然后让 CPU 完成的思路。</li><li>本质上就是牺牲了最后一点时间以及空间，换来需要原子操作的这部分时间。但是每个线程中仍然是明显的串行操作。因此可以采用分布缩减法来改造成真正的并行（这个有点像计算机组成原理里面一种访存方式）<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702202043373.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702202043373"></li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702202141034.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702202141034"></li><li>另外这样修改需要把 local_sum 数组声明为 volatile 禁止编译器优化</li></ul></li></ul></li><li>线程组分歧<ul><li>GPU 线程组（warp）中 32 个线程实际是绑在一起执行的，就像 CPU 的 SIMD 那样。因此如果出现分支（if）语句时，如果 32 个 cond 中有的为真有的为假，则会导致两个分支都被执行！不过在 cond 为假的那几个线程在真分支会避免修改寄存器和访存，产生副作用。而为了避免会产生额外的开销。因此建议 GPU 上的 if 尽可能 32 个线程都处于同一个分支，要么全部真要么全部假，否则实际消耗了两倍时间！<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702202332465.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702202332465"></li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702202340263.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702202340263"></li></ul></li><li>因此前面的代码可以修改为以下的形式<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702202443489.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702202443489"></li></ul></li><li>虽然用了 atomicAdd 按理说是非常低效的，然而却没有低效，这是因为编译器自动优化成刚刚用 BLS 的数组求和了！可以看到他优化后的效率和我们的 BLS 相仿，甚至还要快一些！</li></ul></li></ul><h1 id="共享内存进阶"><a href="#共享内存进阶" class="headerlink" title="共享内存进阶"></a>共享内存进阶</h1><p>需要对 cuda 的内存管理有更进一步的了解。</p><ul><li>寄存器数量有限<ul><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/image-20240702203113885.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg6aHR0cDovL3d3dy5hdXN3aXR6LnRvcC8/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/5" alt="image-20240702203113885"></li><li>可以看到每个 SM 都有自己的寄存器，但是如果板块数量过多的话就会出现寄存器打翻现象。导致每个线程能够分配到的寄存器数量急剧缩小。而如果你的程序恰好用到了非常多的寄存器，那就没办法全部装在高效的寄存器仓库里，而是要把一部分“打翻”到一级缓存中，这时对这些寄存器读写的速度就和一级缓存一样，相对而言低效了。若一级缓存还装不下，那会打翻到所有 SM 共用的二级缓存。</li><li>板块中的线程数量过少：延迟隐藏（latency hiding）失效：当线程组陷入内存等待时，可以切换到另一个线程，继续计算，这样一个 warp 的内存延迟就被另一个 warp 的计算延迟给隐藏起来了。因此，如果线程数量太少的话，就无法通过在多个 warp 之间调度来隐藏内存等待的延迟，从而低效。</li><li><strong>因此对于使用寄存器较少、访存为主的核函数（例如矢量加法），使用大 blockDim 为宜。反之（例如光线追踪）使用小 blockDim，但也不宜太小。</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notebook</category>
      
      <category>高性能并行编程与优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notebook|MYSQLNoteBook||数据库系统原理笔记</title>
    <link href="/2023/03/26/MYSQLNoteBook/"/>
    <url>/2023/03/26/MYSQLNoteBook/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h1><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-1.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="1"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-2.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="2"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-3.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="3"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-4.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="4"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-5.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="5"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-6.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="6"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-7.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="7"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-8.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="8"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-9.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="9"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-10.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="10"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-11.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="11"></p>]]></content>
    
    
    <categories>
      
      <category>Notebook</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notebook|CcNotebook||计算机组成原理笔记</title>
    <link href="/2023/03/25/CcNoteBook/"/>
    <url>/2023/03/25/CcNoteBook/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-1.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="1"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-2.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="2"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-3.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="3"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-4.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="4"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-6.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="6"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-7.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="7"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-8.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="8"></p>]]></content>
    
    
    <categories>
      
      <category>Notebook</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notebook|CNetNotebook||计算机网络自顶向下方法笔记</title>
    <link href="/2023/03/01/CNetNotebook/"/>
    <url>/2023/03/01/CNetNotebook/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><blockquote><p>按照《计算机网络自顶向下》的目录整理的相关笔记</p><p>和之前比更新了很多东西，也删除了很多模糊或者不算重要的知识点。除了第一章整理的还不算清楚之外，其他的都应该清楚了。</p></blockquote><h1 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1. 计算机网络"></a>1. 计算机网络</h1><p>构成因特网的软件和硬件，根据分布式应用提供服务的联网基础设施来描述因特网</p><blockquote><p>世界范围内的计算机网络 因特网就是将端系统彼此互联</p></blockquote><h2 id="1-1-具体构成和描述"><a href="#1-1-具体构成和描述" class="headerlink" title="1.1 具体构成和描述"></a>1.1 具体构成和描述</h2><h3 id="端系统，分组Packet"><a href="#端系统，分组Packet" class="headerlink" title="端系统，分组Packet"></a>端系统，分组Packet</h3><ul><li>所有连接的设备，叫做主机或者端系统 HOST END SYSTEM</li><li>端系统通过通信链路communication link和分组交换机连接在一起</li><li>通信链路又不同类型的物理媒介组成，链路的传输速率为 BIT/S bps 比特每秒来计算</li><li>分组Packet，发送端将数据分段并为每段加上首部字母，这样的信息包叫做分组</li></ul><h3 id="分组交换机"><a href="#分组交换机" class="headerlink" title="分组交换机"></a>分组交换机</h3><ul><li>分组交换机，从交换机的一条入链路将分组转发并从出通信链路发出</li><li>分组交换机包括，路由器Router，链路层交换机Link-layer switch</li><li>链路层交换机用于接入网，路由器用于核心网</li></ul><h3 id="通信链路"><a href="#通信链路" class="headerlink" title="通信链路"></a>通信链路</h3><ul><li>从发送端到接收端系统，一个分组所经历的一系列的通信链路和分组交换机称为通过该网络的路径，Path Route</li><li>分组类似于运载货物的卡车，通信链路类似于公路，分组交换机类似于立交桥；</li><li>链路的速率，主要取决于分组交换机的转发能力： RM bps表示路由器在1S内可以完成R兆bit的转发</li></ul><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><ul><li>端系统由 ISP internet service provider 接入因特网</li><li>每个ISP是一个由多个分组交换机和多段通信链路组成的网络，各ISP为端系统提供了各种不同类型的网络接入</li><li>底层ISP通过国际的高层ISP互联，独立管理，运行着IP协议</li><li>调制解调？</li></ul><h3 id="协议-Protocol"><a href="#协议-Protocol" class="headerlink" title="协议 Protocol"></a>协议 Protocol</h3><ul><li><p>协议控制着网络中或因特网中的信息接受和发送，TCP和IP协议是最重要的两个协议，主协议统称为TCP/IP</p></li><li><p>TCP Transmission Control Protocol 控制传输协议</p></li><li><p>IP Internet Protocol 网际协议，IP协议定义了在路由器和端系统之间发送和接受的分组格式</p></li><li><p>背景，Internet Standard 由 InternetEngineering Task Force研发，其他组织也会制定标准，例如以太网标准，Wi-Fi标准</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-20210711134244371.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="20210711134244371"></p></li></ul><h3 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h3><ul><li>应用程序提供服务的基础设施：分布式应用程序 distributed application，application运行在端系统上，分组交换机并不关心作为数据源或者宿的应用程序</li><li>端系统提供应用程序编程接口，API，API规定了运行在一个端系统上的软件向另一个端系统的特定目的地软件交付数据的方式</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>因特网中涉及两个或者多个远程通信的实体活动都受到协议的制约，交换报文或者采取动作的实体是硬件或者软件</li><li>硬件实现的协议控制了在两块“接口卡”之间的“线上”比特流</li><li>端系统中，拥塞控制协议控制了发送方和接受方之间传输的分组Packet发送频率</li><li><strong>一个协议定义了两个或者多个通信实体之间的交换的报文格式和次序，以及报文发送和接受所采取的动作（一系列约定俗成的动作）</strong>；</li><li>构成，原理，工作方式；</li></ul><h2 id="1-2-网络边缘-边缘计算"><a href="#1-2-网络边缘-边缘计算" class="headerlink" title="1.2 网络边缘 - 边缘计算"></a>1.2 网络边缘 - 边缘计算</h2><ul><li>在因特网中处于边缘的系统，叫做端系统；</li><li><strong>主机 = 端系统 HOST = END SYSTEM</strong> ，主机被划分为两类：Clinet和Server。web服务器属于大型的数据中心Data Center，client通常为桌面级pc和手机等，server为更为强大的服务器</li></ul><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><ul><li><p>端系统和应用程序位于网络边缘，access network，接入网是将端系统接到其边缘路由器的物理链路（edge router）- 端系统接入边缘路由的链路</p></li><li><p>边缘路由器，<strong>是端系统到其他任何远程端系统路径上的第一台路由器</strong></p><blockquote><p>端系统 —(A)— 边缘路由（第一台路由） A:这样的一条链路称为接入网</p></blockquote></li><li><p>上下行速率由编码频率控制，频率越高，速度越高，家庭DSL，家庭接入同轴电缆</p></li><li><p>调制解调为外部设备</p></li><li><p>物理链路的搭建方式 </p></li></ul><h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><ul><li>数字用户线和电缆</li></ul><h3 id="以太网和wifi"><a href="#以太网和wifi" class="headerlink" title="以太网和wifi"></a>以太网和wifi</h3><ul><li>局域网将端系统连接到边缘路由，以太网为接入技术</li></ul><h3 id="广域无线接入"><a href="#广域无线接入" class="headerlink" title="广域无线接入"></a>广域无线接入</h3><ul><li>5G</li></ul><h3 id="物理媒介"><a href="#物理媒介" class="headerlink" title="物理媒介"></a>物理媒介</h3><ul><li>通过跨越物理媒介 Physical Medium传播电磁波活着光脉冲来发送bit；</li><li>物理媒介：引导型媒介，电磁波沿着物理媒介前进；非引导型媒介，电磁波沿着空气前进</li><li>双绞铜线、同轴电缆、光纤等</li></ul><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><ul><li>网络核心：<strong>由互联因特网端系统的分组交换机和链路构成的网状网络</strong>；</li><li><strong>分组交换机包括路由和链路层交换机</strong>；</li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li><p>端系统彼此交换报文（message），报文包含了协议设计者需要的所有的东西；</p></li><li><p>源端系统向目的端系统发送一个报文，“源”将长报文划分为较小的数组快，为“分组”Packet；</p></li><li><p>在源和目的之间，每个分组都通过通信链路的分组交换机（packet swith）传送；路由器和链路层交换机</p></li><li><p>每个分组以等于该链路最大传输速率的速度传输通过通信链路</p></li><li><p>一个Lbit的分组，链路速率为Rbit/s，则传输时间为L/R s</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230227175614947.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230227175614947"></p></li></ul><h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><ul><li>指交换机在开始向输出链路传输该分组的第一个bit前，必须已经接收到了整个分组；缓存分组比特，当路由器由输入链路接收完了整个分组后（此时花费L/R的时间），才开始向出链路传输（传输完成需要花费L/R），总延时为2L/R s</li><li>N条速录为R的链路，转发一个分组，d源到端 = N L/R</li></ul><h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><ul><li>每个分组交换机与多条线路相连，分组交换机有一个输出缓存，output buffer，output Queue；到达的分组的传输链路处于繁忙状态，传输其他分组，达分组会在“输出缓存”中等待；</li><li>时延，1. 存储转发时延，2. 排队时延，时延处于变化的状态，变化程度取决于网络中的拥塞程度</li><li>丢包，一个分组发现“输出缓存”已经被其他的等到传输的分组完成充满了，这时就会出现“分组丢包”，Packet lost，到达分组或者已经排队的分组之一会被丢弃；</li><li>分组达到率（每秒比特）超过了输出链路的速率，这些分组在通过链路传输前，在“链路输出缓存中排队”，在该路由器中将出现拥塞；</li></ul><h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><ul><li>因特网中，每个端系统具有IP地址，源向目的端发送分组，分组的首部都包含了IP地址；</li><li>路由器具有转发表，forwarding table，用于将目的地址（或者地址中的几段）映射为输出链路；</li><li>分组到达路由器，路由器检查分组地址，并用目的地址搜索转发表，发现出链路，则将该分组导向出链路；</li><li>转发表配置问题，路由选择协议 routing protocol，用于自动设置转发表；</li></ul><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>网络链路和交换机转发数据的两种基本方式：1. 电路交换 2. 分组交换；</li><li>电路交换需要提前预留报文要使用的资源，缓存链路传输速率等，传统的电话就是一种电路交换，连接期间预留了恒定的传输速率；</li><li>实现方式：频分复用 Frequency-Division Multiplexing， 时分复用Time-Division Multiplexing；</li><li>带宽 bandwidth：频段的宽度 80——100Mhz；</li><li>相关计算在P21</li></ul><h3 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h3><ul><li><p>分组交换的性能优于电路交换；</p><blockquote><p>例子：假设10个用户，某个用户产生1000个1000bit的分组，其他用户保持静默。每帧具有10个间隙且每个间隙保护1000bit的TDM电路交换情况下，活跃用户只能使用每帧中的一个间隙来传输数据，传完1000，000的bit数据需要10S时间，而分组交换的情况下，活跃用户能连续的以1Mbps的速率使用链路，完成数据的发送只需要1S；</p></blockquote></li><li><p>电路交换需要预先分配传输链路，使得已分配但是不需要的链路时间未被使用；分组交换按需分配链路使用，链路传世能力在所有用户之间逐分组共享；</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分组交换</td><td>① 加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输一份报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的机率及等待的时间也必然少得多。② 简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。③ 减少了出错机率和重发数据量。因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。④ 由于分组短小，更适用于采用优先级策略。</td><td>① 尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。② 分组交换中的每个分组都要加上源、目的地址和分组编号等信息，这将增大传送的信息量，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。③ 当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</td></tr><tr><td>电路交换</td><td>① 由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。② 通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。③ 双方通信时按发送顺序传送数据，不存在失序问题。④ 电路交换既适用于传输模拟信号，也适用于传输数字信号。⑤ 电路交换设备控制均较简单。</td><td>① 电路交换的平均连接建立时间对计算机通信来说偏长。② 电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用低。③ 电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。</td></tr></tbody></table></li></ul><h3 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h3><ul><li>十多个第一层ISP和数十万个底层ISP组成，ISP覆盖大洲，大洋，有些覆盖小的地理区域；底层与高层互联，高层彼此互联；</li></ul><h2 id="1-4-分组交换网中的时延、丢包、吞吐量"><a href="#1-4-分组交换网中的时延、丢包、吞吐量" class="headerlink" title="1.4 分组交换网中的时延、丢包、吞吐量"></a>1.4 分组交换网中的时延、丢包、吞吐量</h2><ul><li><p>时延：节点处理时延，排队时延，传输时延，传播时延，节点总时延；</p></li><li><p>处理时延，检查分组首部需要的处理时延，用来决定将该分组导向何处</p></li><li><p>排队时延，分组在链路上等待传输是排队的时延（“输出缓存” output buffer）</p></li><li><p>传输时延/发送时延，<strong>数据长度/信道带宽</strong> 先到先服务，仅当所有已到达分组被传输后，才能传输刚到达的分组，链路速率R bps，R个bit每秒，时延=分组比特/链路速率，毫秒微秒量级</p></li><li><p>传播时延，<strong>信道长度/传播速率</strong>，是分组从一个路由器传输到另一个路由器，所在的链路的传播需要的时间，它和链路的物理长度及物理媒介有关，和链路的速率以及分组长度无关；</p></li><li><p>区别：传输时延是由路由器将整个分组推出所需要的时间，这里的速率完全取决于路由器的转发能力，R Mbps表示路由器在1S内可以完成R兆bit的转发，速率也和编码频率有关； 传播时延表示分组或者数据比特在物理或者媒介中传播所需要的时间；</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228151743340.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228151743340"></p></li></ul><h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><ul><li>排队时延取决于流量到达该队列的速率，链路传输的速率和流量到达的性质；</li><li>R表示链路的传输速率，就是从队列中推出bit的速率 bps</li><li>假设a表示分组达到队列的速率，L表示分组的比特数量，则La bps表示比特到达队列的平均速率，La/R为 流量强度 traffic intensity； 流量强度不能大于 1</li></ul><h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h3><ul><li>随着”流量强度” 接近1，分组交换机或路由器将会对已经满了的队列，丢弃新的分组，Drop，该分组将会丢失Lost；</li><li>一个结点的性能是根据分组的丢失概率来度量的；</li></ul><h3 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h3><ul><li>N-1台路由器 总时延 = N （主机和路由器上的处理时延 + 链路传播时延 + 传输时延L/R</li><li>traceroute软件做时延分析</li></ul><h3 id="端系统、应用程序、其他时延"><a href="#端系统、应用程序、其他时延" class="headerlink" title="端系统、应用程序、其他时延"></a>端系统、应用程序、其他时延</h3><ul><li>对于某些协议，端系统application处理的延时；</li></ul><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li><strong>单位时间通过某个接口的数据量</strong></li><li>瞬时吞吐量：端系统接受到该文件的速率 bps，例如下载文件的的速率显示</li><li>平均吞吐量：F比特的文件，主机接收到所以的bit用了T秒时间，平均吞吐量为F/T</li><li>有些Application中吞吐量比时延更重要；</li><li>Rs表示服务器与路由器之间的链路速率，Rc表示路由器和客户端之间的链路速率，对于Server来说他的吞入量为min{Rs, Rc}，这里的吞入量为瓶颈链路速率，bottleneck link，当然这里的吞吐量还需要考虑分组层次和传输协议的问题；</li><li>吞吐量取决于数据流过链路的传输速率；在没有其他条件干扰时，吞吐量近似等于源和目的之间的最小传输速率；</li></ul><h3 id="bandwidth-带宽"><a href="#bandwidth-带宽" class="headerlink" title="bandwidth 带宽"></a>bandwidth 带宽</h3><ul><li><p><strong>网络设备所能支持的最高速度</strong>，理想的极限传输速率</p></li><li><p>Bandwidth (signal processing) or analog bandwidth, frequency bandwidth or radio bandwidth, a measure of the width of a range of frequencies, measured in hertz</p></li><li><p>Bandwidth (computing), the rate of data transfer, bit rate or throughput, measured in bits per second (bit/s)</p></li><li><p>Spectral linewidth, the width of an atomic or molecular spectral line, measured in hertz</p></li><li><p>对于信号处理中，bandwidth表示当前信号的频段宽度，例如模拟信号或者数字信号的”频率范围“ hz为单位</p></li><li><p>对于计算机网路链路，带宽为当前最大传输速率，没秒钟链路能够传输或处理的比特，bit/s为单位，注意在电路交换中带宽表示的是频率范围；</p></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><ul><li>*<em>时延带宽积(bit)=传播时延(s)<em>带宽(bit/s)</em></em></li><li>时延带宽积是描述一个链路中，此时此刻的bit数量<h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3></li><li>从发送方发送数据开始，到发送方收到接收方的确认（接收方收到后立即发送确认），总共经历的时延</li><li>RTT包括：*<em>2</em>传播时延、末端处理时间**<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3></li><li>信道利用率=有数据通过时间/总共时间</li><li>网络利用率=信道利用率加权平均值</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228152734030.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228152734030"><h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h2></li></ul><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><ul><li>网络以分层的方式组织协议，某层会向上一层提供服务，就是服务模型；</li><li>应用层协议在端系统中以软件方式实现，物理层和数据链路层则复杂处理跨越链路的通信，通常实现在给定的接口卡中；网络层则有软硬件的混合；</li></ul><h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><ul><li>各层所有的协议被称为协议栈 protocol stack</li><li>因特网的协议栈由5层组成 <strong>1. 物理层 2. 数据链路层 3. 网络层 4. 传输层 5. 应用层</strong></li><li><strong>应用层</strong>：<strong>用户与网络的界面</strong>，网络应用程序之间定义的协议留存的分层，分布在多个端系统上，一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，位于应用层的信息分组称为报文（message）<strong>FTP、SMTP、HTTP</strong></li><li>表示层：数据格式的变换、数据的解密加密、数据的压缩和恢复</li><li>会话层：像表示层提供建立连接并且有序的传输数据</li><li><strong>传输层</strong>、运输层：用于传输应用层报文，主要有TCP和UDP，TCP向他的应用程序提供了面向连接的服务。TCP也将长报文划分为短报文，提供拥塞机制；TCP源代码；UDP无连接，不提供服务的服务，运输分组可以称为<strong>报文段 segment</strong>，端到端的通信。<strong>可靠传输、差错控制、流量控制、复用分用功能</strong>   主要协议： <strong>TCP、UDP</strong></li><li><strong>网络层</strong>：分组单位是<strong>数据报 datagram</strong>，将数据报 datagram 的网络层分组从一台主机移动到另一台主机；源主机中TCP或者UDP运输协议向网络层递交运输层报文段segment和目的地址，网络层IP协议定义了数据报中的各个字段和端系统及路由器如何作用这些字段，IP协议和路由选择协议，IP协议连接了硬件和软件层；</li><li><strong>数据链路层</strong>：分组单位是<strong>帧 Frame</strong>，网络层从源到目的之间经过路由器路由数据报，将分组从一个结点移动到另一个结点，必须“依靠数据链路层的服务”，网络层将数据报下传给链路层，链路层沿着链路将数据传递给下个结点，下个结点链路层又将数据报上报给了网络层；链路层提供的服务取决于链路层的协议。链路层的分组为”帧“Frame，以太网，Wi-Fi，DOCsis；</li><li><strong>物理层</strong>：<strong>在物理媒体上实现比特流的传输</strong>，物理层的任务是将链路层中的帧中的一个一个bit从一个结点移动到下一个结点，物理层协议于链路相关，也与物理介质相关，例如同轴电缆卡，光纤；</li></ul><h3 id="OSI、TCP-IP与五层参考模型"><a href="#OSI、TCP-IP与五层参考模型" class="headerlink" title="OSI、TCP/IP与五层参考模型"></a>OSI、TCP/IP与五层参考模型</h3><ul><li><p>ISO国际标准化组织提出OSI，开发系统互联模型，理论模型，服务、协议、接口。</p></li><li><p>与之相对的TCP/IP参考模型有四层</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228144700581.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228144700581"></p></li><li><p>应用层 表示层 会话层 传输层 网络层 链路层 物理层</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-1-1Z1241445324H.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="OSI 七层网络模型和 TCP/IP 四层网络模型的对比"></p><ul><li>五层参考模型</li></ul><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228145106620.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228145106620"></p></li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote><p>应用层 报文 mesasge 传输层 报文段 segment = message + header 网络层 数据报 datagram = segment + header<br>链路层 帧 frame = datagram + header 物理层</p></blockquote><ul><li>application-layer message — transport-layer segment — network-layer datagram — link-layer frame</li><li>链路层交换机实现第一层和第二层，路由器实现第一层到第三层，路由器能够实现IP协议，链路交换机不能，链路层交换机能够实现第二层地址，以太网地址；网络边缘的端系统可以实现一到五层，将复杂性较高的结构放在边缘；</li><li>封装 （encapsulation）：在发送端，一个应用层报文（application-layer message） — 应用层报文+传输层首部=运输层报文段（transport-layer segment） — 网络层增加了源和目的端地址等网络数据报的首部，产生了网络层数据报 — 链路层增加链路层首部信息并创建链路层帧</li><li>每个分层：首部字段+有效载荷字段（header + payload field），有效载荷为上一层分组</li></ul><h2 id="1-6-攻击的网络"><a href="#1-6-攻击的网络" class="headerlink" title="1.6 攻击的网络"></a>1.6 攻击的网络</h2><h2 id="1-7-历史，分组交换的发展，专用网络和互联网络，因特网的发展"><a href="#1-7-历史，分组交换的发展，专用网络和互联网络，因特网的发展" class="headerlink" title="1.7 历史，分组交换的发展，专用网络和互联网络，因特网的发展"></a>1.7 历史，分组交换的发展，专用网络和互联网络，因特网的发展</h2><hr><hr><h1 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h1><h2 id="2-1-网路应用程序体系结构"><a href="#2-1-网路应用程序体系结构" class="headerlink" title="2.1 网路应用程序体系结构"></a>2.1 网路应用程序体系结构</h2><ul><li>客户 - 服务器体系结构 client-server architecture 如Web应用，客户之间并不直接通信</li><li>P2P结构， per to per architecture，对于服务器有最小依赖，“对等方”在主机间直接通信，p2p特性，自扩展性；</li></ul><h3 id="2-1-1进程通信"><a href="#2-1-1进程通信" class="headerlink" title="2.1.1进程通信"></a>2.1.1进程通信</h3><ul><li>进行通信的实际是进程</li><li>运行在不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信；</li><li>进程通过<strong>“套接字” socket的软件接口</strong>向网络发送报文和从网络接受报文，Socket下面使用运输层TCP或UDP协议，套接字也称为“网络程序编程接口”，套接字对运输层仅仅能 1.选择运输层协议 2.设定运输层参数如最大缓存，最大报文长度等。<strong>套接字是应用层和运输层之间的接口</strong></li><li>开发者选择了运输层协议，应用程序就建立在由该协议提供的运输层服务至上；</li><li>进程寻址，“IP地址”来标识主机地址，“端口号Port”来表示主机中的进程，从而定位到通信的进程；</li></ul><h3 id="2-1-2可供应用程序使用的运输服务"><a href="#2-1-2可供应用程序使用的运输服务" class="headerlink" title="2.1.2可供应用程序使用的运输服务"></a>2.1.2可供应用程序使用的运输服务</h3><ul><li><strong>可靠数据传输</strong>：分组交换机的缓存溢出导致的分组丢失，可靠数据传输（reliable data transfer），运输层协议向应用程序提供进程到进程的可靠数据传输</li><li><strong>吞吐量</strong>：两个进程之间，可用吞吐量就是发送进程到接收进程交付比特的速率，会话会共享沿着网络路径的带宽，可用吞吐量会随着时间波动，运输层协议能够以某种特定的速率提供确保的可用吞吐量；具有吞吐量要求的应用程序为”宽铭感应用”，“弹性应用”是或多或少的利用可用吞吐量；</li><li><strong>定时</strong>：运输层协议保障提供数据传输的总时延小于一个特定值；</li><li><strong>安全性</strong>：运输层协议保障加密进程发送的数据</li></ul><h3 id="2-1-3运输服务"><a href="#2-1-3运输服务" class="headerlink" title="2.1.3运输服务"></a>2.1.3运输服务</h3><ul><li>TCP/IP网络中两个运输层协议，TCP和UDP</li></ul><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>TCP服务模型包括<strong>面向连接服务和可靠数据传输服务</strong></li><li>面向连接服务：连接的三次握手，握手完成后，TCP连接就在两个进程的套接字之间建立了。四次分手</li><li>可靠的数据传输服务：TCP，会无差错、按照顺序交付所发送的数据，当App的一端将字节流传进套接字是，能够依靠TCP将相同的字节流交付给接收方的套接字，没有字节的丢失和冗余；</li><li><strong>拥塞控制机制，在网络发送拥塞时，TCP的拥塞控制机制会抑制发送进程；或使每个连接达到公平共享带宽的目的；</strong></li><li>TCP UDP 不提供任何加密机制，安全套接字，SSL secure sockets layer；SSL是对TCP运输协议的加强，这样的<strong>安全强化是在应用层实现的（很容易）</strong>；SSL有独立的一套SOCKET API</li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul><li>轻量级运输协议，提供最小服务，UDP是无连接的，提供一种不可靠的数据传输服务；</li><li>UDP不保证报文到达接收方进程，到达的数据有可能是乱序到达；</li><li><strong>UDP没用拥塞机制，发送端可以使用UDP选定任何速率向下层注入数据；</strong></li></ul><h4 id="运输协议不提供的服务"><a href="#运输协议不提供的服务" class="headerlink" title="运输协议不提供的服务"></a>运输协议不提供的服务</h4><ul><li>不能提供定时和带宽保证；</li><li>网络语音，以UDP作为主要运输协议，TCP作为当UDP流量被防火墙阻挡后的备选方案；</li></ul><h3 id="2-1-4应用层协议"><a href="#2-1-4应用层协议" class="headerlink" title="2.1.4应用层协议"></a>2.1.4应用层协议</h3><ul><li>应用层协议定义了</li></ul><blockquote><p>交换的报文类型，如请求报文和响应报文 报文语法 字段含义 进程何时及如何发送报文，报文的响应规则</p></blockquote><p>HTTP 超文本传输协议，公共域的RFC SMTP 简单邮件传输协议</p><h2 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2 Web和HTTP"></a>2.2 Web和HTTP</h2><h3 id="2-2-1HTTP"><a href="#2-2-1HTTP" class="headerlink" title="2.2.1HTTP"></a>2.2.1HTTP</h3><ul><li>一个客户程序和一个服务器程序，运行在不同的端系统中，通过交换HTTP报文进行会话；HTTP定义了报文格式，已经报文的交换方式；</li><li>术语</li></ul><blockquote><p>Web页面 webpage 对象 object</p></blockquote><ul><li>HTTP定义了web客户端向服务器请求页面的方式；</li><li>HTTP使用<strong>TCP</strong>运输层服务，客户向他的套接字发送http报文，并从套接字接收响应报文；</li><li>HTTP服务每次发送报文，都会将报文通过套接字交给TCP服务，<strong>HTTP协议不用担心数据的丢失和乱序问题，分层体系结构的最大优点</strong>；</li><li>HTTP服务器不保存每次客户访问的信息，是一个“无状态协议“ stateless protocol</li></ul><h4 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h4><ul><li>非持续连接：每个请求是经过每次的单独的TCP连接发送，每次发送报文新建TCP连接</li><li>持续连接：所有的请求以同一个的TCP连接发送；</li><li><strong>HTTP既能使用非持续，也能使用持续连接</strong>，默认方式是使用持续连接，可以配置成非持续</li></ul><h4 id="非持续连接的HTTP"><a href="#非持续连接的HTTP" class="headerlink" title="非持续连接的HTTP"></a>非持续连接的HTTP</h4><ul><li>每个TCP连接只传输一个请求报文和一个响应报文；</li><li>往返时间： Round-Trip Time RTT，一个短分组从客服到服务器，再返回客户端所花费的时间；</li><li>RTT：分组传播时延，分组传输时延、排队时延、处理时延</li><li><strong>三次握手</strong>，客户向服务器发起一个TCP连接，客户向服务器发送一个小的TCP报文段，服务器用一个小TCP段作出确认和响应，最后客户向服务器返回确认（此时客户结合这部分发送一个http请求报文，一旦该报文被服务器接收，服务器就在该TCP连接上发送HTML文件）；</li><li><strong>采用非持续连接经受双倍的RTT交付延迟，第一个RTT用于创建TCP，第二个RTT用于请求和接受对象。值得注意的是，三次握手的第三次同时在请求。</strong></li></ul><h4 id="持续连接的HTTP"><a href="#持续连接的HTTP" class="headerlink" title="持续连接的HTTP"></a>持续连接的HTTP</h4><ul><li>非持续中，每个TCP都需要在服务器中分配TCP的缓冲区和保持TCP变量，给服务器带来较大负担，而且每个对象都需要经受两倍的RTT交付时延；一个RTT用来创建TCP连接，一个用来请求和接收对象；</li><li>HTTP的默认模式是使用带流水线的持续连接，服务器在发送响应后保持TCP连接打开，同一个客户和服务器的后续请求和响应报文通过相同的TCP连接进行；服务器可以以流水线的方式一个接一个的发出对象的请求，不必等待回答；超时后HTTP服务器就会关闭连接；</li></ul><h3 id="2-2-2HTTP报文格式"><a href="#2-2-2HTTP报文格式" class="headerlink" title="2.2.2HTTP报文格式"></a>2.2.2HTTP报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ul><li><p>使用ASCII编写，最少一行，最后一行附加一个换行符；</p></li><li><ol><li>请求行，后续叫做首部行 【方法字段】【URL统一资源定位】【HTTP版本】</li></ol></li></ul><ul><li>方法字段： GET POST HEAD PUT DELETE</li><li>首部行：HOST指明了对象所在主机，Web代理高速缓存所要求的</li><li>Connection：close 要求服务器在发送完被请求对象后关闭这条连接</li><li>User-agent：用户代理，不同的agent表示不同的设备或者浏览器。Mozilla标准</li></ul><ul><li>绝大部分使用GET方法</li><li>POST报文仍然可以向服务器请求对象，表单的请求报文不是必须使用POST方法；</li><li>HEAD方法和GET方法类似，但是服务器不返回请求对象；</li><li>PUT方法多用于上传路径的服务</li><li>DETELE方法允许用户删除服务器上的对象</li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul><li><p>状态行status line，协议版本+状态码+状态信息</p></li><li><p>首部行 header line</p></li><li><p><strong>实体行 entity body</strong>   实体部分是报文的主要部分，包含了对象本身；</p></li><li><p>Connection：close 表示告诉客户，发送完报文后服务器将关闭TCP连接</p></li><li><p>Date：响应报文的时间</p></li><li><p>Server：Server类型和版本</p></li><li><p>Last—Modified：对象的最后修改时间</p></li><li><p>Content-Length：被发送对象的字节数</p></li><li><p>Content-Type：内容类型</p></li><li><p>常见短语和状态码<br><code>200 OK</code>：请求成功</p><p><code>301 Moved Permanently</code>：请求的对象被永久转移了</p><p><code>400 Bad request </code>：请求不能被服务器理解 </p><p><code>404 Not Found</code>：请求的对象不在服务器</p><p><code>505 HTTP Version Not Supported</code>服务器不支持请求报文使用的http协议版本</p></li></ul><h3 id="2-2-3cookie"><a href="#2-2-3cookie" class="headerlink" title="2.2.3cookie"></a>2.2.3cookie</h3><ul><li><p>HTTP服务是无状态的，cookie允许站点对用户进行跟踪；包含以下四个部分</p></li><li><ul><li>HTTP响应报文中包含一个cookie首部行</li><li>HTTP请求报文中的一个cookie首部行</li><li>用户系统中保留一个cookie文件</li><li>web站点后端数据库</li></ul></li><li><p>Set-cookie首部识别码可以确定一个用户，在站点上每次访问的路径，跟踪用户的活动；</p></li><li><p><strong>过程：在用户首次访问网站时，网站产生一个唯一识别码并保存在web站点后端数据库，接下来Web服务器把包含该识别码的报文传给用户，用户的浏览器收到报文后，将该识别码记录在浏览器的cookie文件中，这条记录包含服务器的主机名和识别码。当用户后面再次浏览该网站时，用户查询到目标服务器和识别码对应，就将识别码加入到http请求报文中。这样网站就可以跟踪用户的活动。</strong></p></li></ul><h3 id="2-2-4Web缓存"><a href="#2-2-4Web缓存" class="headerlink" title="2.2.4Web缓存"></a>2.2.4Web缓存</h3><ul><li>Web cache &amp; proxy server 也叫代理服务器</li><li>代表初始的web服务器来满足http请求的网络实体</li><li>有自己的磁盘空间用来存储最近保存过的对象的副本</li><li><strong>过程：浏览器创建一个到web cache的tcp连接，并向web cache发送HTTP请求，Web缓存对对象做检查，有则直接返回给浏览器，无则与对象的初始服务器建立TCP连接。Web缓存器在这个TCP连接上发送HTTP请求，初始服务器Web cache进行响应，接收到对象的web cache会在本地存储一份副本，并向浏览器发送对象，web cache和浏览器也是TCP连接；</strong></li><li>通常由ISP提供，比如一所大学可能在校园网上安装一台WEB缓存器。</li><li>内容分发网络 Content Distribution Network CDN，CDN在地理位置上安装了很多缓存器，使得大量流量本地化</li></ul><h3 id="2-2-5条件GET方法"><a href="#2-2-5条件GET方法" class="headerlink" title="2.2.5条件GET方法"></a>2.2.5条件GET方法</h3><ul><li><p><strong>过程：web缓存器在收到报文后记录一个时间，在下次向服务器请求时带上这个时间并询问服务器这个页面是否在这个时间之后被修改，若修改，则发送新的报文给缓存器，若无，则回复 <code>304 not modified</code></strong></p></li><li><p>请求使用 GET method</p></li><li><p>header line： “If-Modified-Since：”</p><h2 id="2-3-电子邮件"><a href="#2-3-电子邮件" class="headerlink" title="2.3 电子邮件"></a>2.3 电子邮件</h2><h3 id="2-3-1SMTP"><a href="#2-3-1SMTP" class="headerlink" title="2.3.1SMTP"></a>2.3.1SMTP</h3></li><li><p><strong>过程：发送方调用邮件代理程序并提供接收方的邮件地址然后指示用户代理发送该报文，用户代理将报文发送给<code>发送方的邮件服务器</code>，在那里报文进入报文队列中，运行在发送方的邮件服务器的SMTP客户端发现了这个队列中的报文，（25号端口）创建一个到<code>接收方的邮件服务器</code>的TCP连接，在经过一些初始的SMTP握手后，SMTP客户通过该TCP连接发送报文，接收方的邮件服务器SMTP服务器端接收到了该报文，邮件服务器将报文放入接收方的邮箱之中。接收方调用用户代理阅读该报文。</strong></p></li><li><p>需要值得注意的是只有<code>发送方的邮件服务器</code>和<code>接收方的邮件服务器</code>，SMTP一般不使用中间服务器。如果接收方的邮件服务器没有开机，那么发送方的邮件服务器在后续会进行多次尝试。</p></li></ul><h3 id="2-3-2与HTTP对比"><a href="#2-3-2与HTTP对比" class="headerlink" title="2.3.2与HTTP对比"></a>2.3.2与HTTP对比</h3><table><thead><tr><th></th><th>相同</th><th>不同</th></tr></thead><tbody><tr><td>HTTP</td><td>都是一台主机向另一台发送信息</td><td>1、HTTP是一个拉协议；2、HTTP没有7比特ASCLL字符限制；3、HTTP把每个对象封装到一个报文中</td></tr><tr><td>SMTP</td><td>都是一台主机向另一台发送信息</td><td>1、SMTP是一个推协议；2、SMTP只能发送7比特的ASCLL字符；3、SMTP把所有对象封装到一个报文中</td></tr></tbody></table><h3 id="2-3-3邮件报文格式"><a href="#2-3-3邮件报文格式" class="headerlink" title="2.3.3邮件报文格式"></a>2.3.3邮件报文格式</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">From：alice<span class="hljs-symbol">@crepes</span>.fr<br><span class="hljs-keyword">To</span>:bob<span class="hljs-symbol">@hamburger</span>.edu<br>Subject:Searching <span class="hljs-keyword">for</span> the meaning of life<br></code></pre></td></tr></table></figure><h3 id="2-3-4邮件访问协议"><a href="#2-3-4邮件访问协议" class="headerlink" title="2.3.4邮件访问协议"></a>2.3.4邮件访问协议</h3><ul><li>之前我们默认是需要登录去访问邮件服务器的，而今天，邮件访问使用了一种**<code>客户-服务器体系结构</code>**，即用户使用桌面客户端来阅读电子邮件。</li><li>如果邮件服务器运行到用户设备上，那么保持持续在线是一件很困难的事。所以通常用户运行代理程序，而他访问总是开机的共享服务器上的邮件服务器。但是这又引发了一个问题：<strong>接收方是如何通过本地的代理程序来阅读程序的呢？（SMTP是一个推协议，所以无法使用SMTP来得到）</strong></li><li>上面这个问题的解决用到了一些特殊的邮件协议：**<code>POP3</code>和<code>IMAP</code>以及<code>HTTP</code>**<ul><li>POP3：<strong>过程分为三个阶段，第一阶段特许，服务器鉴别用户；第二阶段事务处理，用户代理取回报文，同时还可以选择对报文进行删除标记等；第三阶段更新阶段，即客户发出了quit命令之后，断开POP3连接，服务器删除被标记的报文</strong></li><li>IMAP：<strong>POP3无法为用户创建远程文件夹，也无法指派文件进入文件夹，所以IMAP应运而生，IMAP可以在邮件服务器接收邮件时与收件夹自动关联，后续在用户代理操作时可以指派文件夹，同时IMAP还可以选择只读取报文的首部，就可以避免一些下载不必要的大邮件。</strong></li></ul></li></ul><h2 id="2-4-DNS，域名解析服务"><a href="#2-4-DNS，域名解析服务" class="headerlink" title="2.4 DNS，域名解析服务"></a>2.4 DNS，域名解析服务</h2><p>工作机理：浏览器向用户DNS客户端发送主机名（gethostbyname），DNS客户端从缓存中查找，找不到向网络发送一个DNS查询报文，DNS请求和回答报文都是用UDP数据报经过53端口发送，DNS客户端将映射结果返回给调用的程序；</p><h3 id="2-4-1DNS提供的服务"><a href="#2-4-1DNS提供的服务" class="headerlink" title="2.4.1DNS提供的服务"></a>2.4.1DNS提供的服务</h3><ul><li><p>从主机名到ip地址转换目录服务。</p></li><li><p>DNS通常是其他应用层协议所使用的，它提供如下服务：</p><ul><li><p>从主机名到ip地址转换目录服务</p></li><li><p>主机别名</p></li><li><p>邮件服务器别名</p></li><li><p>负载分配</p></li></ul></li></ul><h3 id="2-4-2DNS工作机理概述"><a href="#2-4-2DNS工作机理概述" class="headerlink" title="2.4.2DNS工作机理概述"></a>2.4.2DNS工作机理概述</h3><h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><ul><li><p>没有一台DNS服务器能够囊括全球域名，因此需要大量的DNS服务器，大致来说有三种：根DNS服务器，顶级域DNS服务器（tld），权威DNS服务器，还有一类： 本地DNS服务器，不过严格来说他不处于这个层次中</p></li><li><p><strong>过程：客户访问一个网址，首先向他的本地DNS服务器查询，本地DNS服务器将该报文转发到根DNS服务器，根DNS服务器再向本地DNS服务器返回负责这部分顶级域的tld-DNS服务器的ip地址列表，本地DNS服务器再向tld发送查询报文，tld再发送相关权威DNS服务器的ip地址，最后本地服务器再向权威服务器的ip发送报文，最后权威DNS服务器给出要访问的网址的ip地址，最后终于得到了ip地址</strong></p><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4></li><li><p>DNS服务器会缓存IP/主机名的信息，在查询过程中的一级DNS服务器存储了这个ip就可以直接找到。</p></li></ul><h3 id="2-4-3DNS记录-DNS报文"><a href="#2-4-3DNS记录-DNS报文" class="headerlink" title="2.4.3DNS记录 DNS报文"></a>2.4.3DNS记录 DNS报文</h3><ul><li><p>资源记录：NAME|VALUE|TYPE|TTL</p><ul><li>NAME和VALUE的值主要取决于TYPE</li><li>TYPE分为A（主机名-ip）、NS（域如auswitz.top-知道如何获取该域主机ip的权威服务器）、CNAME（规范主机名-别名）、MX（邮件服务器的别名-规范主机名）</li><li>TTL：该记录的生存时间<h3 id="2-4-4DNS脆弱性"><a href="#2-4-4DNS脆弱性" class="headerlink" title="2.4.4DNS脆弱性"></a>2.4.4DNS脆弱性</h3></li></ul></li><li><p>针对DNS的DDos分布式拒绝服务带宽洪泛攻击，将大量分组发送到DNS服务器，以至于合法的分组得不到回答</p></li><li><p>但是，总而言之，DNS已经显示了惊人的鲁棒性，迄今为止，没有一个攻击有效的妨碍了DNS服务。</p></li></ul><h2 id="2-5-P2P"><a href="#2-5-P2P" class="headerlink" title="2.5 P2P"></a>2.5 P2P</h2><h3 id="2-5-1P2P结构的扩展性"><a href="#2-5-1P2P结构的扩展性" class="headerlink" title="2.5.1P2P结构的扩展性"></a>2.5.1P2P结构的扩展性</h3><p>在服务器-客户体系中，文件分发时，服务器必须向每一个对等方分发文件，<strong>但是在P2P文件分发中，每个对等方都能向其他任何对等方分发它已经接收到的文件的部分。</strong></p><h3 id="2-5-2BitTorrent"><a href="#2-5-2BitTorrent" class="headerlink" title="2.5.2BitTorrent"></a>2.5.2BitTorrent</h3><ul><li>BitTorrent时一种流行的P2P协议，参与一个特定文件分发的所有对等方被称为一个洪流（torrent），每个洪流有一个追踪器</li><li><strong>过程：当一个新的对等方加入洪流，它向追踪器注册自己，并周期性的告知自己仍在洪流中。当这个对等方A加入洪流时，追踪器随机的从对等方选择对等方的一个子集，将这个自己里的对等放的ip发给A，A就持有了这个子集的列表，试图与列表上的所有对等方建立TCP连接。称建立好连接的为邻近对等方，随着时间的流逝，这些邻近对等方会离开在任何给定的时间，每个对等方将获得来自文件的子集，并且不同对等方具有不同的子集，A周期性的向他的邻近对等方索要块列表，利用这个列表，A将针对它没有的块在邻居中请求最稀缺的块，这样最稀缺的块就能得到快速的分发。为了决定A响应哪个邻居的索要块的请求，A根据当前能够以最高速率向他提供数据的邻居，给出其优先权，并确定以最高速率流入的四个邻居，每过一段时间，A重新计算得到新的四个邻居(这四个对等方叫做疏通)，重要的是，A每过30s也要重新选择一个邻居发送块，将这个被选择的邻居称为B，A正在向B发送数据，因此A有机会称为B的疏通，这样B也有机会向A发送数据，也有希望继续成为A的疏通。他们将对方放入疏通成为对方的伴侣，直到该对等方之一发现了更好的伴侣。这种处理能够以趋于找到彼此协调的速率上载，随机选择邻居的方式也允许接触新的对等方，以便找到更好的伴侣。</strong><h2 id="2-6视频流和内容分发网络"><a href="#2-6视频流和内容分发网络" class="headerlink" title="2.6视频流和内容分发网络"></a>2.6视频流和内容分发网络</h2></li></ul><h3 id="2-6-1因特网视频"><a href="#2-6-1因特网视频" class="headerlink" title="2.6.1因特网视频"></a>2.6.1因特网视频</h3><h3 id="2-6-2HTTP和DASH"><a href="#2-6-2HTTP和DASH" class="headerlink" title="2.6.2HTTP和DASH"></a>2.6.2HTTP和DASH</h3><ul><li><p><strong>过程：视频只是存储在HTTP服务器上一个普通的文件，当用户要看视频时，客户服务器创建一个TCP连接，并发送该URL的HTTP-GET请求，服务器就以尽可能快的速率在报文中发送该视频文件，当缓存的字节数量超过设置的门槛，客户端就开始播放文件，同时继续缓存后面的视频帧。</strong></p></li><li><p>DASH：DASH允许允许不同质量的网络接入不同的视频版本的（4k、1080p等等）</p></li></ul><h3 id="2-6-3内容分发网"><a href="#2-6-3内容分发网" class="headerlink" title="2.6.3内容分发网"></a>2.6.3内容分发网</h3><ul><li><strong>过程：为了应对分发巨量数据的挑战，视频流公司都利用内容分发网CDN。用户请求一个视频，本地DNS服务器将请求发送到权威服务器，权威服务器观察到这是和视频相关的请求，就把CDN域中的主机名返回给本地DNS，这是本地DNS服务器的请求进入了CDN的DNS基础设施，此时CDN的DNS系统返回一个具有该视频的CDN服务器ip，本地DNS系统接收到后再返回给本地主机，主机和该CDN服务器创建一条TCP连接。最终用户能从该CDN服务器中获取想要的内容。</strong></li><li>集群选择策略：为了基于当前流量给客户更好的体验，CDN能够对其集群和客户的时延丢包进行周期性的测量。</li></ul><h1 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3. 运输层"></a>3. 运输层</h1><h2 id="3-1-运输层服务"><a href="#3-1-运输层服务" class="headerlink" title="3.1 运输层服务"></a>3.1 运输层服务</h2><ul><li>运输层协议为运行在不同主机之间的应用程序提供了<strong>逻辑通信</strong>的功能</li><li>运输层从应用程序接受报文并转化成<strong>”报文段“</strong>，实现方式是将报文划分成较小的块，<strong>转换成运输层分组</strong>，并为每块加上一个运输层首部以生成运输层报文段，运输层协议是在端系统中而不是路由器中实现；</li><li><strong>报文分块</strong> – <strong>添加首部</strong> – <strong>生成报文段</strong> – 运输层将这些报文传递给网络层，网络层将其封装成数据报分组并向目的地发送；</li><li><strong>p123页的例子非常好，可以说明运输层协议只是工作在端系统。运输层协议将来自应用层的报文处理后挪到网络层边缘。</strong></li><li>路由器只会作用于网络层字段，不会检查封装在该数据报的运输层报文段和字段；运输层则处理接受到的报文段，使该报文的数据为接受应用程序使用；</li></ul><h3 id="3-1-1运输层和网络层的关系"><a href="#3-1-1运输层和网络层的关系" class="headerlink" title="3.1.1运输层和网络层的关系"></a>3.1.1运输层和网络层的关系</h3><ul><li>网络层提供了主机之间的逻辑通信</li><li>运输层提供了进程之间的逻辑通信</li><li>运输层协议只在端系统中工作；对报文在网络核心中如何移动不做任何规定；</li><li>不同的运输层协议为应用程序提供不同的服务模型</li><li>底层的网络层协议不可靠，分组交换机会发送分组丢失等，但是运输层协议仍然能够为应用程式提供可靠的数据传输；网络层协议有一个名字叫做<strong>IP（网际协议）</strong>，服务模型是尽力而为交付服务，因此被称为不可靠服务。</li></ul><h3 id="3-1-2概述"><a href="#3-1-2概述" class="headerlink" title="3.1.2概述"></a>3.1.2概述</h3><ul><li>运输层分组：报文段 segment TCP：报文段 UDP：数据报 网络层：数据报</li><li>IP的服务模型：<strong>尽力为交付服务</strong> best-effort delivery service，尽最大努力交付，但是不做任何确保，不确保报文段的交付、不确保报文段的按序交付、不确保报文段中的数据的完整性</li><li>IP：不可靠服务</li><li>TCP UDP的基本责任是：将两个端系统之间的IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务；</li><li>主机间的交付扩展到进程间的交付： <strong>运输层的多路复用</strong> 与 <strong>多路分解</strong> （transport-layer multiplexing, demultiplexing)</li><li><strong>进程和进程的数据交付</strong>和<strong>差错检查</strong>是两种最低限度的运输层服务</li></ul><h2 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h2><ul><li><p>多路分解：在接收端，运输层检查这些字段，标识出接收套接字，进而将报文定向到该套接字。</p></li><li><p>多路复用：从源主机不同套接字收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层。</p></li><li><p>报文段特殊字段的格式：<strong>源端口号|目的端口号|其他首部字段|应用数据</strong></p><h3 id="3-2-1无连接的多路分解和多路复用"><a href="#3-2-1无连接的多路分解和多路复用" class="headerlink" title="3.2.1无连接的多路分解和多路复用"></a>3.2.1无连接的多路分解和多路复用</h3></li><li><p>过程：<strong>主机A的运输层创建一个运输层报文段，其中包括应用程序数据、源端口号、目的端口号和其他。运输层就将这个报文传递给网络层。</strong></p></li><li><p>源端口号的目的是什么？提供一个完整的返回地址。</p></li><li><p>UDP的套接字是由一个<strong>二元组</strong>表示的，包含一个目的IP地址和一个目的端口号</p></li><li><p>源地址不同，目的地址相同，将被定向到同一个套接字。</p></li></ul><h3 id="3-2-2面向连接的多路分解和多路复用"><a href="#3-2-2面向连接的多路分解和多路复用" class="headerlink" title="3.2.2面向连接的多路分解和多路复用"></a>3.2.2面向连接的多路分解和多路复用</h3><ul><li>TCP的套接字是由一个<strong>四元组</strong>（目的IP、目的端口号、源IP、源端口号组成的）</li><li>不同源地址，相同目的地址，将被定向到两个不同的套接字。</li></ul><h3 id="3-2-3Web服务器与TCP"><a href="#3-2-3Web服务器与TCP" class="headerlink" title="3.2.3Web服务器与TCP"></a>3.2.3Web服务器与TCP</h3><ul><li>连接套接字与进程之间并非有着一一对应的关系，Web服务器具有多个新连接套接字的<strong>新线程</strong>，任意时间内会有不同标识的套接字连接到相同的进程中；线程管理的套接字可以接收或者发送HTTP请求和响应</li></ul><h2 id="3-3-无连接运输-UDP"><a href="#3-3-无连接运输-UDP" class="headerlink" title="3.3 无连接运输-UDP"></a>3.3 无连接运输-UDP</h2><ul><li><p>选择UDP的原因依据：</p><ul><li><p>时间和数据：不希望过分的延迟发送报文，且能容忍一定的数据丢失、</p></li><li><p>无需建立连接：UDP无连接时延</p></li><li><p>无连接状态：UDP无需维护连接状态，无需跟踪参数，无拥塞控制机制</p></li><li><p>分组首部开销小：源端口、目的端口、校验和、数据大小</p></li></ul></li></ul><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230306141535242.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230306141535242"></p><h3 id="3-3-1UDP的报文段结构"><a href="#3-3-1UDP的报文段结构" class="headerlink" title="3.3.1UDP的报文段结构"></a>3.3.1UDP的报文段结构</h3><ul><li>首部包含四个字段每个字段由2个字节组成，一共8字节</li></ul><table><thead><tr><th>16bit</th><th>16bit</th></tr></thead><tbody><tr><td>源端口</td><td>目的端口</td></tr><tr><td>UDP报文首部和数据的总长度</td><td>校验和，对UDP报文段中的所有16比特字的和进行反码</td></tr><tr><td>报文数据</td><td>报文数据</td></tr></tbody></table><h3 id="3-3-2UDP校验和"><a href="#3-3-2UDP校验和" class="headerlink" title="3.3.2UDP校验和"></a>3.3.2UDP校验和</h3><ul><li>链路层路由协议及以太网协议也都提供了差错检测，传输层的差错检测存在的意义就是因为不能保证每一条链路都使用了差错检测的协议；这既是无法确保链路的可靠性；</li><li><strong>端到端原则</strong>： 必须基于端到端实现功能，因为相比在较高级别实现这些功能的代价，在较低级别上实现可以是冗余或者几乎无价值的；</li><li>UDP对检验出的受损报文段：1. 直接丢弃 2. 交给套接字并向应用程序发出<strong>警告</strong></li></ul><h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><ul><li>可靠数据传输为上层实体提供的服务抽象： <strong>数据可以通过一条可靠的信道传输</strong></li><li>传输数据不会受损例如数据bit从0变为1或者从1变为0，且数据按照发送顺序交付</li><li>TCP的下层IP不可靠，TCP在不可靠的IP协议端到端网络层上实验可靠数据传输，且<strong>可靠数据传输协议</strong>下层可能是一条或者多条物理链路</li></ul><h3 id="3-4-1-构造可靠数据传输"><a href="#3-4-1-构造可靠数据传输" class="headerlink" title="3.4.1 构造可靠数据传输"></a>3.4.1 构造可靠数据传输</h3><h4 id="1-rdt1-0"><a href="#1-rdt1-0" class="headerlink" title="1. rdt1.0"></a>1. rdt1.0</h4><table><thead><tr><th>rdt1.0 - 发送端</th><th>{action}</th></tr></thead><tbody><tr><td>等待上次应用的调用</td><td>rdt_send(data)</td></tr><tr><td></td><td>packet = make_pkt(data); udt_send(packet)</td></tr></tbody></table><table><thead><tr><th>rdt1.0 - 接收端</th><th>{action}</th></tr></thead><tbody><tr><td>等待来自下层的调用</td><td>rdt_rev(packet)</td></tr><tr><td></td><td>extract(packet, data); deliver_data(data)</td></tr></tbody></table><ul><li>发送方和接收方都有各自的FSM，上图FSM各自只有一个状态</li><li>发送端：rdt的发送端只通过rdt_send(data)事件接收来自较高层的数据，然后生成一个包含数据的分组，并将分组发送到信道中；事件由上层应用的过程调用产生；</li></ul><blockquote><p>过程调用和系统调用</p></blockquote><ul><li>接收端：rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，然后从分组中取出数据extract，并将数据上传给高层deliver；rdt_rcv事件由较为底层的协议过程调用产生</li></ul><h4 id="2-rdt2-0"><a href="#2-rdt2-0" class="headerlink" title="2. rdt2.0"></a>2. rdt2.0</h4><ul><li><p>肯定确认 (positive acknowledgement) 否定确认 (negative acknowledgment)，控制报文使得接收方可以让发送发知道哪些内容被正确接收，哪些内容接收有误需要自动请求重传；</p></li><li><p><strong>自动重传协议</strong>  ARQ</p></li><li><p>自动重传协议</p><p>需要的支持</p><ul><li>差错检测，分组<strong>检验和</strong>字段</li><li>接收方反馈，“肯定确认” ACK，“否定确认” NAK</li><li>重传，接收方收到有差错的分组时，发送方收到反馈后将进行重传</li></ul></li></ul><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230306143117832.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230306143117832"></p><ul><li>这样的等待协议为 <strong>停等</strong> 协议 stop-and-wait</li><li>接收方的FSM只有一个状态，当分组到达时，接收方检验分组是否受损，要么回答一个ACK要么回答一个NAK；</li><li>致命缺陷：没有考虑ACK、NAK受损的可能性。</li><li>解决ACK或者NAK分组受损导致发送方无法明确分组是否被正确接收的方法是：引入新字段，<strong>分组编号</strong>，就是发送数据的分组**序号 **</li></ul><h4 id="3-rdt-2-1-amp-amp-rdt2-2"><a href="#3-rdt-2-1-amp-amp-rdt2-2" class="headerlink" title="3 rdt 2.1&amp;&amp;rdt2.2"></a>3 rdt 2.1&amp;&amp;rdt2.2</h4><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230306144235681.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230306144235681"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230306144301266.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230306144301266"></p><h4 id="3-rdt3-0-具有比特差错的丢包信道的可靠数据传输"><a href="#3-rdt3-0-具有比特差错的丢包信道的可靠数据传输" class="headerlink" title="3. rdt3.0 具有比特差错的丢包信道的可靠数据传输"></a>3. rdt3.0 具有比特差错的丢包信道的可靠数据传输</h4><blockquote><p>检测丢包和丢包后的action</p></blockquote><ul><li>当前已经包含的： 检验和、序号、ACK分组、重传机制</li><li>发送方等待超时，如果等待足够长的时间没有收到接收方的响应，便对该分组进行重传</li><li>等待时间： 发送方与接收方之间的一个往返时延（传输时延，传播时延，排队时延） + 接收方处理一个分组的时间， 实践中，发送方明智的选择一个确定的时间值作为等待时间</li><li>如果一个分组经历了比较长的时延，但是并没有丢包，发送方也会重传该分组，这样的情况下接收方就会 <strong>“冗余数据分组</strong>，分组序号可以解决冗余数据分组的问题</li><li>过度延时或者分组丢失都会导致重传</li><li>倒计数定时器 countdown timer， 用于给定时间过期后，中断发送方；</li></ul><table><thead><tr><th>发送方</th><th></th></tr></thead><tbody><tr><td>等待来自上层的调用 0</td><td>rdt_send(data)</td></tr><tr><td></td><td>sndpkt = make_pkt(0, data, checksum); udt_send(sndpkt); start_timer;</td></tr><tr><td>等待ACK 0</td><td>rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || isACK(rcvpkt, 1)) # 等待响应分组，1. 下层过程调用rdt_rcv 2. 如果检验后数据受损 或 获得的确认包序号不是当前0序号 则保持当前状态</td></tr><tr><td></td><td>timeout; udt_send(sndpkt); start_timer; #如果出现超时(数据丢失或者网络延时)，则重新发送序号为0的分组，并启动新的timer，发送后依然保持当前等待0响应的状态</td></tr><tr><td>⬇ 到下一状态</td><td>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 0)); stop_timer; #当在该状态下收到响应分组，调用rdt_rcv函数后，检验数据无损，且当前响应分组的序号与当前等待状态序号一致，此处为0，则进入下一状态</td></tr><tr><td>等待来自上层的调用1</td><td>rdt_send(data)</td></tr><tr><td></td><td>sndpkt = make_pkt(1, data, checksum); udt_send(sndpkt); start_timer;</td></tr><tr><td>等待ACK 1</td><td>rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || isACK(rcvpkt, 0)) # 等待响应分组，1. 下层过程调用rdt_rcv 2. 如果检验后数据受损 或 获得的确认包序号不是当前1序号 则保持当前状态, 继续等待正确响应分组</td></tr><tr><td></td><td>timeout; udt_send(sndpkt); start_timer; #如果出现超时(数据丢失或者网络延时)，则重新发送序号为1的分组，并启动新的timer，发送后依然保持当前等待0响应的状态</td></tr><tr><td>⬇ 到下一状态</td><td>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 1); stop_timer; #当在该状态下收到响应分组，调用rdt_rcv函数后，检验数据无损，且当前响应分组的序号与当前等待状态序号一致，此处为1，则进入下一状态</td></tr><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>接收方</th><th></th></tr></thead><tbody><tr><td>STATE</td><td>ACTION</td></tr><tr><td>等待来自下层的调用0（过程调用）</td><td>rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || has_seq1(rcvpkt)) ; sndpkt = make_pkt(NAK, 0, checksum); udt_send(sndpkt) #下层调用，检验数据是否受损, 检测分组序号，当数据受损或序号为1时，继续保持该状态等待下层调用0, 并发送0的NCK响应</td></tr><tr><td>⬇ 到下一状态</td><td>rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &amp;&amp; has_seq0(rcvpkt); extract(rcvpkt, data); deliver_data(data); sndpkt = make_pkt(ACK, 0, checksum); udt_send(sndpkt) # 接收分组，解出数据，校验数据无损且分组序号为0，则将数据提交给上层应用，并向发送方响应序号为0的ACK，当前状态转移到等待下层调用序号1</td></tr><tr><td>等待来自下层的调用1（过程调用）</td><td>rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || has_seq0(rcvpkt)) ; sndpkt = make_pkt(NCK, 1, checksum); udt_send(sndpkt) #下层调用，检验数据是否受损, 检测分组序号，当数据受损或序号为1时，继续保持该状态等待下层调用0, 并发送0的NCK响应</td></tr><tr><td>返回初始状态</td><td>rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &amp;&amp; has_seq1(rcvpkt); extract(rcvpkt, data); deliver_data(data); sndpkt = make_pkt(ACK, 1, checksum); udt_send(sndpkt) # 接收分组，解出数据，校验数据无损且分组序号为1，则将数据提交给上层应用，并向发送方响应序号为1的ACK，返回初始状态</td></tr></tbody></table><h3 id="3-4-2-流水线可靠传输协议"><a href="#3-4-2-流水线可靠传输协议" class="headerlink" title="3.4.2 流水线可靠传输协议"></a>3.4.2 流水线可靠传输协议</h3><ul><li><p>rdt3.0的停等协议有着非常低的发送利用率 每个分组到达接收方后返回ACK的延时为一个RTT</p></li><li><p>解决方法：不使用停等协议等方式运行，允许发送方发送多个分组而无需等待确认；</p></li><li><p>流水线 pipelining</p></li></ul><p>  带来的影响</p><ul><li>必须增加序号范围，每个分组必须有一个唯一的序号</li><li>协议的发送方和接收方两端必须<strong>缓存多个分组</strong></li><li>序号范围和缓冲 取决于数据传输协议如何处理丢失、损坏、延时过大的分组；流水线的差错恢复的方法： <strong>回退N步 （Go-back-N GBN)**，</strong>选择重传 (Seletive Repeat, SR)**</li></ul><h3 id="3-4-3-回退N步"><a href="#3-4-3-回退N步" class="headerlink" title="3.4.3 回退N步"></a>3.4.3 回退N步</h3><blockquote><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>base nextseqnum</p><p>—–窗口长度—-</p><p>窗口到nextseqnum前是已发送但未确认分组，nextseqnum后是未发送分组</p></blockquote><ul><li>已经被发送但是还没有确认的分组的许可序号范围可以被看成一个在序号范围内的N的<strong>窗口</strong>；</li><li>N为<strong>窗口长度 window size</strong>， GBN协议也被称为<strong>滑动窗口协议 sliding window protocol</strong></li><li>运输层分组首部：分组序号，szie为k比特，则序号范围=[0, 2^k -1]，序号使用模2^k运算；</li><li>TCP的序号按照字节流中的字节计数</li><li>GBN响应的三种类型<ul><li>上层调用 rdt_send()，当前窗口未满时（判断是否已经有N个已经发送但是未被确认的分组），产生一个分组并发送，并更新变量；如果窗口已满，发送方需要将数据返回给上层，上层会稍等再试；</li><li>收到一个ACK，在GBN中，对序号为n的分组采用<strong>累计确认 cumulative acknowledgment</strong> 的方式，表明接收方已经正确接收n及n在内的所有的分组</li><li>超时事件，出现丢失和时延过长分组的情况下，发送方重传所有已经发送但是还未确认的分组，也就是重传当前窗口中的所有分组；</li></ul></li><li>GBN中，接收方，序号为n的分组被<strong>按序正确接收</strong>则接收方发送一个ACK，其他情况下接收方丢弃分组，并为最近按序接收的分组重新发送ACK；</li><li>如果序号为k的分组已经交付给上层，则证明k-1个分组都已经交付</li><li>因为数据必须按序交付，如果接收方等待分组n但是却收到了分组n+1，接收方会直接丢弃分组n+1，因为如果不丢弃会导致发送方重传，因此只需丢弃n+1，优点是接收缓存简单，接收方无需缓存失序分组；</li><li>发送方需要维护窗口的上下边界及nextseqnum在该窗口的位置，接收需要维护下一个按序接收的分组序号；且保存在expectedseqnum;</li></ul><blockquote><p>基于事件编程 event-based programming</p></blockquote><h3 id="3-4-4-选择重传"><a href="#3-4-4-选择重传" class="headerlink" title="3.4.4 选择重传"></a>3.4.4 选择重传</h3><ul><li>选择重传 SR 协议通过让发送方仅重传那些它怀疑在接收方出错（丢失、受损）的分组</li></ul><blockquote><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>base nextseqnum</p><p>—–窗口长度—-</p><p>nextseqnum前包含 已经确认的分组 和 已发送未确认分组</p><p>nextseqnum之后是 未发送分组</p></blockquote><ul><li>发送方和接收方的序号空间</li><li>发送发<ul><li>从上层接收数据，序号位于窗口内，将数据打包发送，如果不在窗口内，则将数据缓存或者将数据返回给上层；</li><li>超时，每个分组有自己的逻辑定时器，超时发生后只能发送一个分组，使用一个硬件定时器模拟多个逻辑定时器；</li><li>收到ACK，发送方收到ACK且判断在窗口内时，SR发送方将分组标记为“已接收”；当收到的序号等于send_base时，则base向前移动到<strong>“最小序号的未确认处”</strong>，如果序号为窗口内未发送分组，则发送这些分组</li></ul></li><li>接收方，将确认每个正确接收的分组，失序的分组将被缓存直到所有丢失分组都被收到为止；所有分组被收到后，将分组按序交付给上层；<ul><li>序号在[rcv_base, rcv_base + n -1]内的分组被正确接收，收到的分组落在接收方的窗口内，选择ACK被会送给发送方；分组以前没有收到过，则缓存；分组序号为base序号，则触发该分组前的连续分组交付给上层；窗口向前移动并按照编号交付分组；</li><li>序号在[rcv_base, rcv_base + n -1]内的分组被正确接收，此时，必须产生一个AC</li></ul></li><li>接收方会重新确认（ACK）已经收到过的序号小于当前窗口base的分组；</li><li>SR中接收方和发送方的窗口不总是一致的；</li></ul><ul><li>对于SR协议，窗口的长度必须小于或者等于序号空间大小的一半；</li><li>Page153，对于发送方窗口序号为0，1，2，3，0，1，2 窗口长度为3，接收方无法判断序号为0的分组是重传还是第五个分组的初次传输；此处序号空间是4，但是窗口size为3，导致协议无法工作；</li></ul><h5 id="可靠数据传输机制总结"><a href="#可靠数据传输机制总结" class="headerlink" title="可靠数据传输机制总结"></a>可靠数据传输机制总结</h5><table><thead><tr><th>机制</th><th>说明</th></tr></thead><tbody><tr><td>检验和 checksum</td><td>检验分组数据bit是否受损</td></tr><tr><td>定时器timer</td><td>用于分组丢失的情况下的超时重传，分组丢失或者ACK回复在链路中丢失，或者因为链路时延导致超时；重传可能会导致接收方的分组冗余</td></tr><tr><td>序号 sequence number</td><td>对从发送方到接收方的数据按序编号，发送方可以按序交付数据给接收方，接收方通过序号检测数据是否受损或者丢失并向发送方回复；接收方还可以通过序号检测是否收到了冗余副本；</td></tr><tr><td>确认 ACK</td><td>接收方用于确认一个分组或者一组分组是否正确接收，携带被确认的分组的序号或者多个序号，确认可以逐个也可以是积累的；</td></tr><tr><td>否定确认 NAK</td><td>接收方用于回复发送方某一个序号的分组未正确接收，例如数据顺坏，携带被否定确认的分组的序号；</td></tr><tr><td>窗口、流水线 sliding window</td><td>发送方通过一次发送多个分组，不断更新窗口位置，接收方每次收到base序号的分组后，则将缓存中的分组交付给上层；窗口长度根据接收方 接收 和 缓存 报文的能力、网络拥塞程度来配置；</td></tr></tbody></table><ul><li>通过假定一个分组在网络中“存活”时间不会超过一个最大的固定时间（最大分组寿命3分钟），来确保一个序号的分组都已经不再网络中，则可以重复使用该序号；对序号的重复使用会导致冗余分组和当前分组的混乱，所有重复使用序号的前提是必须保证网络中不再包含该序号的分组；</li></ul><h2 id="3-5-面向连接的运输：TCP"><a href="#3-5-面向连接的运输：TCP" class="headerlink" title="3.5 面向连接的运输：TCP"></a>3.5 面向连接的运输：TCP</h2><h3 id="3-5-1-TCP连接"><a href="#3-5-1-TCP连接" class="headerlink" title="3.5.1 TCP连接"></a>3.5.1 TCP连接</h3><ul><li>发送预备报文段，进行握手，以建立确保数据传输的参数，进而建立<strong>“连接”</strong>；</li><li>TCP/IP Transmission Control Protocol/Internet Protocol，建立之初为单一的实体，后来将其分开为TCP和IP协议，存在于网络的不同层次</li><li>连接状态完全保留在两个端系统中，中间网络不会维持TCP连接，中间网络对TCP连接完全“视而不见”</li><li>全双工服务（full-duplex service）；进程A和进程B可以同时发送数据；</li><li>点对点（point-to-point），单个发送方和单个接收方； </li></ul><h5 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h5><ul><li>客服进程、服务器进程</li></ul><blockquote><p>clientSocket.connect((serverName, serverport))</p></blockquote><ul><li><p>两个进程之间发送了3个报文段，前两个不承载“有效载荷”，建立的过程被称为<strong>三次握手</strong></p></li><li><p><strong>过程：1、客户端发送连接请求 SYN=1 SEQ=随机x    2、服务器为TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。SYN=1 ACK=1 SEQ=随机y ack=x+1    3、客户端为该客户端连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。</strong></p><h5 id="连接的释放"><a href="#连接的释放" class="headerlink" title="连接的释放"></a>连接的释放</h5></li><li><p><strong>过程：1、客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接 FIN=1 SEQ=u    2、服务器端返回确认报文段，连接释放 ACK=1 SEQ=v ack=u+1半关闭状态    3、服务器端发完数据，发出连接释放报文段，主动关闭TCP连接FIN=1 ACK=1 SEQ=w ack=u+1    4、客户端回复确认报文端，等待计时器设置的2msl（最长报文段寿命）连接彻底关闭</strong></p></li></ul><h3 id="3-5-2-报文段-结构"><a href="#3-5-2-报文段-结构" class="headerlink" title="3.5.2 报文段 结构"></a>3.5.2 报文段 结构</h3><ul><li>32bit</li></ul><table><thead><tr><th align="center">32bit</th></tr></thead><tbody><tr><td align="center">源端口号 | 目的端口号</td></tr><tr><td align="center">序号</td></tr><tr><td align="center">确认号</td></tr><tr><td align="center">首部长度|保留未用|URG|ACK|PSH|RST|SYN|FIN | 接收窗口</td></tr><tr><td align="center">检验和 | 紧急数据指针</td></tr><tr><td align="center">选项</td></tr><tr><td align="center">数据</td></tr></tbody></table><ul><li><strong>MSS限制了报文段数据字段的最大长度</strong>，对于较大的文件，TCP会将文件划分成若干块进行处理</li><li>和UDP相同，首部包括了源和目的端口、检验和字段（checksum）</li><li>32bit的序号字段，32bit的确认号字段</li><li>16bit的接收窗口字段，用于流量控制，用于指定接收方愿意接收的字节数量</li><li>4bit的首部长度字段，典型长度为20byte</li><li>选项字段，可变长度用于协商MSS</li><li>6bit的标志字段 flag field<ul><li>ACK 用于确认报文段是否被成功接收，1 bit</li><li>RST、SYN、FIN用于连接的建立和拆除，1bit</li><li>PSH表示，是否立即将数据交付给上层，1bit，运输层传递给应用层的优先级++</li><li>URG表示，报文段中是否 ”存在“ 被发送端的上层实体置为”紧急“的数据</li><li>紧急数据指针字段用于指出紧急数据，存在时TCP会通知上层服务；16bit</li></ul></li></ul><h3 id="3-5-3-往返时间与超时"><a href="#3-5-3-往返时间与超时" class="headerlink" title="3.5.3 往返时间与超时"></a>3.5.3 往返时间与超时</h3><ul><li>TCP使用超时重传机制</li><li><strong>超时间隔是动态确定的</strong></li><li>TCP使用 SampleRTT来<strong>预估 一次的RTT时间</strong>，TCP会维持一个平均值<strong>EstimateRTT</strong>，当获取到新的SampleRTT，计算加权平均值的方式如下：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">EstimatedRTT</span> = （<span class="hljs-number">1</span>- α）· EstimatedRTT + α · SampleRTT<br><span class="hljs-attr">DevRTT</span> = (<span class="hljs-number">1</span>-β) · DevRTT + β · |SampleRTT - EstimatedRTT|<br></code></pre></td></tr></table></figure><blockquote><p>α参考值为0.125，β推荐值为0.25</p><p>指数加权移动平均</p><p>定义了DevRTT为SampleRTT到EstimatedRTT的偏离程度</p></blockquote><ul><li>考虑到SampleRTT的波动，超时重传的时间间隔</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">TimeoutInterval</span> = EstimatedRTT + <span class="hljs-number">4</span> · DevRTT<br></code></pre></td></tr></table></figure><ul><li>初始推荐为1秒</li></ul><h3 id="3-5-4-可靠数据传输"><a href="#3-5-4-可靠数据传输" class="headerlink" title="3.5.4 可靠数据传输"></a>3.5.4 可靠数据传输</h3><ul><li>回顾：IP协议的不可靠，数据报可能会溢出路由器输出缓存，数据报达到目的地址乱序，数据报在传输过程中比特可能损坏；</li><li>TCP是在IP的不可靠服务上创建的可靠数据传输服务（reliable data transfer service）</li><li>确保：进程从接收缓存中读取的数据流是无损坏、无间隔、非冗余、按序</li></ul><h4 id="单一重传定时器简化描述"><a href="#单一重传定时器简化描述" class="headerlink" title="单一重传定时器简化描述"></a>单一重传定时器简化描述</h4><ul><li>事件一，TCP从应用层接收数据，并将数据进行封装，报文段被发送给IP时，TCP启动<strong>定时器</strong>，这里定时器的timeout时间是前面提到的TimeoutInterval，由EstimatedRTT和DevRTT计算得出</li><li>事件二，发送方处理来自接收方的ACK（这里的ACK被包含数据的报文段捎带），TCP将ACK确认号与窗口变量SendBase进行比较，因为累计确认，ACK的值确认了该值前的所有序号的数据都已经正确接收，发送方更新SendBase后，TCP需要重启定时器；</li><li>事件三，超时重传。</li></ul><h4 id="一些有趣的情况-p161"><a href="#一些有趣的情况-p161" class="headerlink" title="一些有趣的情况 p161"></a>一些有趣的情况 p161</h4><ul><li>第一种，确认报文丢失，发送端重传报文，接收端接收重传的报文，<strong>并替换原来的部分报文。</strong></li><li>第二种，同时有两个连续的报文被接收，但是两个确认报文都没有到达发送端，超时事件发生后，主机a重传第一个，若新的超时发生之前，发送端收到了第二个报文的ACK，那么发送端不用再重发第二个报文。</li><li>第三种，前一个ACK丢失，但后面的ACK被收到，由于累计机制，所以不会重传。</li></ul><h4 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h4><ul><li>超时事件发生，TCP重传具有最小序号的还未被确认的报文段；每次重传将下一次的超时时间间隔设置为先前值的2倍，而不是使用计算值，定时器在收到上层数据或者收到ACK报文段时将恢复计算时间为超时时间间隔；</li><li>这里的超时时间间隔的指数型增长，提供了一种简单形式的拥塞控制；</li></ul><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><blockquote><p>冗余ACK就是再次确认某个报文段的ACK</p></blockquote><ul><li><p>超时周期可能太长</p></li><li><p>接收方收到3个冗余ACK（快速重传的条件是3个冗余 ？为什么），TCP执行<strong>快速重传</strong>，即在该报文段定时器超时前重传丢失报文段；</p></li></ul><h4 id="选择确认"><a href="#选择确认" class="headerlink" title="选择确认"></a>选择确认</h4><p>有选择的确认失序报文段，而不是累积到最后一个正确接收的有序报文段，与选择重传相结合；</p><h3 id="3-5-5-流量控制"><a href="#3-5-5-流量控制" class="headerlink" title="3.5.5 流量控制"></a>3.5.5 流量控制</h3><ul><li>流量控制区别于拥塞控制：<strong>流量控制是为了消除发送方使接收方缓存溢出的可能性，拥塞控制是为了处理因IP网络的拥塞造成的遏制。</strong></li><li>TCP缓存溢出：TCP的两则都有接收缓存，TCP接收到正确的、按序的字节后，将数据放入缓存，应用程序从缓存中读取数据，如果应用当前其他事务繁忙，则有可能发送缓存溢出的情况；</li><li>流量控制服务（Flow-control service），匹配发送方的发送速率和接收方应用程序的读取速率；</li><li>流量控制<ul><li>RcvBuffer：配置的接收缓存的大小</li><li>LastByteRead：从缓存中读取的数据的最后一个字节的编号</li><li>LastByteRcvd：达到的按序报文段放入缓存的数据流的最后一个字节的编号</li><li>LastByteRcvd - LastByteRead &lt;= RcvBuffer 必须成立才可不发生溢出</li><li><strong>当前的接收窗口：rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</strong></li><li>rwnd空间为动态变化的空间，rwnd值会被接收主机放入发给发送方的报文段的<strong>”接收窗口“</strong>字段，开始时rwnd = RcvBuffer</li><li>发送方跟踪的变量：LastByteSent, LastByteAcked</li><li>发送方在整个连接的生命周期内必须保证： LastByteSent - LastByteAcked &lt;= rwnd</li><li>发送方要保证，当前所有未被确认的数据长度一定小于等于接收方返回的窗口长度</li><li>特殊情况：接收方窗口为0时，发送发将继续发送只有一个字节数据的报文段，接收方确认，当缓存清空后，确认报文将包含一个非0的窗口值rwnd；这里再清空前还是会发生重传；</li><li>注意：UDP不存在流量控制，所有对于UDP会出现缓存溢出</li></ul></li></ul><h3 id="3-5-6-TCP的连接管理"><a href="#3-5-6-TCP的连接管理" class="headerlink" title="3.5.6 TCP的连接管理"></a>3.5.6 TCP的连接管理</h3><ul><li>TCP连接的建立与拆除</li><li>连接建立的过程会显著增加用户感受到的时延</li><li>网络攻击利用TCP连接管理的弱点、</li></ul><h4 id="连接建立的步骤"><a href="#连接建立的步骤" class="headerlink" title="连接建立的步骤"></a>连接建立的步骤</h4><blockquote><p>isn = identity sequence number</p></blockquote><ol><li>第一步，<strong>客户的TCP服务向服务端的TCP发送一个特殊的TCP报文段，该报文段不包含应用层数据，但是报文段的首部的标志位“SYN”的比特被置为1</strong>；客户随机选择一个起始序号（client_isn），并将该编号放在TCP SYN报文段的序号字段中；<strong>表示发起建立新的连接</strong></li><li>第二步，包含TCP SYN报文段的IP数据报到达服务端，服务器从数据报中提取TCP SYN报文段，为TCP连接分配缓存和变量（这里分配的缓存和变量容易受到洪泛攻击），<strong>并发送允许连接的报文段</strong>，允许连接的报文段：不包含任何应用层数据，SYN标志位被置为1，确认号为client_isn+1，序号为随机选择的服务器初始序号 server_isn；<strong>表示收到了发起连接的SYN的client_isn，同意建立连接，称作SYNACK报文段(SYNACK segment)</strong></li><li>第三步，客户收到SYNACK报文段后，客户给该连接分配缓存和变量，**客户向服务端发送一个对服务端SYNACK的确认，确认序号为server_isn+1，且SYN被置为0，这个数据报中可以携带客户应用层数据；</li></ol><ul><li>这个步骤被称为“3次握手”，从第三个步骤开始次周的报文段传输的过程中SYN标志位都为0，建立的过程中交换了3个分组；</li></ul><h4 id="连接拆除的步骤"><a href="#连接拆除的步骤" class="headerlink" title="连接拆除的步骤"></a>连接拆除的步骤</h4><blockquote><p>两个进程都可以终止当前的连接，连接接收后，TCP服务分配的缓存和变量都会被释放和回收；</p></blockquote><ol><li>客户应用程序发起关闭连接的命令，客户TCP向服务器发送报文段：首部标志位FIN被置为1；</li><li>服务器收到FIN 为1的报文段后，向发送发会送一个确认报文段；</li><li>服务器发送自己的终止报文段，其FIN比特被置为1；</li><li>客户向服务端发送的终止报文段，发送一个确认，此时两台主机上用于该连接的所有资源都被释放；</li></ol><h3 id="3-6-TCP拥塞控制原理"><a href="#3-6-TCP拥塞控制原理" class="headerlink" title="3.6 TCP拥塞控制原理"></a>3.6 TCP拥塞控制原理</h3><ul><li><strong>异步传递方式 ATM</strong></li><li><strong>可用比特率 ABR</strong></li></ul><h4 id="3-6-1-拥塞代价"><a href="#3-6-1-拥塞代价" class="headerlink" title="3.6.1 拥塞代价"></a>3.6.1 拥塞代价</h4><ul><li>代价1：当分组到达的速率接近链路容量时，分组经历了巨大的排队时延；</li><li>代价2：发送方必须执行重传以补偿因为缓存益处导致的分组丢失</li><li>代价3：发送方再遇到网络时延较大的情况下，会重传分组，导致路由器会利用链路带宽来转发一个不需要的分组副本；</li><li>代价4：一个分组沿着一条路径被丢弃时，每个上游的路由器对该分组的转发都是在浪费传输容量；</li></ul><h4 id="3-6-2-拥塞控制方法"><a href="#3-6-2-拥塞控制方法" class="headerlink" title="3.6.2 拥塞控制方法"></a>3.6.2 拥塞控制方法</h4><ul><li><strong>端到端拥塞控制</strong>：TCP通过端到端的方法解决拥塞问题，<strong>IP层不会向端系统提供有关网络拥塞的反馈</strong>；TCP接收方通过三次冗余确认告知接收方报文段的丢失，报文段的丢失就是一种网络拥塞的迹象，TCP会<strong>相应的减小窗口长度</strong>，往返的时延值作为网络拥塞程度的指示；</li><li><strong>网络辅助的拥塞控制</strong>：网络层的路由器会向发送方提供关于链路中的拥塞情况；反馈方式为，阻塞分组（choke packet），路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生；收到标记的分组后，接收方就会向发送方通知网络的拥塞；<strong>ATM拥塞控制（路由器显式的通知发送方链路支持的最大主机发送速率）</strong></li></ul><h3 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a>3.7 TCP 拥塞控制</h3><ul><li><p><strong>TCP使用端到端的拥塞控制机制，IP层不向端系统显示的提供任何网络拥塞程度的反馈；</strong></p></li><li><p>采用的方法：<strong>让每个发送方根据所感知的到的网络的拥塞程度来限制向连接发送流量的速率，动态调整流量发送速率，无拥塞时增加速率，有拥塞时降低速率；</strong></p></li><li><p>TCP拥塞控制算法（TCP congestion control algorithm）</p><ul><li>慢启动</li><li>拥塞避免</li><li>快速恢复</li></ul></li></ul><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><ul><li><p>slow-start，发送方的起始cwnd值为一个MSS，起始发送速率为MSS/RTT，每当传输的报文段首次被确认接收ACK，cwnd就增加一个MSS，在这个过程中每一个RTT，cwnd的值就会翻番，起始阶段很慢，<strong>但是在整个慢启动阶段以指数增加；</strong></p></li><li><p>慢启动对超时和丢包事件的处理，即发送拥塞时的处理，有两种方式：</p><ul><li>1是将cwnd设置为1重新开始慢启动过程，将ssthresh（慢启动阀门）设置为cwnd/2，当出现拥塞将ssthresh设置为拥塞窗口的一半；</li><li>2是当cwnd的值等于ssthresh时，结束慢启动并且将TCP转移到<strong>”拥塞避免模式“</strong>；</li></ul></li><li><p>当检测到3个冗余ACK，这时TCP执行一种快速重传并进入<strong>快速恢复状态</strong>；</p></li></ul><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><ul><li>进入拥塞避免的TCP，cwnd的值大约是遇到拥塞时的一半，这时每个RTT的确认ACK只将cwnd的值<strong>增加1个MSS</strong>；</li><li>出现超时：cwnd的值被设置为1个MSS，ssthresh被设置为cwnd/2，并进入慢启动状态；</li><li>出现冗余ACK事件：TCP将cwnd减半，加上三个ACK的3个MSS，进入快速恢复状态</li></ul><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><ul><li>进入快速恢复后，对每个收到的冗余报文段的ACK，cwnd的值增加一个MSS，当丢失报文的一个ACK到达时，TCP再降低cwnd后进入拥塞避免状态；</li><li>出现超时，执行与拥塞避免相同的操作，进入慢启动状态；</li><li>出现丢包，cwnd的值设置为1个MSS，将ssthresh的值设置为cwnd的一半；</li></ul><h5 id="全局回顾"><a href="#全局回顾" class="headerlink" title="全局回顾"></a>全局回顾</h5><blockquote><p>当TCP通过3个冗余ACK感知到了丢包，TCP进行的拥塞控制是：每个RTT内cwnd线性增加1MSS，出现3个冗余ACK事件时cwnd减半；</p></blockquote><ul><li>TCP拥塞控制：<strong>加性增</strong>，<strong>乘性减</strong></li></ul><h5 id="吞吐量的宏观描述"><a href="#吞吐量的宏观描述" class="headerlink" title="吞吐量的宏观描述"></a>吞吐量的宏观描述</h5><ul><li>一天连接的平均吞吐量<code>0.75 x w /RTT</code> ，这里的w表示当前拥塞窗口的长度；</li></ul><h4 id="3-7-1-公平性"><a href="#3-7-1-公平性" class="headerlink" title="3.7.1 公平性"></a>3.7.1 公平性</h4><ul><li>与UDP：UDP没有内置的拥塞控制，UDP上的应用需要好以恒定的速率将数据注入网络中，UDP连接在TCP的观点看来时不公平的，因为它不与其他的连接合作，也不会适时的调整传输速率，TCP的拥塞控制在面临拥塞增加时，会降低其传输速率，原则上UDP并不会这样做；<strong>UDP源可能会压制TCP流量；</strong></li><li>与并行TCP：TCP应用建立的并行连接会导致网络中应用程序带宽分配的不公平，比如一个WEB来建立多个TCP去传输多个对象；</li></ul><hr><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><ul><li><p>两个部分：</p><ul><li>数据平面：从其输入链路向其输出链路转发数据报</li><li>控制平面：协调这些本地路由器的转发动作</li></ul></li><li><p>交付方式</p><ul><li>数据报模式：因特网所采用的</li><li>虚电路模式</li></ul></li><li><p>网络层功能</p><ul><li>转发 forwarding</li><li>路由选择 routing</li><li>网际协议IP IPv4, IPv6</li><li>网络地址转换NAT</li><li>数据报分段</li><li>因特网控制报文协议ICMP</li><li>路由选择算法：链路状态和距离矢量算法，等级制路由选择方法；RIP，OSPF，IS-IS，BGP</li></ul></li></ul><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><ul><li>路由器的主要作用是将数据报（data grama）从入链路转发到出链路，路由器具有截断的协议栈，即没有网络层以上的部分；路由器除了控制目的外，不运行网络层以上的协议；、</li></ul><h3 id="4-1-1-转发和路由选择"><a href="#4-1-1-转发和路由选择" class="headerlink" title="4.1.1 转发和路由选择"></a>4.1.1 转发和路由选择</h3><ul><li><p><strong>转发：</strong>将分组从输入链路移动到适当的输出链路的过程</p></li><li><p><strong>路由选择：</strong>网络层需要决定分组从发送方到接收方所要采用的路径或者路由，计算这些路径的算法为<strong>路由选择算法</strong> routing algorithm</p></li><li><p>每台路由器有一张</p><p>转发表（forwarding table）</p><ul><li>转发表存储：分组首部的值和路由表的输出链路接口</li><li>路由器通过检查到达的分组首部的字段，用该字段值再转发表中查询，从而找出输出链路的接口</li><li>路由选择算法，决定了插入路由器的转发表中的值，路由选择算法可能是集中式的也可能是分布式的；</li><li>路由器接收路由选择协议报文，将报文信息用以配置路由转发表；</li></ul></li><li><p>控制平面传统方法：路由选择算法运行在每台路由器中，并在每台路由器中都含有转发和路由选择这两种功能</p></li><li><p>控制平面SDN方法：路由选择设备仅支持转发，而远程控制器计算并分发转发表</p></li></ul><h3 id="4-1-2-网络服务模型"><a href="#4-1-2-网络服务模型" class="headerlink" title="4.1.2 网络服务模型"></a>4.1.2 网络服务模型</h3><ul><li>网络服务模型 network service model 定义了分组再发送与接收端系统之间端到端的端运输特性</li><li>网络层提供的服务/特性<ul><li>确保交付：确保分组最终到达目的地</li><li>具有时延上界的确保交付：确保分组交付，且再特定主机到主机时延上界内交付</li><li>有序分组交付：分组按照发送顺序达到目的地</li><li>确保最小带宽：主机以低于特定比特率的速率传输比特，则不会发送分组丢失，且分组再预定的时延内到达；</li><li>确保最大时延抖动：确保发送方两个相继分组间的时间量 = 目的地接收两个分组之间的时间量</li><li>安全性服务，使用源和目的主机知道的会话密钥，再源主机的网络层加密向目的主机发送的所有数据报负载；</li></ul></li><li>因特网<strong>尽力而为服务</strong>，分组间的定时不能被保证，分组接受顺序也不能保证，发送分组最终是否能交付也不能保证；但是实践证明，足够好</li></ul><h3 id="4-1-3-虚电路和数据报网络"><a href="#4-1-3-虚电路和数据报网络" class="headerlink" title="4.1.3 虚电路和数据报网络"></a>4.1.3 虚电路和数据报网络</h3><ul><li>网络层的面向连接服务和无连接服务<ul><li>网络层的面向连接服务和无连接服务向运输层提供主机到主机的服务，运输层则是向应用层提供进程到进程之间的服务；</li><li>只在网络层提供连接服务的网络：<strong>虚电路网络 Virtual-Circuit VC</strong></li><li>只在网络层提供无连接服务的网络：<strong>数据报网络 datagram network</strong></li><li>运输层的连接服务只在网络边缘的端系统中实现，网络层的连接服务再端系统中和网络核心的路由器中实现；</li><li>计算机网路的两种基本类型：<strong>虚电路网络， 数据报网络</strong></li></ul></li></ul><h5 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h5><ul><li>ATM、帧中继的体系结构都是虚电路网络，在网络层使用连接，成为虚电路；</li><li>虚电路的组成：<ul><li>源和目的之间的路径，链路和路由器</li><li>VC号，沿着该路径的每段链路的一个号码；</li><li>沿着路径的每台路由器中的转发表表项；<ul><li>每台路路由器会为分组替换一个新的VC号，分组在每条链路上有不同的VC号，且再分组的首部携带；</li><li>路由器的转发表会管理入VC号字段和对应的出VC号字段；</li><li>创建虚电路对路由器新增转发项，终止一条虚电路，删除相应的转发表项；</li><li>路由器需要对进行中的连接 维持<strong>连接状态信息</strong>，分组跨越一个路由器就创建新连接，增加路由器的表项，每释放一个连接从表中删除表项；</li></ul></li></ul></li><li>虚电路的3个阶段<ul><li>虚电路建立，运输层向网络层指定接收方地址，网络层决定一条分组通过的路径，网络层沿着路径向链路中的每一个路由器节点决定VC，在转发表中增加表项；</li><li>数据传输，分组沿着创建号的虚电路流动；</li><li>虚电路拆除，发送方或者接收方通知网络层希望终止该电路时，网络层会通知另一侧的端系统结束呼叫并更新路径上的每台路由器的转发表；</li></ul></li><li>沿着两个端系统之间的路径上的路由器都要参与虚电路的建立，且<strong>每台路由器都完全知道通过它的所有虚电路</strong>；</li></ul><h5 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h5><ul><li>端系统为想要发送的分组加上目的端系统的地址，然后将分组推进网络中；路由器不维护任何虚电路；</li><li>分组在链路中经过每一台路由器，<strong>路由器都是用分组目的地址来对分组进行转发</strong>；</li><li>每台路由器维护一个<strong>链路接口转发表</strong>用来给目的地址做映射，对于到达分组，路由器会使用其首部的目的地址在链路转发表中查找适当的输出链路接口；然后路由器将分组向该接口转发；</li><li>IPv4地址长度 32 位bit，4段（4 group）</li><li>IPv6地址长度128位bit，8段（16进制，8group）</li><li>转发表：路由器用分组的目的地址的<strong>前缀（prefix）</strong>与该表中的表项进行匹配；当初先多匹配时，例如一个分组的目的地址与转发表中的21位表项匹配且又与24位表项匹配，<strong>则路由器使用最长前缀匹配规则</strong>，将该分组转发到24位表项相匹配的输出链路接口上，路由器总是在<strong>链路接口转发表中</strong>匹配最长的prefix，最长匹配项；最长匹配与编址规则有关；</li><li>路由器维护的转发表，维持了转发转台信息，转发表由<strong>路由选择算法进行更新和修改</strong>，路由器建立新连接和拆除一条连接都会更新转发表；</li></ul><hr><p>这一部分是数据平面相关的内容</p><p>需要更细致的了解<strong>分组交换机</strong>：</p><ul><li>链路层交换机：基于链路层帧中的字段值做出决定</li><li>路由器：基于网络层帧的字段做出决定</li></ul><h2 id="4-2-路由器的工作原理"><a href="#4-2-路由器的工作原理" class="headerlink" title="4.2 路由器的工作原理"></a>4.2 路由器的工作原理</h2><ul><li><p><strong>转发功能</strong>：将分组从路由器的入链路传送到适当的出链路</p></li><li><p>路由器的体系结构</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230307163533160.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230307163533160"></p></li><li><p>输入端口：</p><ul><li><p>物理层功能：将一条输入链路与路由器相连接</p></li><li><p>数据链路层功能：与位于入链路远端的数据链路层交互</p></li><li><p>通过查询转发表决定输出端口，到达分组通过路由器的交换结构转发到输出端口；</p></li><li><p>将“控制分组”从输入端口转发到路由器的“选择处理器”，（携带路由选择控制协议的分组）</p><blockquote><p><strong>端口</strong>，这个词语在网络硬件中表示，路由器物理的输入和输出接口；</p></blockquote></li></ul></li><li><p>交换结构：</p><ul><li>与输入端口和输出端口相连，交换结构完全包换在路由器中，网络路由器中的网络；</li></ul></li><li><p>输出端口：</p><ul><li>存储从交换结构接收的分组</li><li>执行相应的物理层和链路层功能，在输出链路上传输分组</li><li>双向链路，输出端口和输入端口在同一线路卡上成对出现；</li></ul></li><li><p>路由选择处理器：</p><ul><li>执行路由选择协议</li><li>维护路由表及连接的链路状态信息</li><li>计算转发表</li><li>执行网络管理功能</li></ul></li><li><p><strong>路由转发平面 router forwarding plane</strong> ：路由转发是路由器用输入输出端口、交换结构共同实现的转发功能，总是用“硬件”实现；</p><ul><li>路由器对n个端口数据的处理，数据处理流水线需要n倍的处理速率，通过厂商定制的硬件来实现这样的功能；</li></ul></li><li><p><strong>路由器控制平面 router control plane</strong> ：通过软件实现，路由器的控制功能，包括执行路由选择协议，对上线和下线的连接链路进行响应，及路由的管理功能；</p></li><li><p>路由器和交换机的设计面对一系列的拥堵问题；</p></li></ul><h3 id="4-2-1-输入端口"><a href="#4-2-1-输入端口" class="headerlink" title="4.2.1 输入端口"></a>4.2.1 输入端口</h3><ul><li>输入端口的<strong>线路端接功能</strong> 与 <strong>链路层处理</strong> 实现了用于各个输入链路的物理层和链路层，执行输出链路处理，包括链路协议，和分组的拆封；</li><li>输入端口中：<strong>路由器使用转发表来查找输出端口</strong>，最长前缀匹配，使得到达的分组能够经过交换结构转发到该输出端口；</li><li>转发表由路由器的选择处理器计算和更新，转发表的一份影子副本通常会被存放在每个输入端口；</li><li>转发表从路由选择处理器经过独立总线，复制到线路卡；</li><li>影子副本的作用：在每个端口本地作出转发决策，无需调用中央路由选择处理器，避免了集中式处理的瓶颈；</li><li>因为交换结构可能会被其他的分组使用，当前已经匹配了转发表项的输入分组需要在输入端口排队，并等待 被调度通过交换结构；</li></ul><h3 id="4-2-2-交换结构"><a href="#4-2-2-交换结构" class="headerlink" title="4.2.2 交换结构"></a>4.2.2 交换结构</h3><h4 id="三种交换技术"><a href="#三种交换技术" class="headerlink" title="三种交换技术"></a>三种交换技术</h4><blockquote><p>内存，总线，纵横</p></blockquote><ul><li>经内存交换<ul><li>传统计算机的设计方式，<strong>CPU</strong>对分组进行在内存的I/O操作；</li><li>现代内存交换：输入线路卡查找转发表，并将分组放入适当的内存存储位置，也就是输出端口的内存</li></ul></li><li>经总线交换<ul><li>通过共享总线将分组发送到输出端口<ul><li>输入端口为分组预先计划一个内部标签（首部），该标签用来标识输出端口</li><li>分组在总线上传送到输出端口</li><li>所有输出端口都会收到分组，只有与标签匹配的端口才将分组保存，然后标签在输出端口被去除</li></ul></li><li>一次只有一个分组可以跨越总线，路由器的交换带宽受到其总线速率的限制；</li></ul></li><li>经互联网络交换<ul><li>纵横式交换机是一种由2N条总线组成的互联网络；</li><li>连接N个输入端口和N个输出端口</li><li>垂直总线在交叉点和水平总线交叉，交叉点通过交换结构控制器能在任何时候开启和闭合；</li><li>对于来自不同输入需要达到不同输出端口的分组，纵横网络能够转发多个这样的分组；</li><li>对于进入相同总线的分组，还是需要排队等待；</li></ul></li></ul><h3 id="4-2-3-输出端口"><a href="#4-2-3-输出端口" class="headerlink" title="4.2.3 输出端口"></a>4.2.3 输出端口</h3><ul><li>输出端口：取<strong>出存放在输出端口内存中的分组，并将其发送到输出链路上；</strong></li><li>选择和取出排队分组进行传输，执行链路层和物理层传输功能；</li></ul><h3 id="4-2-4-排队"><a href="#4-2-4-排队" class="headerlink" title="4.2.4 排队"></a>4.2.4 排队</h3><ul><li>输入和输出端口处都会形成分组排队</li><li>排队位置和程度：取决于流量负载、交换结构的相对速率、线路速率；</li><li>随着队列增长，路由器的缓存空间最终耗尽，新到达的分组将会出现<strong>丢包</strong> </li></ul><h3 id="4-2-5分组调度程序"><a href="#4-2-5分组调度程序" class="headerlink" title="4.2.5分组调度程序"></a>4.2.5分组调度程序</h3><ul><li>服务原则<ul><li>先来先服务 FCFS</li><li>优先权排队</li><li>循环和加权公平排队</li></ul></li></ul><h2 id="4-3-网际协议：-转发和编址"><a href="#4-3-网际协议：-转发和编址" class="headerlink" title="4.3 网际协议： 转发和编址"></a>4.3 网际协议： 转发和编址</h2><h3 id="4-3-1-IPv4数据报格式"><a href="#4-3-1-IPv4数据报格式" class="headerlink" title="4.3.1 IPv4数据报格式"></a>4.3.1 IPv4数据报格式</h3><ul><li>网络层的分组： <strong>数据报</strong> datagram</li><li>IPv4 数据报格式</li></ul><table><thead><tr><th align="center">IPv4数据报格式 一行32bit</th></tr></thead><tbody><tr><td align="center">版本 | 首部长度 | 服务类型 | 数据报长度（字节）</td></tr><tr><td align="center">16比特标识 | 标志 | 13比特片偏移</td></tr><tr><td align="center">寿命 | 上层协议 | 首部检验和</td></tr><tr><td align="center">32比特源IP地址</td></tr><tr><td align="center">32比特目的IP地址</td></tr><tr><td align="center">选项（如果有的话）</td></tr><tr><td align="center">数据</td></tr></tbody></table><ul><li><p>版本：4个比特，IP协议版本</p></li><li><p>首部长度：4个比特，用来确定数据部分从哪里开始，不包含选项的情况，数据报首部为20字节</p></li><li><p>服务类型：TOS，实时数据报，非实时数据报，用来确定数据报的优先级</p></li><li><p>数据报长度：包括首部的IP数据报的总长度，16比特，最大理论长度2^ 16,65535</p></li><li><p>标识、标志、片偏移：IP分片</p></li><li><p>寿命：Time-To-Live TTL，每经过一个路由器，该值减1，TTl为0时丢弃，取保数据报不会永远在路由选择环路中循环转发；</p></li><li><p>协议：上层协议，6为TCP，17为UDP</p><p>&gt; 协议号：网络层与运输层绑定到一起的粘合剂 &gt; &gt; 端口号：运输层与应用层绑定到一起的粘合剂 &gt; &gt; 链路层帧</p></li><li><p>首部检验和：checksum，检验收到的ip数据报中的比特错误；</p><ul><li>只对首部做检验</li><li>计算方式：将首部中的每2个字节，也就是16个比特相加在进行反码运算；</li><li>每个路由器都要对每个收到的IP数据报进行首部检验和的计算，检测出差错就丢弃，因为TTL每次都会减1，所有路由器会每次重新计算检验和并放置到数据报的检验和位置</li><li>IP协议和TCP/UDP协议都需要进行检验和<ol><li>IP数据报只是对数据报的首部进行检验</li><li>TCP/UDP是对整个报文段进行检验，而且报文段就是IP数据报的数据部分</li><li>TCP原则上可以运行在其他协议上 如ATM</li></ol></li></ul></li><li><p>源和目的IP地址</p></li><li><p>选项：允许IP首部被扩展，很少使用，已经在IPv6中去除</p></li><li><p>数据：有效载荷，运输层报文段，或者ICMP报文</p></li></ul><blockquote><p>对于无 “选项” 的IP数据报首部总长度为20个字节；</p><p>如果IP数据报承载了TCP报文段，则数据报承载了20字节的IP数据报首部，20字节的运输层TCP报文段的首部，及应用层报文；</p></blockquote><h3 id="4-3-2-IP数据报分片"><a href="#4-3-2-IP数据报分片" class="headerlink" title="4.3.2 IP数据报分片"></a>4.3.2 IP数据报分片</h3><ul><li>对于不同的链路层协议，其能承载的网路层数据报的长度不同，以太网协议能承载1500字节的数据，某些广域网链路帧可承受不超过576字节的数据；</li><li><strong>“最大传送单元”</strong>：Maximum Transmission Unit, MTU, 一个链路层数据帧能够承载的最大数据量；</li><li>发送方和接收方的路径上的每段链路可能使用不同的链路层协议，每种协议都可能由不同的MTU；</li><li>对于过大的IP数据报，超过链路MTU的情况下，需要对IP数据报做分片；单独的链路帧将封装这些较小的IP数据报；然后将链路帧发送到链路上，每个较小的数据报为<strong>“片”</strong> fragment</li><li>分片方法：<ul><li>发送端该数据报设置源目的地址的同时，会贴上“标识”，为每个发送的数据报标识加1；</li><li>路由器需要对数据报分片时，每个数据报都会由源目的地址和自己的标识号；</li><li>目的主机通过标识号确定那些数据报（片）是同一个大的数据报；</li><li>最后一片的标志比特为0，其他片的标志比特为1，目的是让目的端确定已经收到了所有的片；</li><li>偏移字段用来指定该片在数据报中的位置，目的端按照顺序组装，同时也可以确定数据报是否有片丢失；</li></ul></li><li>目的端，只有当IP层已经完成了重构初始IP数据报时，有效载荷才会被传递给运输层；如果一片或者多片没有到达目的地，则不完整的数据报会被丢弃，不会交给运输层；TCP超时重传、选择重传、快速重传，<strong>IPv4将重新组装工作放在端系统中</strong></li></ul><h3 id="4-4-3-IPv4-编址"><a href="#4-4-3-IPv4-编址" class="headerlink" title="4.4.3 IPv4 编址"></a>4.4.3 IPv4 编址</h3><ul><li><p>主机与路由器连入网络</p><ul><li>一台主机通常只有一条链路连接到网络；</li><li>主机和物理链路之间的边界叫做<strong>接口 interface</strong>；</li><li>一个IP地址与一个接口相关联，不与主机及路由器相关联；</li><li>IP地址，<strong>32bit</strong>，点分十进制法书写；</li><li>因特网处NAT之外的每台主机、路由器的接口都有一个唯一的IP地址；</li><li>IP地址的一部分由连接的子网来决定；</li><li>例子：<ul><li>3台主机与1台路由器相连，4个接口的ip地址的前24bit相同；</li><li>3个主机的接口与一个路由器的接口形成一个子网（subnet）；</li><li>IP编址为这个子网分配一个地址，<strong>”/24“</strong>，为子网掩码（network mask），这表示32bit中最左侧的24比特定义了子网地址；</li><li>任何需要连入该子网的主机，ip地址都需要具有与前24bit子网地址相同的形式；</li><li>确定网络中子网的方法：<ul><li>分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口“端接”隔离的网络端点，隔离的网络中的每一个都是一个子网（subnet）</li></ul></li><li>一个具有“多个以太网段”和点对点链路的组织将具有多个子网；</li></ul></li></ul></li><li><p>地址分配策略：</p><ul><li>无类别域间路由选择（Classless Interdomain Routing，CIDR）</li><li>CIDR将子网地址划分为两部分，表示为a.b.c.d/x，其中x表示地址的第一部分的比特数；</li><li>a.b.c.d/x 的地址的x 最高比特构成了ip地址的网络部分，地址的前缀（prefix）（网络前缀）；</li><li>路由选择协议，转发只考虑该网络前面的前缀比特x，这就减少了路由器中转发表的长度；</li><li>实践原则：<ul><li>地址聚合 address aggregation：使用单个网络前缀通告多个网络或多个子网的能力</li><li>也称作 路由聚合 route aggregation，路由摘要 route summarization</li></ul></li><li>一个地址剩余的32-x比特用来区分内部设备；只有内部设备连接的内部路由器在转发分组时，才会考虑这些剩余的bit；低级的bit可能有另外的子网结构；<ul><li>例如：a.b.c.d/21中的前21个比特表示当前组织的网络前缀，a.b.c.d/24表示组织内部的子网；</li></ul></li><li>分类编址，旧方式</li><li>ip广播地址 255.255.255.255，当一台主机向广播目的地址发送数据报时，该报文会交付给同一子网内所有的主机；</li></ul></li><li><p>获取地址</p><ul><li>从ISP获取，因特网名字和编号分配机构获取；（Internet Corporation for Assigned Names and Numbers，ICANN）</li></ul></li><li><p>DHCP 动态主机配置协议</p><ul><li>DHCP允许主机自动获取（被分配）IP地址，可以配置，在每次连接外部网络时都能获得相同的IP地址，或者被分配一个<strong>临时的IP地址</strong>（temporary IP address）；</li><li>DHCP还允许主机得知，子网掩码，第一跳路由器地址（默认网关），与本地DNS服务器地址</li><li>DHCP为 <strong>即插即用协议</strong></li><li>DHCP在主机加入或者 离开网络时，DHCP服务器会更新可用IP地址表；一台机器加入，则从当前可用地址池中分配任意一个地址；主机离开时，地址会回收到该地址池中；</li><li>客户-服务器协议，客户为新到达的主机，客户需要获取一个自身使用的IP地址和网络配置信息；如果该网络中没有DHCP服务器，则需要一个DHCP中继代理；</li><li>对于新到达的主机DHCP的四个步骤：<ol><li>DHCP服务器发现，DHCP发现报文（DHCP discover message)，客户使用UDP的DHCP发现报文，以广播地址255.255.255.255作为目的地址，本机源地址0.0.0.0作为源地址，67作为目标端口，DHCP客户将IP数据报传递给链路层，链路层将帧广播到所有与该子网连接的子网；</li><li>DHCP服务器提供，DHCP服务器收到报文后，用DHCP提供报文（DHCP offer message）向客户做出响应；仍然使用广播地址<ol><li>提供报文包括：发现报文的事务ID，向客户推荐的IP地址、网络掩码及IP地址租用期（address lease time）</li></ol></li><li>DHCP请求，客户从多个DHCP服务器中选择一个，并向服务器发送DHCP请求响应（DHCP request message）进行响应，回显配置参数；</li><li>DHCP ACK，服务器用DHCP ACK报文对DHCP请求报文进行确认响应；</li></ol></li><li>客户收到DHCP ACK之后，交互完成，客户可用在租用期之内使用分配的IP地址，如果超时后还希望继续使用，DHCP提供一种机制允许用户更新对地址的租用；</li></ul></li></ul><h3 id="4-3-4-网络地址转换NAT"><a href="#4-3-4-网络地址转换NAT" class="headerlink" title="4.3.4  网络地址转换NAT"></a>4.3.4  网络地址转换NAT</h3><ul><li><p>NAT<strong>“使能”</strong>路由器对于外部网络来说，就是一台具有单一ip的设备，所有离开这个NAT子网的数据报，都有同一个源地址IP，所有进入该网络的数据报都有同一个相同的目的IP；</p></li><li><p>本质：NAT使能路由器对外界<strong>隐藏了内部网络的细节</strong>；</p></li><li><p>在此网络内部，有独立的NAT-DHCP服务为内部的设备分配IP，路由器从ISP的DHCP服务获取外部IP；</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230307193214279.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230307193214279"></p></li><li><p><strong>NAT转换表</strong> 如上图</p><ul><li><strong>表中包含了WAN端的IP地址和端口 及 映射的 LAN端 IP地址和端口</strong></li><li>对于本地子网要发送的数据报，NAT会将内部子网主机的IP地址及端口号，记录在转发表的LAN端，NAT路由器收到数据报后会生成一个新的源端口（选择当前任意一个不在转换表中的端口，支持超过60 000个并行的广域网IP地址连接），<strong>并将数据报中的端口改为新的源端口，IP地址改为NAT的接口的广域网IP地址</strong>，并将数据报发送到目的地址；目的主机无法感知数据报中的源IP和端口都经过NAT协议的改装；</li><li><strong>目的端响应报文到达NAT路由器时，路由器会使用数据报中的源IP地址和源端口检索出内部子网主机的ip和端口，并改写数据报的目的IP和目的端口，并向主机转发该数据报，当有多个内部主机去访问同一个服务器时，</strong>从返回的信息不足以区分响应应该转发到哪个内部主机。此时，需要NAT设备根据传输层信息或其他上层协议去区分不同的会话，并且可能要对上层协议的标识进行转换，比如TCP或UDP端口号。这样NAT网关就可以将不同的内部连接访问映射到同一公网IP的不同传输层端口，通过这种方式实现公网IP的复用和解复用。<h3 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5 IPv6"></a>4.3.5 IPv6</h3></li></ul></li></ul><p>由于32bit的IP地址空间即将耗尽而形成的一种新的网际协议</p><h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><ul><li>IPv6数据报格式</li></ul><table><thead><tr><th align="center">32bit一行</th></tr></thead><tbody><tr><td align="center">版本 | 流量类型 | 流标签</td></tr><tr><td align="center">有效载荷长度 | 下一个首部 | 跳限制</td></tr><tr><td align="center">源地址 （128bit）</td></tr><tr><td align="center">目的地址 （128bit）</td></tr><tr><td align="center">数据</td></tr></tbody></table><ul><li>IPv6数据报格式变化<ul><li>扩大的地址容量<ul><li><strong>地址容量从32bit扩大到128比特</strong>，用16进制表示；</li><li>IPv6引入了<strong>任播地址</strong> （anycast address），用来将数据报交付给一组主机中的任意一个；</li></ul></li><li>简化的高效的40字节首部<ul><li>40字节定长首部，去除IPv4中的选项字段，允许更快的处理IP数据报</li></ul></li><li>流标签与优先级<ul><li>Flow：给属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流；</li><li>音频和视频的传输就是一种“流”</li><li>流量类型字段，类似与IPv4中的TOS字段，用于给出一个流中某些数据报的优先级，用来指示某些应用程序的数据报比其他应用有更高的优先权；</li></ul></li></ul></li><li>IPv6数据报的结构更简单，更高效：<ul><li>版本：4bit，用于标识IP版本号； 6</li><li>流量类型：8bit，与IPv4中的TOS字段含义相似</li><li>流标签：20bit，用于标识一条数据报的流</li><li>有效载荷长度：16bit，给出IPv6数据报中定长40字节的首部后面的数据部分的比特数；</li><li>下一个首部：标识数据报中的内容需要交付给，哪个协议（TCP/UDP）与IPv4中的上层协议字段相同</li><li>跳限制：转发数据报的每台路由器对该值减1，当计数为0时，数据报被丢弃；用来限制数据报转发的路由器数量，防止数据报在环路中一直存在；</li><li>源地址和目的地址：128bit的源地址和目的地址字段</li><li>数据：有效载荷部分，包括运输层报文段的首部及应用层数据部分</li></ul></li><li>IPv4数据报中的字段在IPv6中已不存在<ul><li>分片/重新组装：IPv6不允许路由器对数据报进行分片和组装；分片和重新组装只在源和目的端执行；当路由器遇到较大分组无法转发到链路时（如超过1500个字节），直接将数据报丢弃，并向发送方回复“分组太大的” ICMP差错报文，ICMP报文也封装在IP数据报中；这样发送端收到ICMP报文后，将数据报在端系统出进行分片，从而加快了转发速率；</li><li>首部检验和：为了快速处理IP分组，将检验和去除，数据报中只有运输层报文端有首部检验和做检验；（IPv4的耗时主要体现在每个数据报都有自己的TTL，所有每个路由器进行检验后，还需要更新数据报中的检验和）</li><li>选项：选项字段去除，但是任然有选项的存在，如“下一个首部”字段指向的位置有可能时“选项”<h4 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h4></li></ul></li></ul><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230307194809237.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230307194809237"></p><ul><li><p><strong>双栈</strong>， 有发送和接收IPv4，IPv6两种数据报的能力；</p></li><li><p>IPv6/IPv4节点必须有IPv6和IPv4两种地址；</p></li><li><p>IPv6数据报可以转换成IPv4数据报，但是会丢失IPv6数据报首部 一些在IPv4中无对应项的字段信息；</p></li><li><p>建隧道（tunneling），两个端系统进行IPv6数据报的交换，但是中间有一个IPv4的路由器，两个IPv6路由器之间的IPv4路由器的集合为 <strong>隧道</strong> Tunnel，借助隧道，在隧道发送端的IPv6结点，将IPv6数据报方到一个IPv4数据报的数据部分（有效载荷），该IPv4数据报通过中间路由被转发到隧道接收端，隧道接收到取出IPv6的数据，然后再为IPv6的数据报提供转发；</p></li></ul><h2 id="4-4-通用转发和SDN"><a href="#4-4-通用转发和SDN" class="headerlink" title="4.4 通用转发和SDN"></a>4.4 通用转发和SDN</h2><hr><p>下面是有关<strong>控制平面</strong>的东西</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230308100610957.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230308100610957"></p><p>完成控制平面工作可能有两种做法：</p><ul><li>每路由器控制</li><li>逻辑集中控制：SDN采用了这种方式。</li></ul><h2 id="4-5-路由选择算法"><a href="#4-5-路由选择算法" class="headerlink" title="4.5 路由选择算法"></a>4.5 路由选择算法</h2><ul><li><p>可以用图来形式化的描述路由选择问题</p></li><li><p>分类</p><ul><li>集中式的路由选择算法<ul><li>该算法为“集中式的全局路由选择算法”</li><li>输入为所有节点的连通性及链路的费用，算法执行前需要<strong>获取全局的完整信息</strong>；</li><li>全局状态信息：<strong>链路状态算法</strong></li></ul></li><li>分散式路由选择算法<ul><li>以迭代、分布式的方式计算出最低费用路径，迭代的每个节点逐渐的计算到达某目的节点的最低费用；</li><li>距离向量算法DV</li></ul></li></ul></li><li><p>第二种广义分类</p><ul><li>静态路由选择算法（static routing algorithm），路由变化缓慢，通常人工调整</li><li>动态路由选择算法（dynamic routing algorithm），网络流量负载或者拓扑发生变化时改变路由选择路径；动态算法周期性的运行或者对拓扑变化直接响应</li></ul></li><li><p>第三种分类</p><ul><li>负载敏感算法（load-sensitive algorithm）</li><li>负载迟钝算法（load-insensitive algorithm），链路费用无法直接反应链路拥塞水平</li></ul></li></ul><h3 id="4-5-1-链路状态路由选择算法"><a href="#4-5-1-链路状态路由选择算法" class="headerlink" title="4.5.1 链路状态路由选择算法"></a>4.5.1 链路状态路由选择算法</h3><ul><li>链路状态算法中，网络拓扑和所以的链路状态都是已知的，并且作为LS算法的输入</li><li>实践中<ul><li>让每个结点向网络中所有其他结点广播链路状态分组</li><li>每个链路状态分组包含它所连接的链路的特征和费用 例如OSPF路由选择协议</li><li>链路状态广播算法 （link state broadcast）来完成</li><li>广播的结果是该网络中的所有结点都具有了与该网络等同的、完整的视图</li><li>每个结点都能运行LS算法计算出最低费用的集合</li></ul></li><li>Dijkstra算法<ul><li>Dijkstra算法计算源结点到网络中其他所有结点最低费用路径</li><li>此算法的最差时间复杂都为 O(n^2)，使用堆的数据结构，可以将时间复杂度降低到logn级别</li><li>当链路的费用依赖于当前链路所承载的流量时，链路状态选择算法会出现<strong>”振荡“</strong>，解决方式是确保路由器不同时运行LS算法；</li><li><a href="http://www.auswitz.top/2021/12/24/cnet-python-kruscul/">有关Dijstra的模拟实验</a></li></ul></li></ul><h3 id="4-5-2-距离向量路由选择算法"><a href="#4-5-2-距离向量路由选择算法" class="headerlink" title="4.5.2 距离向量路由选择算法"></a>4.5.2 距离向量路由选择算法</h3><ul><li><p><strong>距离向量 （Distance-Vector）</strong>算法</p><ul><li>迭代：获取信息和执行计算的过程需要持续到邻居之间无更多的信息交换为止</li><li>异步：不要求所有结点步骤一致的进行操作</li><li>分布式：每个结点要从一个或者多个直接相邻的结点获取信息，执行计算，将结果分发给邻居</li></ul><p>&gt; Bellman-Ford方程： 获取x到所有邻结点的费用，取从这些邻结点v到目标结点y的最小费用，则x到y的最小费用是所以邻居v的 <strong>c(x, v) + d v (y)</strong> 的最小值<br>$$<br>d_x (y) = min _v{ c(x, v) + d _v (y) }<br>$$</p></li><li><p><strong>DV算法的基本思想</strong></p><ul><li>每个结点x，对N中的所有结点，估计从自己到结点y的最低费用；</li><li>每个结点x，维护的信息如下：<ul><li>对于每个邻居v，从x到直接邻居v的费用 c(x, v)</li><li>结点x的距离向量，包含了x到N中所有目的地y的费用估计值</li><li>每个邻居的距离向量，x的每个邻居v</li></ul></li><li>算法思想的理解：<ul><li>该算法以分布式的方式，在网络中，每个结点接收相邻结点的距离向量副本，每次更新都会触发结点向响铃结点广播自己最新的距离向量；</li><li>每个结点根据B-F方程的思想不断更新自己缓存的到其他每个结点的最小距离；（最低费用）</li><li>当所有结点触发的更新完成后，也就是不再有异步更新时，该网络中的路由选择表趋于稳定；</li></ul></li><li>路由器需要周期性与相邻的路由器交换更新通告，动态建立路由表，以决定最短路径。</li></ul></li><li><p>伪代码：</p></li></ul><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gml">对每个结点<span class="hljs-symbol">x</span>进行如下操作：<br>    初始化：<br>        遍历所有网络中的所有目的地<span class="hljs-symbol">y</span>：<br>            估计 <span class="hljs-symbol">x</span> 的距离向量。如果是非邻接结点，那么距离为∞。<br>        遍历每个邻接结点 w：<br>            邻接结点 w 的距离向量。初始估计，不准确的。<br>        遍历每个邻接结点 w:    <br>            发送本结点 <span class="hljs-symbol">x</span> 的距离向量到每个邻接结点 w。<br> <br>    <br>    循环：<br>        等待（知道存在链路状态变化或者收到其他结点的距离向量之后终止等待）<br>        <br>        遍历网络N中的每个结点 <span class="hljs-symbol">y</span>：<br>            依照bellman-ford方程更新本地 <span class="hljs-symbol">x</span> 距离向量<br> <br>        如果 <span class="hljs-symbol">x</span> 的距离向量存在变化<br>            发送 <span class="hljs-symbol">x</span> 的距离向量给每一个邻居结点。<br></code></pre></td></tr></table></figure><ul><li>在该分布式、异步的算法中，每个结点不时的向它的每个邻居发送它的距离向量副本，当结点x从它的任意一个邻居v接收到新的距离向量，保持v的距离向量，然后使用Bellman-Ford方程更新他自己的距离向量，对每个节点；结点x的距离向量更新后，向每个邻居发送更新后的向量；最终结果会收敛到最低费用路径；</li></ul><blockquote><p>Dijkstra算法，LS算法是全局的，在运行之前需要先获取整改网络的完整信息</p><p>DV算法是分布式和异步的，每个结点具有的信息是他到直接相邻结点的链路费用，和它收到的这些邻居发给它的信息；</p><p>DV算法的实践： RIP、BGP、ISO IDRP、Novell IPX</p></blockquote><ul><li>从邻居接收更新的距离向量、重新计算<strong>路由选择表</strong> 和通知邻居到目的地的最低费用路径的费用已经发送变化，这个过程会持续下去，直到无更新报文发送为止；这时算法进入等待状态，直到再次有线路费用变化触发算法；</li></ul><h5 id="1-距离向量算法：链路费用改变与链路故障"><a href="#1-距离向量算法：链路费用改变与链路故障" class="headerlink" title="1. 距离向量算法：链路费用改变与链路故障"></a>1. 距离向量算法：链路费用改变与链路故障</h5><ul><li><p>在链路费用变化的过程中，如果某个结点接受了邻居结点的信息后，路由选择表并没有更新，则该结点不再向其邻居结点发送信息；</p></li><li><p><strong>路由选择环路 routing loop</strong></p><ul><li><p>分组将在两个结点之间不停的转发</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230308104014621.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230308104014621"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230308103959246.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230308103959246"></p></li><li><p>无穷级数问题</p></li></ul></li></ul><h5 id="2-距离向量算法：增加毒性逆转"><a href="#2-距离向量算法：增加毒性逆转" class="headerlink" title="2. 距离向量算法：增加毒性逆转"></a>2. 距离向量算法：增加毒性逆转</h5><ul><li><strong>毒性逆转 （poisoned reverse）</strong>，可以避免路由环路</li><li>如上图5.7的实现方法：<strong>如果z通过y到达x，那么这段z将通告这段z到x的长度为∞</strong></li><li>无法解决3个或者更多系欸但的环路问题</li></ul><h5 id="3-LS与DB路由选择算法的比较"><a href="#3-LS与DB路由选择算法的比较" class="headerlink" title="3. LS与DB路由选择算法的比较"></a>3. LS与DB路由选择算法的比较</h5><ul><li><p>DV和LS算法采用<strong>互补</strong>的方法来解决路由选择计算问题；</p></li><li><p>比较 N为结点集合（路由器） E是边（链路）集合</p><ul><li><p>报文复杂性</p><ul><li>DV算法要求每次迭代时，在两个直接相邻的结点之间交换报文；当链路费用发生变化时，DV算法仅在新的链路费用，导致与该链路相连的结点的最低费用改变时，才会向其他相邻结点传播费用信息，如果不在发生改变则不会在向相邻结点发送；</li></ul></li><li><p>收敛速度</p><ul><li>DV算法收敛较慢，而且遇到路由选择环路时，会遇到无穷计数的问题；</li></ul></li><li><p>健壮性</p><ul><li>LS：一个结点可以会损坏或者丢弃它收到的LS广播分组，但是LS结点只计算自己的转发表，每个结点各自接收广播分组，各自进行计算，提供了一定程度的健壮性；</li><li>DV算法：一个结点如果产生了错误的链路费用，会通知它所有的相邻结点，这个错误会一直扩散到整个网络的所有路由器上；</li></ul></li></ul></li></ul><h3 id="4-5-4-层次路由选择"><a href="#4-5-4-层次路由选择" class="headerlink" title="4.5.4 层次路由选择"></a>4.5.4 层次路由选择</h3><ul><li><p>实践和路由选择算法模型</p><ul><li>规模，当前的因特网上路由器需要巨大容量的内存存储路由选择信息；路由器的LS广播的开销会导致没有剩余的带宽用来发送数据分组，大量路由器中算法将永远无法收敛；</li><li>管理自治，网络需要按照意愿进行管理，还需要和外部其他网络连接；</li></ul></li><li><p>自治系统 Autonomous System AS</p><ul><li><p>每个AS由一组通常处于相同管理控制下的路由器组成</p></li><li><p>相同的AS中的路由器全都运行的同样的路由选择算法（如一种LS或一种DV）,且拥有彼此信息；</p></li><li><p>在一个自治系统内运的路由选择算法：<strong>自治系统内部路由选择协议 intra-autonomous system routing protocol</strong></p></li><li><p>在AS内部有<strong>一台或者多台</strong>路由器 <strong>”网关路由器 gateway router“</strong>，负责向本AS之外的目的地转发分组；</p></li><li><p>源AS只有一台网关路由器，且只有一条通向外部AS的链路时，分组会直接通过该链路传输；</p></li><li><p>自治系统之间的路由选择协议（inter-autonomous system routing protocol），AS间路由选择协议</p><p>BGP4</p><ul><li>从AS间协议知道经过多个网关可达子网x</li><li>使用来自AS内部协议的路由选择信息，以决定到每个网关的 <strong>最低费用路径</strong> 的费用</li><li>热土豆路由选择（hot potato routing），选择具有最低费用的网关</li><li>从转发表确定通向最低费用网关的接口I，将（x，I）项田间道转发表中</li></ul></li></ul></li></ul><h2 id="4-6-因特网中自治系统内部的路由选择：OSPF"><a href="#4-6-因特网中自治系统内部的路由选择：OSPF" class="headerlink" title="4.6 因特网中自治系统内部的路由选择：OSPF"></a>4.6 因特网中自治系统内部的路由选择：OSPF</h2><blockquote><p>一个AS是一个处于相同的管理与技术控制下的路由器集合，在AS之间都运行相同的路由选择协议；每个AS通常又都包含多个子网；</p></blockquote><ul><li><p>OSPF：<strong>开放最短路优先</strong></p></li><li><p>OSPF核心：</p><ul><li>一个使用洪泛链路状态信息的链路状态协议</li><li>一个Dijkstra最低费用路径算法</li><li>使用OSPF，<strong>一台路由器构建了一副关于整个自治系统的完整拓扑图，每台路由器路由器运行Dijkstra最短路径算法，以确定一个以自身为根节点的到所有子网的最短路径数，链路状态信息是由网络管理员配置的；</strong></li><li>OSPF提供机制，为“给定链路权值集合”确定最低费用路劲路由选择</li></ul></li><li><p>原理</p><ul><li>OSPF，路由器向自治系统内所有其他路由器广播路由选择信息；</li><li>当一条链路发生变化，路由器就会广播链路状态信息，当链路状态未发生变化，路由器会周期性的广播链路状态信息（至少每30min）</li><li>OSPF报文，由IP协议承载，上层协议值为<strong>89</strong>，OSPF协议自己实现可靠报文传输、链路状态广播等功能</li><li>OSPF要检查链路正在运行，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库</li></ul></li><li><p>OSPF的优点</p><ul><li><strong>安全</strong>；能够鉴别OSPF路由器之间的交换；使用鉴别，只有受到信任的路由器能参与AS内的OSPF协议；MD5散列值计算；</li><li><strong>多条相同费用的路径</strong>；出现多条相同费用路径时，OSPF允许使用多条路径；</li><li><strong>对单播和多播路由选择的综合支持</strong>；多播：使用现有的OSPF链路数据，为现有的OSPF链路状态广播机制增加了新型的链路状态通告；</li><li><strong>支持在单个路由选择域内的层次结构</strong>；<strong>具有按层次结构构建一个自治系统的能力</strong></li></ul></li></ul><h2 id="4-7-ISP间的路由选择：BGP"><a href="#4-7-ISP间的路由选择：BGP" class="headerlink" title="4.7 ISP间的路由选择：BGP"></a>4.7 ISP间的路由选择：BGP</h2><ul><li><p>OSPF 来决定位于相同AS内部的源和目的之间的路由选择路径；跨越多个AS的源和目的之间的路由选择，<strong>边界网络协议 Border Gateway Protocol, BGP</strong></p></li><li><p>BGP协议是所有因特网协议中最重要的协议，唯一的竞争者就是IP协议，它将数以千计的ISP粘结在一起。</p></li><li><p>工作手段</p><ul><li>从相邻AS处获得子网可达信息</li><li>向本AS内部的所有路由器传播这些可达信息</li><li>基于可达性信息和AS策略，决定到达子网的 “好” 路由</li></ul></li></ul><h3 id="4-7-1-BGP作用"><a href="#4-7-1-BGP作用" class="headerlink" title="4.7.1 BGP作用"></a>4.7.1 BGP作用</h3><p>对于位于AS目的地而言，路由转发表决定，而对于外部，正是由BGP协议发挥作用，提供了以下手段：</p><ol><li><strong>从邻居AS获得前缀的可达性信息</strong></li><li><strong>确定到该前缀的“最好的”路由</strong></li></ol><h3 id="4-7-2-通告BGP路由信息"><a href="#4-7-2-通告BGP路由信息" class="headerlink" title="4.7.2 通告BGP路由信息"></a>4.7.2 通告BGP路由信息</h3><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230308110231533.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230308110231533"></p><p>如图所示，简单的网络具有AS1、AS2、AS3。AS的边缘路由器是网关路由器，如1c</p><ul><li><p>怎么向所有路由器通告x的存在呢？</p></li><li><p>过程：<strong>AS3向AS2发送一个BGP报文，告知x存在且位于AS3中，将该报文表示为AS3 x，然后AS2向AS1发送一个BGP报文，告知x的存在并且先通过AS2到达AS3然后找到x，将该报文表示为AS2 AS3 x，但是有一点细节需要注意，AS之内的BGP报文叫iBGP，AS之间的BGP报文叫eBGP。</strong></p></li></ul><h3 id="4-7-3-确定最好的路由"><a href="#4-7-3-确定最好的路由" class="headerlink" title="4.7.3 确定最好的路由"></a>4.7.3 确定最好的路由</h3><h4 id="热土豆路由器选择"><a href="#热土豆路由器选择" class="headerlink" title="热土豆路由器选择"></a>热土豆路由器选择</h4><ul><li>过程：<strong>对于AS内部的路由器发送分组，考虑的是尽可能快的将分组送出其AS，而不担心AS外部到目的地余下的开销。</strong></li></ul><h4 id="路由器选择算法"><a href="#路由器选择算法" class="headerlink" title="路由器选择算法"></a>路由器选择算法</h4><p>实践中，BGP使用了一种比热土豆更好的算法，如果相同前缀的有两条或者多条路由，则顺序的调用以下消除规则：</p><ol><li><strong>路由被指派一个本地偏好，优先被选择</strong></li><li><strong>选出具有最短AS-PATH的路由，如果该规则是选择的唯一规则，则BGP将使用距离向量算法决定路径，其中距离测度是AS的跳数而不是路由器的跳数</strong></li><li><strong>从余下的路由使用热土豆算法</strong></li><li>如果仍然有多条路由，则使用BGP的标识符来选择路由</li></ol><h3 id="4-7-4-IP任播"><a href="#4-7-4-IP任播" class="headerlink" title="4.7.4 IP任播"></a>4.7.4 IP任播</h3><p>BGP除了被用于选择路由，还被用于IP任播，但是实践中并不用</p><ul><li>过程：<strong>例如在CDN实践中，在路由任播阶段，CDN公司为他的多台服务器指派相同的IP地址，并使用标准的BGP来通告，BGP路由器收到同一个IP的多个路由的时候，理解为相同物理位置不同的路径，因此客户向CDN-IP请求内容的时候，BGP就向最近的服务器转发分组。</strong></li></ul><h1 id="5-链路层和局域网"><a href="#5-链路层和局域网" class="headerlink" title="5.链路层和局域网"></a>5.链路层和局域网</h1><h2 id="5-1概述"><a href="#5-1概述" class="headerlink" title="5.1概述"></a>5.1概述</h2><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-aus-image-20230228154622539.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1"></p><ul><li><p>节点：运行链路层协议的任何设备</p></li><li><p>链路：物理通道</p></li><li><p>数据链路：逻辑通道</p></li><li><p>帧：链路层分组，封装网络层数据报</p></li><li><p>作用：在物理层服务基础上向网络层提供服务，将物理层提供的可能出错的链接改造成一条无差错的链接</p></li><li><p>功能：成帧、链路接入、可靠交付、差错检测和纠错</p></li></ul><h2 id="5-2封装成帧及透明传输"><a href="#5-2封装成帧及透明传输" class="headerlink" title="5.2封装成帧及透明传输"></a>5.2封装成帧及透明传输</h2><h2 id="5-3差错控制及纠正技术"><a href="#5-3差错控制及纠正技术" class="headerlink" title="5.3差错控制及纠正技术"></a>5.3差错控制及纠正技术</h2><ul><li><p>差错：位错、帧错</p></li><li><p>差错控制：检错编码和纠错编码</p><ul><li><p>检错编码：奇偶校验码和循环冗余码CRC</p><ul><li><p>奇偶校验码</p></li><li><p>CRC：<strong>异或计算（同0异1）</strong></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228164052122.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228164052122"></p></li></ul></li><li><p>纠错编码：海明码</p></li></ul></li></ul><h2 id="5-4流量控制与可靠传输机制"><a href="#5-4流量控制与可靠传输机制" class="headerlink" title="5.4流量控制与可靠传输机制"></a>5.4流量控制与可靠传输机制</h2><h2 id="5-5多路访问链路和协议"><a href="#5-5多路访问链路和协议" class="headerlink" title="5.5多路访问链路和协议"></a>5.5多路访问链路和协议</h2><h3 id="5-5-1信道划分协议"><a href="#5-5-1信道划分协议" class="headerlink" title="5.5.1信道划分协议"></a>5.5.1信道划分协议</h3><ul><li><p>TDM时分多路复用</p></li><li><p>FDM频分多路复用</p></li><li><p>CDMA码分多址：类似于时隙和频隙的一种划分方式，仅作了解</p></li></ul><h3 id="5-5-2随机接入协议"><a href="#5-5-2随机接入协议" class="headerlink" title="5.5.2随机接入协议"></a>5.5.2随机接入协议</h3><ul><li><p>时隙ALOHA：ALOHA的改进版，把时间分为相同大小的时间片SLOT，不监听信道、按时间槽发送、随机重发（时间片开始）、想发就发，碰撞概率仍然很大</p></li><li><p>ALOHA：不监听信道、不按时间槽发送、随机重发、想发就发，碰撞概率很大</p></li><li><p>CSMA载波监听：先听再发，几种方式如下：</p><ul><li>1坚持：空闲时可能有多个计算机同时发送，可能导致冲突</li><li>非坚持：如果监听到忙，就放弃监听，等待随机时间后再监听</li><li>p坚持：和1坚持的区别就是发送数据的概率，产生冲突的概率小一点</li></ul></li><li><p>CSMA/CD：碰撞检测，先听再发，边听边发，冲突停发，随机重发。最小帧长的规定。</p><ul><li>如何重发：截断二进制指数退避算法 P300：第一次在{0，1}中等概率选择一个，第二次在{0，1，2，3}中等概率选择一个… …第十次在{0，1，……，1023}中等概率选择一个。</li></ul></li></ul><h3 id="5-5-3轮流协议"><a href="#5-5-3轮流协议" class="headerlink" title="5.5.3轮流协议"></a>5.5.3轮流协议</h3><ul><li>轮询协议</li><li>令牌传递协议<h2 id="5-4交换局域网"><a href="#5-4交换局域网" class="headerlink" title="5.4交换局域网"></a>5.4交换局域网</h2></li></ul><h3 id="5-4-1链路层寻址和ARP"><a href="#5-4-1链路层寻址和ARP" class="headerlink" title="5.4.1链路层寻址和ARP"></a>5.4.1链路层寻址和ARP</h3><ul><li><p>发送数据报到子网以内</p><ul><li>局域网，不使用IP地址寻址，通过链路层地址MAC寻址</li><li>如果ARP表中有对应的项，那么正常发送即可。</li><li><strong>如果ARP表中没有对应IP的MAC地址，那么发送方向他的适配器传输一个ARP查询分组，指示适配器用MAC广播地址将这个分组发送出去，然后局域网中其他设备检查自己的ARP表，将与之匹配的ARP项返回给查询主机，查询主机再进行后续的操作。</strong></li></ul></li><li><p>发送数据报到子网以外</p><ul><li><strong>子网1向子网2发送数据报，子网1中的设备向子网1中的设备查询，子网1中的路由器发现该地址是向它寻址的，因此把这个帧传给路由器的网络层。路由器通过查询转发表将该帧转发到子网2的路由器接口，然后该接口把包传递给他的适配器，再通过查询ARP来查询到MAC地址封装到一个新的帧，最后将帧转发到目的地。</strong></li></ul></li></ul><h3 id="5-4-2以太网"><a href="#5-4-2以太网" class="headerlink" title="5.4.2以太网"></a>5.4.2以太网</h3><p>以太网是目前最流行的有线局域网技术</p><ul><li><p>以太网帧结构</p><ul><li>前同步码|目的地址|源地址|类型|数据| |CRC<ul><li>数据：这个字段承载了IP数据报</li><li>目的地址：包含目的适配器的MAC地址</li><li>源地址：包含了源MAC地址</li></ul></li></ul></li><li><p>以太网技术</p><ul><li><p>以太网向网络层提供不可靠服务：帧没有通过CRC校验时只是舍弃该帧</p></li><li><p>以太网向网络层提供无连接服务：不事先握手</p></li></ul></li></ul><h3 id="5-4-3链路层交换机"><a href="#5-4-3链路层交换机" class="headerlink" title="5.4.3链路层交换机"></a>5.4.3链路层交换机</h3><ul><li><p>交换机转发和过滤</p><ul><li>过滤：决定一个帧是否转发和是否丢弃 </li><li>转发：决定一个帧被导向哪个接口</li><li>交换机的转发和过滤借助于交换机表</li></ul></li><li><p>自学习</p><ul><li><p>交换机表是自动、动态、自治的建立的，即插即用设备</p></li><li><p>交换机表初始为空</p></li><li><p>对于每个接口接收到的入帧，交换机将其存储</p></li><li><p>老化器：一段时间，该地址不活跃，交换机就将其删除</p></li></ul></li><li><p>链路层交换机的性质 p315</p><ul><li>消除碰撞</li><li>异质的链路：交换机将链路隔离，因此局域网中不同的链路能一不一样的速度、介质存在。</li><li>管理：交换机可以为网络管理提供便捷</li></ul></li><li><p>交换机和路由器的比较</p><ul><li><p>交换机基于MAC地址转发（第二层）、路由器基于IP地址转发（第三层），现代交换机两种都有。</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>交换机</td><td>1、即插即用。2、相对高的分组过滤和转发速率。</td><td>为了防止广播帧的循环，交换网络的活跃拓扑严格限制成一棵树，但是交换机对这个没有限制，有可能导致以太网的崩溃。</td></tr><tr><td>路由器</td><td>1、一般分组不会被循环。允许了非常丰富的拓扑结构来构建因特网。2、对第二层的广播风暴构建了防火墙。</td><td>处理时间比交换机更长</td></tr></tbody></table></li></ul></li></ul><h3 id="5-4-4虚拟局域网VLAN"><a href="#5-4-4虚拟局域网VLAN" class="headerlink" title="5.4.4虚拟局域网VLAN"></a>5.4.4虚拟局域网VLAN</h3><p>在一个单一的物理局域网中定义多个虚拟局域网，支持VLAN的交换机的端口被管理员划分为组</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230302151151787.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230302151151787"></p><p>这些端口中的广播流量仅能到达该组中的其他端口</p><ul><li>怎么解决完全隔离带来的组与组之间传递的问题呢：VLAN干线连接</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notebook</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【操作系统】|Linux 命令解释程序设计与实现</title>
    <link href="/2022/06/30/os1/"/>
    <url>/2022/06/30/os1/</url>
    
    <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>探索、理解并掌握操作系统命令解释器的设计原理和实现机制，基于 Linux 内核进行相应命令解释程序的设计和实现，并在 Linux 操作系统平台上加以测试验证。</p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>分析、设计与实现基于 Linux 内核的命令解释程序（Shell），主要包括系统环境变量的设置和初始化、系统命令提示符显示、命令辨别解析（区分内部命令与外部命令及不同内部命令）、典型内部命令（譬如显示指定目录下文件列表、显示文本文件内容、文件拷贝、文件删除、空文件创建、日期设置/显示）处理等功能，并在 Linux 操作系统上测试验证。</p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p><strong>命令的设计与实现</strong></p><p>下面是六条命令的设计与详情：</p><table><thead><tr><th>Table4：命令的设计</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>COMMAND</strong></td><td><strong>TYPE1</strong></td><td><strong>TYPE2</strong></td><td><strong>EFFECT</strong></td></tr><tr><td>cp</td><td>直接调用</td><td>内部命令</td><td>把A文件复制为B文件</td></tr><tr><td>rename</td><td>间接调用</td><td>内部命令</td><td>把文件A重命名为B</td></tr><tr><td>list</td><td>间接调用</td><td>内部命令</td><td>读取目录下文件列表</td></tr><tr><td>rm</td><td>间接调用</td><td>内部命令</td><td>删除文件</td></tr><tr><td>pwd</td><td>间接调用</td><td>内部命令</td><td>打印目前路径</td></tr><tr><td>spath</td><td>直接调用</td><td>外部命令</td><td>显示系统变量</td></tr><tr><td>exit</td><td>无调用</td><td>内部命令</td><td>退出</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>​    采用C语言编写，为了实现相应的功能，头文件引用如下：</p><table><thead><tr><th>Table5：头文件引用</th><th></th></tr></thead><tbody><tr><td><strong>include</strong></td><td><strong>describe</strong></td></tr><tr><td>&lt;stdio.h&gt;</td><td>标准输入输出</td></tr><tr><td>&lt;sys/types.h&gt;</td><td>基本系统数据类型</td></tr><tr><td>&lt;wait.h&gt;</td><td>引用wait</td></tr><tr><td>&lt;stdbool.h&gt;</td><td>c语言引用bool类型</td></tr><tr><td>&lt;sys/syscall.h&gt;</td><td>系统调用头文件</td></tr><tr><td>&lt;string.h&gt;</td><td>字符串操作</td></tr><tr><td>&lt;stdlib.h&gt;</td><td>定义杂项函数及内分配函数</td></tr><tr><td>&lt;stddef.h&gt;</td><td></td></tr><tr><td>&lt;malloc.h&gt;</td><td>动态存储分配函数头文件</td></tr><tr><td>&lt;errno.h&gt;</td><td>定义错误码</td></tr><tr><td>&lt;unistd.h&gt;</td><td>unix 系统标准头文件</td></tr><tr><td>&lt;libgen.h&gt;</td><td>模式匹配函数定义</td></tr><tr><td>&lt;sys/stat.h&gt;</td><td>文件状态</td></tr><tr><td>&lt;fcntl.h&gt;</td><td>文件控制</td></tr><tr><td>&lt;dirent.h&gt;</td><td>目录项</td></tr></tbody></table><p><strong>详细的过程不贴了，把代码贴到最后吧。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libgen.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PWD_size 512</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> command_size 256</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tmp_size 1024</span><br><span class="hljs-comment">// getcwd(buffer, sizeof(buffer));</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_switch</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *command)</span></span>; <span class="hljs-comment">//对命令进行分流的子函数</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_list</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *command2, <span class="hljs-keyword">bool</span> isPwd)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_rename</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_copyFile</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_rm</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">command_systempath</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_pwd</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">char</span> pwd[PWD_size], command[command_size];<br>        getcwd(pwd, <span class="hljs-keyword">sizeof</span>(pwd));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;basher^%s&gt;&quot;</span>, pwd);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, command);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;exit&quot;</span>))<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//对command进行分流处理</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (!command_switch(command))<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;command Error\n&quot;</span>);<br>            fflush(<span class="hljs-built_in">stdin</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Successfully Exit!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_switch</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *command)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;list&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">char</span> command2[command_size];<br>        <span class="hljs-comment">// printf(&quot;当前目录查询请输0,其他目录请输入路径&gt;&quot;);</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, command2);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command2, <span class="hljs-string">&quot;0&quot;</span>)) <span class="hljs-comment">//缓冲区无字符</span><br>        &#123;<br>            <span class="hljs-keyword">char</span> pwd[PWD_size];<br>            getcwd(pwd, <span class="hljs-keyword">sizeof</span>(pwd)); <span class="hljs-comment">//通过当前目录查找</span><br>            command_list(pwd, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            command_list(command2, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;rename&quot;</span>)) <span class="hljs-comment">//修改文件名</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (command_rename())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;cp&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (command_copyFile())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;rm&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (command_rm())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;spath&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (command_systempath())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;pwd&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (command_pwd())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_list</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *command2, <span class="hljs-keyword">bool</span> isPwd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> *<span class="hljs-title">entry</span>;</span><br>    DIR *olist = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    fflush(<span class="hljs-built_in">stdin</span>);<br>    <span class="hljs-keyword">if</span> ((olist = opendir(command2)) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;opendir false!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (entry = readdir(olist))<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">strcmp</span>(entry-&gt;d_name, <span class="hljs-string">&quot;.&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(entry-&gt;d_name, <span class="hljs-string">&quot;..&quot;</span>))) <span class="hljs-comment">// 忽略掉上一目录和这一目录</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, entry-&gt;d_name);<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (closedir(olist) != <span class="hljs-number">0</span> &amp;&amp; !isPwd)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;closedir false!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_rename</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 命令格式 rename 1.txt 2.txt</span><br>    <span class="hljs-keyword">char</span> newname[<span class="hljs-number">30</span>], oldname[<span class="hljs-number">30</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, oldname);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, newname);<br>    fflush(<span class="hljs-built_in">stdin</span>);<br>    <span class="hljs-keyword">if</span> (rename(oldname, newname) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;change the new name false! \n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;change the new name success! \n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_copyFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 输入命令如下格式</span><br>    <span class="hljs-comment">// cp 1.txt 2.txt</span><br>    <span class="hljs-comment">// 直接调用</span><br>    <span class="hljs-keyword">char</span> cp1[<span class="hljs-number">30</span>], cp2[<span class="hljs-number">30</span>], buf[tmp_size];<br>    <span class="hljs-keyword">int</span> fd1, fd2;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, cp1);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, cp2);<br>    fflush(<span class="hljs-built_in">stdin</span>);<br>    <span class="hljs-keyword">if</span> ((fd1 = syscall(SYS_open, cp1, O_RDONLY)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open the file false!&quot;</span>);<br>        flag = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((n = syscall(SYS_read, fd1, buf, tmp_size)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read the first file false! \n&quot;</span>);<br>        flag = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((fd2 = syscall(SYS_creat, cp2, <span class="hljs-number">066</span>)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create the file false!\n&quot;</span>);<br>        flag = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (syscall(SYS_write, fd2, buf, n) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write the second file false!\n&quot;</span>);<br>        flag = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (syscall(SYS_close, fd1) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close the first file false! \n&quot;</span>);<br>        flag = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (syscall(SYS_close, fd2) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close the second file false! \n&quot;</span>);<br>        flag = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;copy the new file success! \n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> !flag;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_rm</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> file_name[<span class="hljs-number">30</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, file_name);<br>    fflush(<span class="hljs-built_in">stdin</span>);<br>    remove(file_name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">command_systempath</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Fork Failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        execlp(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// wait();</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">command_pwd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> pwd[PWD_size];<br>    getcwd(pwd, <span class="hljs-keyword">sizeof</span>(pwd)); <span class="hljs-comment">//通过当前目录查找</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, pwd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编译原理实验】|编译器前端实现（专题 1+专题 5）</title>
    <link href="/2022/06/26/cp6/"/>
    <url>/2022/06/26/cp6/</url>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><blockquote><p>专题 1_词法分析程序设计原理与实现技术<br>专题 2_递归下降语法分析设计原理与实现技术<br>专题 3 LL(1)语法分析设计原理与实现技术<br>专题 4_算符优先语法分析设计原理与实现技术<br>专题 5_基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现技术<br>专题 6 编译器前端实现（专题 1+专题 5）</p></blockquote><h1 id="本次程序实现"><a href="#本次程序实现" class="headerlink" title="本次程序实现"></a>本次程序实现</h1><p><strong>编译器前端与分实验的关系</strong></p><p>将词法分析程序设计原理与实现（专题 1）和基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现（专题 5）形成一个程序，即程序的输入为符号串源程序，输出为中间代码四元式序列。</p><p>在前面的每次实验中，我的程序都是按照相对完整的编译器实验去做的，所以实验六和实验五并无大的改动，只是把繁杂的输出去掉，并且加入了输出四元式为中间文件（mid.txt）的功能，由output函数实现。</p><p>具体实现是：设计了a词法分析类、b语法分析类（语法制导翻译）b类中组合一个a类，这样我的主函数中只需要操作b类即可，如下图。如果后续需要扩展目标代码生成等功能，我只需要再添加一个目标代码生成类，将其组合在我的编译器前端类中即可。</p><p><img src="https://pic.imgdb.cn/item/62b7ea682f25919088bd7b07.jpg"></p><p><img src="https://pic.imgdb.cn/item/62b7ea762f25919088bd8c75.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Principles Of Compliers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编译原理实验】|基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现技术</title>
    <link href="/2022/06/26/cp5/"/>
    <url>/2022/06/26/cp5/</url>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><p>第五次实验是基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现技术，这次实验的主要难点SLR(1)分析表构造与语义制导翻译，这次实验相对是最难的一次实验。</p><blockquote><p>专题 1_词法分析程序设计原理与实现技术<br>专题 2_递归下降语法分析设计原理与实现技术<br>专题 3 LL(1)语法分析设计原理与实现技术<br>专题 4_算符优先语法分析设计原理与实现技术<br>专题 5_基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现技术<br>专题 6 编译器前端实现（专题 1+专题 5）</p></blockquote><h1 id="本次程序介绍"><a href="#本次程序介绍" class="headerlink" title="本次程序介绍"></a>本次程序介绍</h1><p>实验项目</p><p>完成以下描述赋值语句 SLR(1)文法语法制导生成中间代码四元式的过程。</p><p>G[S]:S→V=E</p><p>E→E+T∣E-T∣T</p><p>T→T*F∣T/F∣F</p><p>F→(E)∣i</p><p>V→i</p><p>设计要求</p><p>（1）构造文法的 SLR(1)分析表，设计语法制导翻译过程，给出每一产生式</p><p>对应的语义动作；</p><p>（2）设计中间代码四元式的结构；</p><p>（3）输入串应是词法分析的输出二元式序列，即某赋值语句“专题1”的输出结果，输出为赋值语句的四元式序列中间文件；</p><p>（4）设计两个测试用例（尽可能完备），并给出程序执行结果四元式序列。任务分析：重点解决SLR(1)分析表构造，赋值语句文法的改写和语义动作的添加。</p><h1 id="详细实现"><a href="#详细实现" class="headerlink" title="详细实现"></a>详细实现</h1><h2 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h2><p>可以看到目录结构如下，其中LexicalAnalysis是词法分析器，SLR1是SLR1语法分析器，code.txt是原始代码，LA.txt是词法分析生成的中间代码。GS.txt是文法文件。</p><p><img src="https://pic.imgdb.cn/item/62b7e8f02f25919088bb9375.jpg"></p><p>原始代码code.txt仍旧是以空格分隔字符如下。</p><p><img src="https://pic.imgdb.cn/item/62b7e4092f25919088b5878a.jpg"></p><p>文法的存储如下。是两行一个产生式，第一行是产生式的右部，第二行是产生式的左部。</p><p><img src="https://pic.imgdb.cn/item/62b7e41a2f25919088b59cf1.jpg"></p><h2 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h2><p>LaCode数据结构将词法分析的结果从LA.txt中提取保存出来。</p><p>GsMap存储文法</p><p>FirstSet和LastSet存储First集和Last集。</p><p>FirstSet2是按产生式分割的First集。</p><p>StackAnalyse是OG分析栈。</p><p>table是SLR1分析表（GOTO和Action）。</p><p><img src="C:\Users\aosiw\AppData\Roaming\Typora\typora-user-images\image-20220626130541522.png" alt="image-20220626130541522"></p><h2 id="程序生成的中间数据"><a href="#程序生成的中间数据" class="headerlink" title="程序生成的中间数据"></a>程序生成的中间数据</h2><p>读取到的待检测串、文法和Vt、Vn集。</p><p><img src="https://pic.imgdb.cn/item/62b7e9412f25919088bbfcff.jpg"></p><p>生成的First集和Last集。ImproveFirst是按产生式划分的First集。</p><p><img src="https://pic.imgdb.cn/item/62b7e9522f25919088bc17b9.jpg"></p><p>闭包操作产生有效项目规范族</p><p><img src="https://pic.imgdb.cn/item/62b7e96a2f25919088bc37cc.jpg"></p><p>生成Action Goto表</p><p><img src="https://pic.imgdb.cn/item/62b7e9792f25919088bc4b33.jpg"></p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p><img src="https://pic.imgdb.cn/item/62b7e9902f25919088bc671d.jpg"></p><p>SLR（1）文法是在LR（0）的基础上对于移进归约冲突和归约归约向前看一个符号来处理，造表过程和LR（0）基本一样，先（得到拓广文法）列出所有项目，从开始符号开始，用closure将项目集划分，填写ACTION表和GOTO表。而语法制导生成四元式在SLR（1）分析过程中进行。</p><p>​     通过GetClosure函数CLOSURE(I)构造规范集组。</p><p>getTable函数，构造 SLR语法分析表，其构造方法原理如课本上教的一样：</p><p>​     analyse函数，SLR1分析函数，设立一个三个栈，其中一个状态栈，一个符号栈，一个是用于存放四元式变量的栈，当规约出现V→i时将i压入栈，当出现A→V=E，E→E+T∣E-T，T→T*F∣T/F这几条规则时，newTemp函数产生新的变量，将其根据语义规则生成四元式，然后将对应栈中变量弹出，将新的变量压入栈。</p><h1 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h1><p>本程序的测试代码存在可执行文件同目录下的code.txt中。本程序中输入串每个符号与符号之间需要空格分隔。测试结果中打印函数的SLR1语法分析过程。若错误则会输出Error。</p><p>测试用例1（正确）</p><p><img src="https://pic.imgdb.cn/item/62b7e9a92f25919088bc8a0e.jpg"></p><p>测试结果1</p><p><img src="https://pic.imgdb.cn/item/62b7e9b62f25919088bc9d4f.jpg"></p><p>测试用例2（错误）</p><p><img src="https://pic.imgdb.cn/item/62b7e9c42f25919088bcae9b.jpg"></p><p>测试结果2</p><p><img src="https://pic.imgdb.cn/item/62b7e9d32f25919088bcc0ee.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Principles Of Compliers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编译原理实验】|算符优先语法分析设计原理与实现技术</title>
    <link href="/2022/06/26/cp4/"/>
    <url>/2022/06/26/cp4/</url>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><p>第四次实验是算符优先语法分析设计原理与实现技术，这次实验的主要难点在FirstVt、FollowVt集的构造，这次实验相对第三次较为简单。集合的构造我都是选择规范方法去构造的。</p><blockquote><p>专题 1_词法分析程序设计原理与实现技术<br>专题 2_递归下降语法分析设计原理与实现技术<br>专题 3 LL(1)语法分析设计原理与实现技术<br>专题 4_算符优先语法分析设计原理与实现技术<br>专题 5_基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现技术<br>专题 6 编译器前端实现（专题 1+专题 5）</p></blockquote><h1 id="本次程序介绍"><a href="#本次程序介绍" class="headerlink" title="本次程序介绍"></a>本次程序介绍</h1><p><strong>[实验项目]</strong></p><p>实现算符优先分析算法，完成以下描述算术表达式的算符优先文法的算符优先分析过程。</p><p>G[E]:E→E+T∣E-T∣T</p><p>  T→T*F∣T/F∣F</p><p>  F→(E)∣i</p><p><strong>[实验说明]</strong></p><p>终结符号i 为用户定义的简单变量,即标识符的定义。</p><p><strong>[设计要求]</strong></p><p>（1）构造该算符优先文法的优先关系矩阵或优先函数；</p><p>（2）输入串应是词法分析的输出二元式序列，即某算术表达式“专题 1”的输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果。</p><p>（3）算符优先分析过程应能发现输入串出错。</p><p>（4）设计两个测试用例（尽可能完备，正确和出错），并给出测试结果；</p><p>（5）考虑编写程序根据算符优先文法构造算符优先关系矩阵，并添加到你的算符优先分析程序中。</p><p>能够有效识别以下算符优先文法</p><p>E → E+T | E-T | T</p><p>T → T*F | T/F | F</p><p>F → (E) | i</p><p>所描述算术表达式．</p><h1 id="详细实现"><a href="#详细实现" class="headerlink" title="详细实现"></a>详细实现</h1><h2 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h2><p>可以看到目录结构如下，其中LexicalAnalysis是词法分析器，OG是算符优先语法分析器，code.txt是原始代码，LA.txt是词法分析生成的中间代码。</p><p><img src="https://pic.imgdb.cn/item/62b7e6a12f25919088b8c76c.jpg"></p><p>原始代码code.txt仍旧是以空格分隔字符如下。</p><p><img src="https://pic.imgdb.cn/item/62b7e4092f25919088b5878a.jpg"></p><p>文法的存储如下。是两行一个产生式，第一行是产生式的右部，第二行是产生式的左部。</p><p><img src="https://pic.imgdb.cn/item/62b7e41a2f25919088b59cf1.jpg"></p><h2 id="主要数据结构描述"><a href="#主要数据结构描述" class="headerlink" title="主要数据结构描述"></a>主要数据结构描述</h2><p>LaCodeVector数据结构将词法分析的结果从LA.txt中提取保存出来。</p><p>GsMap存储文法</p><p>FirstVtSet和LastVtSet存储FirstVt集和LastVt集。</p><p>StackAnalyse是OG分析栈。</p><p>OgTable是算符优先分析表。具体的为map的key是一个pair，里面存纵横行的符号，map的值0为=  1为&gt;  2为&lt;  3为空（即error）。</p><p><img src="https://pic.imgdb.cn/item/62b7e6fd2f25919088b935bf.jpg"></p><h2 id="生成中间数据描述"><a href="#生成中间数据描述" class="headerlink" title="生成中间数据描述"></a>生成中间数据描述</h2><p>读取到的待检测串、文法和Vt、Vn集。</p><p><img src="https://pic.imgdb.cn/item/62b7e72c2f25919088b96ed0.jpg"></p><p>生成的FirstVt集和LastVt集</p><p><img src="https://pic.imgdb.cn/item/62b7e73e2f25919088b98455.jpg"></p><p>生成的算符优先分析表</p><p><img src="https://pic.imgdb.cn/item/62b7e74b2f25919088b9959b.jpg"></p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p><img src="https://pic.imgdb.cn/item/62b7e75f2f25919088b9acdb.jpg"></p><h1 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h1><p>本程序的测试代码存在可执行文件同目录下的code.txt中。本程序中输入串每个符号与符号之间需要空格分隔。测试结果中打印函数的算符优先分析过程。若错误则会输出Error。</p><p>测试用例1（正确）</p><p><img src="https://pic.imgdb.cn/item/62b7e7e22f25919088ba4ae7.jpg"></p><p>测试结果1</p><p><img src="https://pic.imgdb.cn/item/62b7e7ed2f25919088ba58c5.jpg"></p><p>测试用例2（错误）</p><p><img src="https://pic.imgdb.cn/item/62b7e7f72f25919088ba64d8.jpg"></p><p>测试结果2</p><p><img src="https://pic.imgdb.cn/item/62b7e8032f25919088ba71da.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Principles Of Compliers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编译原理实验】|LL(1)语法分析设计原理与实现技术</title>
    <link href="/2022/06/26/cp3/"/>
    <url>/2022/06/26/cp3/</url>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><p>第三次实验是LL(1)语法分析设计原理与实现技术，这次实验的主要难点在First、Follow集的构造，而且由于我最初并未按照单个产生式去构造First集，导致比较麻烦。</p><blockquote><p>专题 1_词法分析程序设计原理与实现技术<br>专题 2_递归下降语法分析设计原理与实现技术<br>专题 3 LL(1)语法分析设计原理与实现技术<br>专题 4_算符优先语法分析设计原理与实现技术<br>专题 5_基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现技术<br>专题 6 编译器前端实现（专题 1+专题 5）</p></blockquote><h1 id="本次程序介绍"><a href="#本次程序介绍" class="headerlink" title="本次程序介绍"></a>本次程序介绍</h1><p>[实验项目] 实现 LL(1)分析中控制程序（表驱动程序）；完成以下描述赋值语句的 LL(1) 文法的 LL(1)分析过程。 </p><p>G[S]:S→V=E</p><p>E→TE′      </p><p>E′→ATE′|ε      </p><p>T→FT′      </p><p>T′→MFT′|ε      </p><p>F→ (E)|i      </p><p>A→+|-      </p><p>M→*|/      </p><p>V→i</p><p><strong>[设计说明]</strong> 终结符号 i 为用户定义的简单变量,即标识符的定义。 </p><p>**[设计要求]**（1）输入串应是词法分析的输出二元式序列，即某算术表达式“专题 1”的 输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果；（ 2）LL(1)分析过程 应能发现输入串出错；（ 3）设计两个测试用例（尽可能完备，正确和出错），并给出测试结 果；（ 4）考虑根据 LL(1)文法编写程序构造 LL（1）分析表，并添加到你的 LL（1）分析程序 中。 【也要考虑First集、Follow集的构造与LL1分析表的构造】</p><p><strong>[任务分析]</strong> 重点 LL（1）分析方法和 LL(1)分析器的实现。</p><p>-提供了文件输入方式，且输入的内容为二元式序列；</p><p>-能够对输入的字符串做出正确的LL(1)分析判断，并给出判断结果，判断结果输出到文件，也显示在屏幕；</p><p>-能发现输入串中的错误，包含非法字符，输入不匹配等；</p><p>-能够处理一些可预见性的错误，如文件不存在，输入非法等。</p><p><strong>[单词符号表]</strong></p><table><thead><tr><th><strong>单词符号</strong></th><th><strong>种别码</strong></th></tr></thead><tbody><tr><td>（</td><td>1</td></tr><tr><td>）</td><td>2</td></tr><tr><td>+</td><td>3</td></tr><tr><td>-</td><td>4</td></tr><tr><td>*</td><td>5</td></tr><tr><td>/</td><td>6</td></tr><tr><td>i</td><td>7</td></tr><tr><td>#</td><td>8</td></tr></tbody></table><h1 id="详细实现"><a href="#详细实现" class="headerlink" title="详细实现"></a>详细实现</h1><h2 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述"></a>文件描述</h2><p>本次实验采用面向对象的程序设计，沿用之前的LA类（词法分析）。可以看到目录结构如下，其中LexicalAnalysis是词法分析器LA类的实现，LL1是LL(1)语法分析LL1类的实现，code.txt是原始代码，LA.txt是词法分析生成的中间代码，GS.txt是储存的文法。</p><p><img src="https://pic.imgdb.cn/item/62b7e3fb2f25919088b5738e.jpg"></p><p>原始代码code.txt仍旧是以空格分隔字符如下。</p><p><img src="https://pic.imgdb.cn/item/62b7e4092f25919088b5878a.jpg"></p><p>文法的存储如下。是两行一个产生式，第一行是产生式的右部，第二行是产生式的左部。</p><p><img src="https://pic.imgdb.cn/item/62b7e41a2f25919088b59cf1.jpg"></p><h2 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h2><p>LaCodeVector数据结构将词法分析的结果从LA.txt中提取保存出来。</p><p>GsMap存储文法</p><p>FirstSet和FollowSet存储First集和Follow集。</p><p>FirstSet2存储按产生式构成的First集（这个是由于前期设计失误用来弥补的措施）</p><p>StackAnalyse是LL1分析栈。</p><p><img src="https://pic.imgdb.cn/item/62b7e4332f25919088b5bcf6.jpg"></p><h2 id="程序结构描述"><a href="#程序结构描述" class="headerlink" title="程序结构描述"></a>程序结构描述</h2><p><img src="https://pic.imgdb.cn/item/62b7e45a2f25919088b5f13b.jpg"></p><h2 id="生成的中间数据"><a href="#生成的中间数据" class="headerlink" title="生成的中间数据"></a>生成的中间数据</h2><p>读取的待检测串、Gs文法、Vn、Vt集。</p><p><img src="https://pic.imgdb.cn/item/62b7e48a2f25919088b630d2.jpg"></p><p>生成的First集和按产生式划分的First集。</p><p><img src="https://pic.imgdb.cn/item/62b7e4992f25919088b64543.jpg"></p><p>生成的Follow集</p><p><img src="https://pic.imgdb.cn/item/62b7e4b12f25919088b663af.jpg"></p><p>生成的LL1分析表。</p><p><img src="https://pic.imgdb.cn/item/62b7e4c82f25919088b67ec6.jpg"></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>本程序的测试代码存在可执行文件同目录下的code.txt中。本程序中输入串每个符号与符号之间需要空格分隔。结果中会分别展示几种中间数据以及LL1分析过程与结果。若错误则会输出Error。（几种集合和表格的截图上面有，下面就不多余附了）</p><p>测试用例1（正确）</p><p><img src="https://pic.imgdb.cn/item/62b7e4ee2f25919088b6ab7c.jpg"></p><p>测试结果1</p><p><img src="https://pic.imgdb.cn/item/62b7e4fb2f25919088b6bce9.jpg"></p><p>测试用例2</p><p><img src="https://pic.imgdb.cn/item/62b7e50f2f25919088b6d6bc.jpg"></p><p>测试结果2</p><p><img src="https://pic.imgdb.cn/item/62b7e5232f25919088b6ece3.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Principles Of Compliers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编译原理实验】|递归下降语法分析设计原理与实现技术</title>
    <link href="/2022/06/25/cp2/"/>
    <url>/2022/06/25/cp2/</url>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><p>第二次实验是递归下降语法分析设计原理与实现技术，这个实验和第一次一样，相对来说比较容易</p><blockquote><p>专题 1_词法分析程序设计原理与实现技术<br>专题 2_递归下降语法分析设计原理与实现技术<br>专题 3_LL(1)语法分析设计原理与实现技术<br>专题 4_算符优先语法分析设计原理与实现技术<br>专题 5_基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现技术<br>专题 6_编译器前端实现（专题 1+专题 5）</p></blockquote><h1 id="本次程序介绍"><a href="#本次程序介绍" class="headerlink" title="本次程序介绍"></a>本次程序介绍</h1><p>在专题二中我没有特别去写First、Follow集的构造。我把这部分构造在专题三中（以及后续专题）实现了。</p><p>实现递归下降分析法的功能。词法分析器的功能是利用函数之间的递归调用模拟语法树自上而下的构造过程。</p><p>递归下降分析法的前提是改造文法：</p><p>消除二义性、消除左递归、提取左因子，判断是否为 LL（1）文法。</p><p>这个实验规定了单词种类表，如下：</p><table><thead><tr><th><strong>单词符号</strong></th><th><strong>种别码</strong></th></tr></thead><tbody><tr><td>（</td><td>1</td></tr><tr><td>）</td><td>2</td></tr><tr><td>+</td><td>3</td></tr><tr><td>-</td><td>4</td></tr><tr><td>*</td><td>5</td></tr><tr><td>/</td><td>6</td></tr><tr><td>i</td><td>7</td></tr><tr><td>#</td><td>8</td></tr></tbody></table><h1 id="详细实现"><a href="#详细实现" class="headerlink" title="详细实现"></a>详细实现</h1><h2 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h2><p>本次实验对实验1稍作修改，改为了面向对象程序设计，组合模式将词法分析器组合在递归下降分析器中，提高了后面代码的可复用性。可以看到目录结构如下，其中LexicalAnalysis是词法分析器，RDP是递归下降语法分析器，code.txt是原始代码，RDP.txt是词法分析生成的中间代码。</p><p><img src="https://pic.imgdb.cn/item/62b7dbdb2f25919088ac0954.jpg"></p><h2 id="主要数据结构描述"><a href="#主要数据结构描述" class="headerlink" title="主要数据结构描述"></a>主要数据结构描述</h2><p>以下数据结构将词法分析的结果从RDP.txt中提取保存出来。</p><p><img src="https://pic.imgdb.cn/item/62b7dc032f25919088ac3634.jpg"></p><p>由于是递归下降分析，所以也不需要其他的数据结构来辅助了。</p><h2 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h2><p><img src="C:\Users\aosiw\AppData\Roaming\Typora\typora-user-images\image-20220626121017642.png" alt="image-20220626121017642"></p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p>该程序严格按照每条产生式编写即可，子函数的流程图如PPT上所示的一样。在这里不在缀图了。</p><p><img src="https://pic.imgdb.cn/item/62b7dc4b2f25919088ac8917.jpg"></p><h1 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h1><p>本程序的测试代码存在可执行文件同目录下的code.txt中。本程序中输入串每个符号与符号之间需要空格分隔。测试结果中把函数的递归顺序倒序输出了用来观察。若错误则会输出RDP Error。</p><p>测试用例1（正确）</p><p><img src="https://pic.imgdb.cn/item/62b7dc662f25919088aca649.jpg"></p><p>测试结果1</p><p><img src="https://pic.imgdb.cn/item/62b7dc712f25919088acb15c.jpg"></p><p>测试用例2</p><p><img src="C:\Users\aosiw\AppData\Roaming\Typora\typora-user-images\image-20220626121144948.png" alt="image-20220626121144948"></p><p>测试结果2</p><p><img src="https://pic.imgdb.cn/item/62b7dc8b2f25919088acd0ef.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Principles Of Compliers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编译原理实验】|词法分析程序设计原理与实现技术</title>
    <link href="/2022/06/25/cp1/"/>
    <url>/2022/06/25/cp1/</url>
    
    <content type="html"><![CDATA[<h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><p>这学期的作业很多也很硬，直到期末彻底结束才来把报告挪到这里，编译原理实验中还有很多的疏漏，但是实验要求都已经悉数完成，主要的时间还是花在了各种构造表及构造表的前置数据的构造中，最终的六个实验代码都发在github中。</p><blockquote><p>专题 1_词法分析程序设计原理与实现技术<br>专题 2_递归下降语法分析设计原理与实现技术<br>专题 3_LL(1)语法分析设计原理与实现技术<br>专题 4_算符优先语法分析设计原理与实现技术<br>专题 5_基于 SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现技术<br>专题 6_编译器前端实现（专题 1+专题 5）</p></blockquote><h1 id="本次程序介绍"><a href="#本次程序介绍" class="headerlink" title="本次程序介绍"></a>本次程序介绍</h1><p>程序功能如下：</p><blockquote><p>正则文法：</p><p>&lt;标识符&gt;→字母︱ &lt;标识符&gt;字母︱ &lt;标识符&gt;数字</p><p>&lt;无符号整数&gt;→数字︱ &lt;无符号整数&gt;数字</p><p>&lt;单字符分界符&gt; →+ ︱－ ︱* ︱；︱, ︱(︱) ︱{︱}︱[︱]</p><p>&lt;双字符分界符&gt;→&lt;大于&gt;=︱&lt;小于&gt;=︱&lt;小于&gt;&gt;︱&lt;逻辑非&gt;=︱&lt;等于&gt;=︱&lt;斜竖&gt;*</p><p>&lt;小于&gt;→&lt;</p><p>&lt;等于&gt;→=</p><p>&lt;大于&gt;→&gt;</p><p>&lt;斜竖&gt; →/</p><p>&lt;逻辑非&gt;→!</p><p>&lt;保留字&gt; → Main︱If︱else︱int︱return︱void︱while</p><p>输入：字符串形式的源程序。</p><p>输出：具有独立意义的单词符号。</p></blockquote><h1 id="详细实现"><a href="#详细实现" class="headerlink" title="详细实现"></a>详细实现</h1><!--也许并不详细--><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>以下数据结构将分离出来的字符存放起来。</p><p><img src="https://pic.imgdb.cn/item/62b70ab30947543129a8a54b.jpg"></p><p>以下数据结构将识别出来分割好的有序的字符存放起来，ResultVector是将二元式按输入顺序保存了起来。</p><p><img src="https://pic.imgdb.cn/item/62b70ad80947543129a8de13.jpg"></p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p><img src="https://pic.imgdb.cn/item/62b70b8c0947543129a9df4c.jpg"></p><h2 id="单词类别表"><a href="#单词类别表" class="headerlink" title="单词类别表"></a>单词类别表</h2><p>这里单词类别看起来限制的很死，但是我在程序中预留的位置实际上是可以非常容易的更改的。</p><table><thead><tr><th><strong>序号</strong></th><th><strong>符号</strong></th><th><strong>类别号</strong></th></tr></thead><tbody><tr><td><strong>1</strong></td><td><strong>=</strong></td><td><strong>1</strong></td></tr><tr><td><strong>2</strong></td><td><strong>+</strong></td><td><strong>2</strong></td></tr><tr><td><strong>3</strong></td><td><strong>_</strong></td><td><strong>3</strong></td></tr><tr><td><strong>4</strong></td><td>*****</td><td><strong>4</strong></td></tr><tr><td><strong>5</strong></td><td><strong>/</strong></td><td><strong>5</strong></td></tr><tr><td><strong>6</strong></td><td><strong>&lt;</strong></td><td><strong>6</strong></td></tr><tr><td><strong>7</strong></td><td><strong>&gt;</strong></td><td><strong>7</strong></td></tr><tr><td><strong>8</strong></td><td><strong>!</strong></td><td><strong>8</strong></td></tr><tr><td><strong>9</strong></td><td><strong>；</strong></td><td><strong>9</strong></td></tr><tr><td><strong>10</strong></td><td><strong>：</strong></td><td><strong>10</strong></td></tr><tr><td><strong>11</strong></td><td><strong>，</strong></td><td><strong>11</strong></td></tr><tr><td><strong>12</strong></td><td><strong>{</strong></td><td><strong>12</strong></td></tr><tr><td><strong>13</strong></td><td><strong>}</strong></td><td><strong>13</strong></td></tr><tr><td><strong>14</strong></td><td><strong>[</strong></td><td><strong>14</strong></td></tr><tr><td><strong>15</strong></td><td><strong>]</strong></td><td><strong>15</strong></td></tr><tr><td><strong>16</strong></td><td><strong>（</strong></td><td><strong>16</strong></td></tr><tr><td><strong>17</strong></td><td><strong>）</strong></td><td><strong>17</strong></td></tr><tr><td><strong>18</strong></td><td><strong>&lt;=</strong></td><td><strong>18</strong></td></tr><tr><td><strong>19</strong></td><td><strong>&gt;=</strong></td><td><strong>19</strong></td></tr><tr><td><strong>20</strong></td><td><strong>==</strong></td><td><strong>20</strong></td></tr><tr><td><strong>21</strong></td><td><strong>!=</strong></td><td><strong>21</strong></td></tr><tr><td><strong>22</strong></td><td><strong>main</strong></td><td><strong>22</strong></td></tr><tr><td><strong>23</strong></td><td><strong>int</strong></td><td><strong>23</strong></td></tr><tr><td><strong>24</strong></td><td><strong>if</strong></td><td><strong>24</strong></td></tr><tr><td><strong>25</strong></td><td><strong>else</strong></td><td><strong>25</strong></td></tr><tr><td><strong>26</strong></td><td><strong>return</strong></td><td><strong>26</strong></td></tr><tr><td><strong>27</strong></td><td><strong>void</strong></td><td><strong>27</strong></td></tr><tr><td><strong>28</strong></td><td><strong>while</strong></td><td><strong>28</strong></td></tr><tr><td><strong>29</strong></td><td><strong>标识符</strong></td><td><strong>29</strong></td></tr><tr><td><strong>30</strong></td><td><strong>整数</strong></td><td><strong>30</strong></td></tr></tbody></table><h2 id="DFM图"><a href="#DFM图" class="headerlink" title="DFM图"></a>DFM图</h2><p><img src="https://pic.imgdb.cn/item/62b70c0a0947543129aa95a9.jpg"></p><h1 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h1><p>本程序的测试代码存在可执行文件同目录下的*<strong>code.txt*</strong>中。本程序中输入串每个符号与符号之间需要空格分隔。</p><p>测试用例1</p><p><img src="https://pic.imgdb.cn/item/62b70c560947543129ab01b5.jpg"></p><p>测试结果1</p><p><img src="https://pic.imgdb.cn/item/62b70c660947543129ab19dd.jpg"></p><p>测试用例2</p><p><img src="https://pic.imgdb.cn/item/62b70c7a0947543129ab35f6.jpg"></p><p>测试结果2</p><p><img src="https://pic.imgdb.cn/item/62b70c880947543129ab48a7.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Principles Of Compliers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载|计算机网络原理自顶向下第七版中文答案（不要看）</title>
    <link href="/2022/02/28/cn-top-down-method-answers-in-chinese/"/>
    <url>/2022/02/28/cn-top-down-method-answers-in-chinese/</url>
    
    <content type="html"><![CDATA[<p>仅供自己使用~~~</p><p>怕原文无了，在这里线上保存一份方便自己查看。</p><div class="row">    <embed src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/pdf/cn_top_down_method_answers_in_chinese.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>实践|小黑盒的签到autojs脚本</title>
    <link href="/2022/02/03/xhh-autojs/"/>
    <url>/2022/02/03/xhh-autojs/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>三个任务，分享、点赞、转发都写了，基于无障碍做的，不需要截图权限。项目地址还是autojs脚本的地址（见github）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 小嘿盒</span><br><span class="hljs-keyword">let</span> msg = id(<span class="hljs-string">&quot;iv_home_msg&quot;</span>).findOnce;<br><br><span class="hljs-built_in">console</span>.show();<span class="hljs-comment">//Set console</span><br><span class="hljs-comment">// 设备信息</span><br><span class="hljs-keyword">var</span> WIDTH = device.width,<br>    HEIGHT = device.height,<br>    TYPE = device.brand + <span class="hljs-string">&#x27; &#x27;</span> + device.model;<br><br><span class="hljs-built_in">console</span>.clear;<br><br>log(<span class="hljs-string">&#x27;\n分辨率：&#x27;</span>, WIDTH, <span class="hljs-string">&#x27;*&#x27;</span>, HEIGHT);<br><br><span class="hljs-keyword">let</span> StartServer = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 判断服务是否开启</span><br><br><span class="hljs-keyword">while</span> (StartServer) &#123;<br>    <span class="hljs-keyword">if</span> (!id(<span class="hljs-string">&quot;iv_home_msg&quot;</span>).findOnce()) &#123;<br>        log(<span class="hljs-string">&quot;不在小嘿盒主页，请手动打开&quot;</span>);<br>        <span class="hljs-comment">// 不在小黑盒主页跳过</span><br>        sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 等待1s</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> title = className(<span class="hljs-string">&quot;androidx.recyclerview.widget.RecyclerView&quot;</span>).findOne();<br>        <span class="hljs-comment">// 执行share任务</span><br>        log(<span class="hljs-string">&quot;执行share任务...&quot;</span>);<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<br><br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Tv = title.child(i);<br>            Tv.click();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (error) &#123;<br>            sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>        sleep(<span class="hljs-number">500</span>);<br>        log(<span class="hljs-string">&quot;准备分享&quot;</span>);<br>        <span class="hljs-comment">// 稍微判断一手</span><br>        <span class="hljs-keyword">while</span> (!id(<span class="hljs-string">&quot;iv_appbar_action_button&quot;</span>).findOne()) &#123;<br>            log(<span class="hljs-string">&quot;没找到&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> b = id(<span class="hljs-string">&quot;button_right&quot;</span>).findOne().bounds();<br>        <span class="hljs-keyword">let</span> count_tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!text(<span class="hljs-string">&quot;微信好友&quot;</span>).findOnce()) &#123;<br>            click(b.centerX(), b.centerY());<span class="hljs-comment">//再点一次</span><br>            <span class="hljs-keyword">if</span> (count_tmp++ &gt; <span class="hljs-number">500</span>) &#123;<br>                log(<span class="hljs-string">&quot;share error&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            sleep(<span class="hljs-number">500</span>);<br>            <span class="hljs-keyword">if</span> (count_tmp &gt;= <span class="hljs-number">1</span>) log(<span class="hljs-string">&quot;click another!&quot;</span>);<br>        &#125;<br>        sleep(<span class="hljs-number">2500</span>);<br>        text(<span class="hljs-string">&quot;微信好友&quot;</span>).findOne().parent().click();<br>        sleep(<span class="hljs-number">1500</span>);<br><br>        <span class="hljs-keyword">while</span> (!back()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        log(<span class="hljs-string">&quot;分享成功&quot;</span>);<br>        sleep(<span class="hljs-number">1500</span>);<br>        <span class="hljs-keyword">while</span> (!back()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        sleep(<span class="hljs-number">1000</span>);<br><br><br><br>        <span class="hljs-comment">// 执行点赞任务</span><br>        log(<span class="hljs-string">&quot;执行点赞任务&quot;</span>);<br>        <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Tv = title.child(i);<br>                Tv.click();<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (error) &#123;<br>                sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>            sleep(<span class="hljs-number">1500</span>);<br>            <span class="hljs-comment">//log(&quot;准备点赞&quot;);</span><br>            <span class="hljs-comment">//let d = id(&quot;img&quot;).findOne().bounds();</span><br>            <span class="hljs-comment">//click(d.centerX(), d.centerY());</span><br>            click(<span class="hljs-number">0.8157</span> * WIDTH, <span class="hljs-number">0.9653</span> * HEIGHT);<br>            log(<span class="hljs-string">&quot;点赞数：&quot;</span>, i);<br>            sleep(<span class="hljs-number">1500</span>);<br>            <span class="hljs-keyword">while</span> (!back()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sleep(<span class="hljs-number">1500</span>);<br>            <span class="hljs-comment">//title.scrollUp();</span><br>            <span class="hljs-comment">// 滑动</span><br>            swipe(WIDTH / <span class="hljs-number">2</span>, HEIGHT / <span class="hljs-number">2</span>, WIDTH / <span class="hljs-number">2</span>, HEIGHT / <span class="hljs-number">2</span> - <span class="hljs-number">250</span>, <span class="hljs-number">200</span>);<br>        &#125;<br>        log(<span class="hljs-string">&quot;还有个小bug，只能点四个赞~~~~~还有一个就得自己点了~~~&quot;</span>);<br>    &#125;<br>    log(<span class="hljs-string">&quot;结束&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>autojs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践|Auto.js8基于屏幕识别的vx抢红包脚本</title>
    <link href="/2022/01/30/GrapAllOfRedPackets/"/>
    <url>/2022/01/30/GrapAllOfRedPackets/</url>
    
    <content type="html"><![CDATA[<h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><p>Android：<a href="https://pan.baidu.com/s/1VHe4vDVIH9nC7wgKCpdm1A?pwd=hhhh">download</a></p><h1 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h1><h2 id="Dependent-On"><a href="#Dependent-On" class="headerlink" title="Dependent On"></a>Dependent On</h2><ol><li>Accessibility Service</li><li>screenshot permissions</li></ol>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|集成学习Adaboost决策树的原理和代码实现</title>
    <link href="/2022/01/28/adaboost/"/>
    <url>/2022/01/28/adaboost/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>Adaboost是一种集成学习(Ensemble)思想的算法。在之前，没有一种方法可以使得弱分类器有效的变为强分类器，后面集成学习的出现解决了这一问题，可以使得弱分类器变为强分类器。集成学习主要可以分为两个方法：Sequential Method和Parallel Method，其中Sequential Method中最为基础的代表便是Adaboost。该算法的核心思想如下图。</p><p><img src="https://pic.imgdb.cn/item/61f3f0e92ab3f51d91332834.jpg"></p><p>Adaboost相比于原始决策树具有以下优势：</p><ol><li><p>Adaboost是一种精度非常高的分类器；</p></li><li><p>可以与各种方法构建子分类器，Adaboost算法提供一种计算框架；</p></li><li><p>弱分类器的构造方法比较简单；</p></li><li><p>算法易于理解，不用做特征筛选；</p></li><li><p>不易发生过拟合；</p></li><li><p>易于编码（和奥卡姆剃刀有悖）。</p></li></ol><p>Adaboost算法伪代码如下：</p><p><img src="https://pic.imgdb.cn/item/61f3f1032ab3f51d913346db.jpg"></p><p><strong><del>writage过期了，所以word转公式特别麻烦QAQ。。就直接用图片啦，不知道有一天图床崩了会引起什么反应</del></strong></p><p><strong>后面我又用latex输了</strong></p><p>balabala 不想贴了，不过这里补一个报告pdf</p><p>我们这里讲解Adaboost是如何解决上一节这4个问题的。</p><p>假设我们的训练集样本是</p><p>$$<br>T={(x,y1),(x2,y2),…(xm,ym)}<br>$$<br>训练集的在第k个弱学习器的输出权重为<br>$$<br>D(k)=(wk1,wk2,…wkm);w1i=1m;i=1,2…m<br>$$<br>Adaboost的误差率和其他分类误差率相似，由于多元分类是二元分类的推广，在这里假设是二元分类问题，输出为{-1，1}，则第k个弱分类器Learner k的加权误差率为：<br>$$<br>e_k = P(G_k(x_i) \neq y_i) = \sum\limits_{i=1}^{m}w_{ki}I(G_k(x_i) \neq y_i)<br>$$<br>Adaboost的第k个分类器的权重系数为：<br>$$<br>\alpha_k = \frac{1}{2}log\frac{1-e_k}{e_k}<br>$$<br>从误差率公式和权重系数公式可以看出分离误差率越大,ak越小。假设第k个弱分类器的样本集权重系数为<br>$$<br>D(k) = (w_{k1}, w_{k2}, …w_{km})<br>$$<br>需要得到第k+1个权重系数，对应第k+1个权重系数为：<br>$$<br>w_{k+1,i} = \frac{w_{ki}}{Z_K}exp(-\alpha_ky_iG_k(x_i))<br>$$<br>上式的规范化因子的计算的计算如下：<br>$$<br>Z_k = \sum\limits_{i=1}^{m}w_{ki}exp(-\alpha_ky_iG_k(x_i))<br>$$<br>如图中所示，多个弱学习器还需要一个集合函数将他们合成一个，Adaboost采用的是加权表示法，最终的强分类器为：<br>$$<br>f(x) = sign(\sum\limits_{k=1}^{K}\alpha_kG_k(x))<br>$$<br>分类Adaboost的弱学习器权重系数公式和样本权重更新公式的确定，和从Adaboost的损失函数有关，Adaboost是模型为加法模型，学习算法为前向分步学习算法，损失函数为指数函数的分类问题。加法模型是指最终的强分类器是若干个弱分类器加权平均而得到的，前向分步学习算法是通过一轮轮的弱学习器学习，利用前一个强学习器的结果和当前弱学习器来更新当前的强学习器的模型。第k-1轮的强学习器为：<br>$$<br>f_{k-1}(x) = \sum\limits_{i=1}^{k-1}\alpha_iG_{i}(x)<br>$$<br>而第k轮的强学习器为：<br>$$<br>f_{k}(x) = \sum\limits_{i=1}^{k}\alpha_iG_{i}(x)<br>$$<br>上两式一比较可以得到<br>$$<br>f_{k}(x) = f_{k-1}(x) + \alpha_kG_k(x)<br>$$<br>可见强学习器的确是通过前向分步学习算法一步步而得到的。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAdaBoost</span>(<span class="hljs-params">BaseEstimator,ClassifierMixin</span>):</span><br>   <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,weak_clf=<span class="hljs-literal">None</span>,n_estimator=<span class="hljs-number">50</span></span>):</span><br>        self._clfs=[] <span class="hljs-comment"># 弱分类器的列表</span><br>        self._clf_weight=[] <span class="hljs-comment"># 权重列表</span><br>        self._weak_clf=weak_clf <span class="hljs-comment"># 弱学习器选择</span><br>        self._n_estimator=n_estimator <span class="hljs-comment"># 最大基学习器数量</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_para_ts</span>(<span class="hljs-params">self, deep = <span class="hljs-literal">False</span></span>):</span>  <br>        <span class="hljs-keyword">return</span>&#123;  <br>            <span class="hljs-string">&quot;weak_clf&quot;</span>: self._weak_clf,  <br>            <span class="hljs-string">&quot;n_estimator&quot;</span>: self._n_estimator,  <br>        &#125;  <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>):</span>  <br>        self._clfs.clear()  <br>        self._clf_weight.clear()<br>  <br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, X, y</span>):</span><br>        self.clear()<br><br>        n=<span class="hljs-built_in">len</span>(X)<br>        <span class="hljs-comment"># 计算第一个权重</span><br>        <span class="hljs-comment"># 此后的权重通过计算迭代的得到，见权重计算公式</span><br>        avg_weight=np.ones(n) / n<br>      <br>        <span class="hljs-comment"># 基学习器的最大数量self.n_estimator为迭代次数       </span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._n_estimator):<br>            <br>            <span class="hljs-comment"># 使用弱分类器的fit方法训练弱分类器</span><br>            self._weak_clf=self._weak_clf.fit(X, y,sample_weight=np.array(avg_weight))<br>            <br>            <span class="hljs-comment"># 调用弱分类器的predict方法进行预测</span><br>            y_pred=self._weak_clf.predict(X)<br>            <br>            <span class="hljs-comment"># 计算加权错误率e_k</span><br>            <span class="hljs-comment"># 公式如上文e_k的计算，这里考虑到数值的稳定性</span><br>            eps = <span class="hljs-number">1e-12</span>  <br>            e_k = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>((y_pred != y).dot(avg_weight[:, <span class="hljs-literal">None</span>])[<span class="hljs-number">0</span>], eps), <span class="hljs-number">1</span> - eps)<br>            <br>            <span class="hljs-comment"># 计算该弱分类器的权重a_t</span><br>            <span class="hljs-comment"># 在公式中反映为 1/2*log&#123;(1-e_k)/e_k&#125;</span><br>            a_t=<span class="hljs-number">0.5</span> * np.log((<span class="hljs-number">1</span> - e_k) / (e_k))  <br>            <br>            <span class="hljs-comment"># 更新样本权重</span><br>            <span class="hljs-comment">#通过第k+1个权重公式得到</span><br>            avg_weight *= np.exp(-a_t * y* y_pred)<br>            avg_weight /= np.<span class="hljs-built_in">sum</span>(avg_weight)<br>            <br>            <span class="hljs-comment"># 记录分类器和权重</span><br>            self._clf_weight.append(a_t)<br>            self._clfs.append(deepcopy(self._weak_clf))<br>        <span class="hljs-keyword">return</span> self<br>            <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self,x</span>):</span><br>        result=np.zeros(<span class="hljs-built_in">len</span>(x))<br>        <br>        <span class="hljs-comment"># 集合函数</span><br>        <span class="hljs-comment"># 按权重求和</span><br>        <span class="hljs-keyword">for</span> clf, a_t <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self._clfs, self._clf_weight):<br>            result += a_t * clf.predict(x) <br>        <span class="hljs-comment"># 将结果化为1 0 -1</span><br>        result-=<span class="hljs-number">0.5</span><br>        prediction = np.sign(result)<br>        prediction[prediction == -<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> prediction<br><br><span class="hljs-comment"># 检测Adaboost的树深从8-12的代码</span><br><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_val_predict<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>,<span class="hljs-number">13</span>):<br>    clf=DecisionTreeClassifier(max_depth=i)<span class="hljs-comment"># 最大深度</span><br>    AdaBoostClf=MyAdaBoost(weak_clf=clf)<br>    AdaBoostClf.fit(dota2x,dota2y)<br>    prediction1=AdaBoostClf.predict(dota2x)<br>    <span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error<br>    <span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br>    print(i,<span class="hljs-string">&quot;:&quot;</span>,mean_absolute_error(dota2y,prediction1),mean_squared_error(dota2y,prediction1))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|MySQL数据库压力测试</title>
    <link href="/2022/01/27/mysqlAssginment-8/"/>
    <url>/2022/01/27/mysqlAssginment-8/</url>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><ol><li><p> 结合作业3，针对你的数据库中的一个表，编写简单的数据查询（查询语句应包括单个涉及非主属性等值比较的查询条件，设该非主属性为A，具体属性结合业务背景）和数据插入语句，程序应能在终端或服务器以文件形式记录每次数据读写操作的耗时。<strong>作业三就是之前的设计的微信群聊天业务，也是<a href="http://www.auswitz.top/2022/01/26/mysqlAssignment/">大作业</a></strong></p></li><li><p>无索引压力测试实验：设定该表的数据插入频率（如100条/秒），至少有1台以上终端以并发的形式插入数据，运行一段时间使数据达到百万条级以上，数据规模上限自定。同时使用1台终端每秒并发执行一次查询操作，要求查询条件不包含主码，且不存在针对属性A建立的非聚集索引。</p></li><li><p>有索引压力测试：清空原有数据，实验内容同上，但除主键索引外，需要针对属性A建立非聚集索引，重新执行一轮压力测试。</p></li><li><p>选做：加大数据插入与查询频率，观察你的服务器和不同设计方案的压力承受能力。注意控制规模以免导致硬盘工作空间溢出。</p></li><li><p>分析实验数据，制作图表，观察同一方案插入时间与查询时间变化，分析实验结果原因。</p></li><li><p>分析实验数据，制作图表，比较相同资源条件下不同方案同一指标随时间的变化，分析实验结果原因。</p></li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我选择的业务模型是微信聊天群模型。插入表是对聊天记录表进行插入，如图一。group_message_ID这列设置自增，ID这列是用来设置有无索引的对照列，用python生成10000-99999之间的随机int来插入ID，message列是使用<a href="https://pan.baidu.com/s/1K5iuaIJfVxTLCz6i8tu_8w?pwd=hhhh">50W中文聊天语句数据集</a>。mess_time是插入时间。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>大部分东西在<a href="https://pan.baidu.com/s/1GQBy5MapA3KMTJ7LT3uFjg?pwd=hhhh">报告</a>里</p><p><img src="https://pic.imgdb.cn/item/61f2ab4f2ab3f51d91fbd6a2.png"><br><img src="https://pic.imgdb.cn/item/61f2ab4f2ab3f51d91fbd6a7.png"></p><p><img src="https://pic.imgdb.cn/item/61f2b0012ab3f51d9101cf4f.png"><br><img src="https://pic.imgdb.cn/item/61f2b0022ab3f51d9101cf56.png"><br><img src="https://pic.imgdb.cn/item/61f2b0022ab3f51d9101cfa9.png"><br><img src="https://pic.imgdb.cn/item/61f2b0022ab3f51d9101d0ee.png"></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|数据库大作业小记</title>
    <link href="/2022/01/26/mysqlAssignment/"/>
    <url>/2022/01/26/mysqlAssignment/</url>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这学期的大作业是自学一点点前端知识，做一个能和数据库耦合良好的系统，可以从十几个个系统中选一个想做的，我选的是//微信聊天群聊天系统//。<strong>把程序的文档也都附上。</strong></p><p><a href="https://github.com/aosiweixin/vechat">项目地址</a></p><p><a href="https://pan.baidu.com/s/1SW4c-Py0bTNOHQpSUmxU4g?pwd=hhhh">提取码hhhh</a></p><h1 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h1><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>系统主要功能如下：</p><ol><li>账户功能</li></ol><p>用户可以自行注册账户，注销账户，修改密码，修改账户信息，以实现对自己的账户进行管理。</p><ol start="2"><li>群聊功能</li></ol><p>用户可以通过设计好的系统，查看自己所在的群聊，选择自己想要聊天的群聊进行聊天。聊天群中可以看到发消息的群成员是谁，以及清除群聊界面的消息。</p><p>群聊界面中，还可以对该群的群成员进行查看，以及对本人信息进行查看。</p><ol start="3"><li>系统管理员功能</li></ol><p>系统管理员可以创建新群聊，可以将用户拉入群聊中，也可以对群聊信息，群主，群聊成员进行增删改查。</p><h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><ol><li>前端功能</li></ol><p>前端通过UI设计与简单的页面交互，实现了系统的面向用户部分的功能，主要是分为以下模块：面向普通用户的登陆、注册、注销、修改密码模块；面向普通用户的群聊查看、群聊选择、用户信息查看、群聊模块；面向超级管理员用户的增加删除群聊，群成员添加，群主的修改，群成员的删除模块。</p><ol start="2"><li>Web服务端</li></ol><p>Web服务端主要是服务于用户和数据库系统的中间功能，主要分为以下两个模块：服务于数据库与前端之间的连接模块，主要需要实现相关设计；服务于端与端之间的socket模块，需要实现用户之间的通信。</p><ol start="3"><li>数据库端</li></ol><p>数据库端是对用户的聊天信息的存取，用户信息的存储，管理员信息的存取等需要使用到数据库存储的场景。</p><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>前端通过UI设计与简单的页面交互，实现了系统的面向用户部分的功能，主要是分为以下模块：面向普通用户的登陆、注册、注销、修改密码模块；面向普通用户的群聊查看、群聊选择、用户信息查看、群聊模块；面向超级管理员用户的增加删除群聊，群成员添加，群主的修改，群成员的删除模块。</p><p><strong>QAQ假装插入了图片.jpg</strong></p><h2 id="数据库部分设计"><a href="#数据库部分设计" class="headerlink" title="数据库部分设计"></a>数据库部分设计</h2><p><img src="https://pic.imgdb.cn/item/61f1351a2ab3f51d91a6b005.jpg"></p><p>用到的表不止这四个，但是精简系统之后，实现功能只需要这四个。</p><ol><li>视图</li></ol><p>设计了用于通过ID检索用户名的Search_User视图（行列子视图）。可以提高shujuku系统的安全性。</p><ol start="2"><li>索引</li></ol><p>每张表的主键都是聚集索引；非聚集索引使用在消息表的ID列，由于ID在这里要经常查询，所以在这里使用非聚集索引提高查询效率。</p><ol start="3"><li>存储过程</li></ol><p>用户的注册使用了存储过程，通过一个存储过程代替注册语句。</p><ol start="4"><li>并发控制</li></ol><p>消息的增加和消息数的增添过程使用了事务操作，利用mysql8.0以上版本特性进行自动并发控制。</p><h2 id="安全体系设计"><a href="#安全体系设计" class="headerlink" title="安全体系设计"></a>安全体系设计</h2><ol><li>用户口令管理</li></ol><p>系统采用MD5加盐加密的算法，MD5将整个文件当做一个大文本信息，通过不可逆的字符串变换算法，产生一个唯一的MD5信息摘要，就像每个人都有自己独一无二的指纹,MD5对任何文件产生一个独一无二的数字指纹。“盐”就是一串比较复杂的字符串。加盐的目的是加强加密的复杂度，这么破解起来就更加麻烦，当然这个“盐”越长越复杂，加密后破解起来就越麻烦。</p><ol start="2"><li>存储与恢复</li></ol><p>主要分为两部分：开启日志记录，通过通用操作日志，对数据库的变化进行监控，通过日志，遇到错误时可以回滚；人为可以在一定时间对数据库进行全备份。</p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lc276场周赛</title>
    <link href="/2022/01/16/leetcode1/"/>
    <url>/2022/01/16/leetcode1/</url>
    
    <content type="html"><![CDATA[<h3 id="5980-将字符串拆分为若干长度为-k-的组"><a href="#5980-将字符串拆分为若干长度为-k-的组" class="headerlink" title="5980. 将字符串拆分为若干长度为 k 的组"></a>5980. 将字符串拆分为若干长度为 k 的组</h3><p>字符串 <code>s</code> 可以按下述步骤划分为若干长度为 <code>k</code> 的组：</p><ul><li>第一组由字符串中的前 <code>k</code> 个字符组成，第二组由接下来的 <code>k</code> 个字符串组成，依此类推。每个字符都能够成为 <strong>某一个</strong> 组的一部分。</li><li>对于最后一组，如果字符串剩下的字符 <strong>不足</strong> <code>k</code> 个，需使用字符 <code>fill</code> 来补全这一组字符。</li></ul><p>注意，在去除最后一个组的填充字符 <code>fill</code>（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 <code>s</code> 。</p><p>给你一个字符串 <code>s</code> ，以及每组的长度 <code>k</code> 和一个用于填充的字符 <code>fill</code> ，按上述步骤处理之后，返回一个字符串数组，该数组表示 <code>s</code> 分组后 <strong>每个组的组成情况</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcdefghi&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">fill</span> = <span class="hljs-string">&quot;x&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>]<br>解释：<br>前 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;abc&quot;</span> ，形成第一组。<br>接下来 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;def&quot;</span> ，形成第二组。<br>最后 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;ghi&quot;</span> ，形成第三组。<br>由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。<br>因此，形成 <span class="hljs-number">3</span> 组，分别是 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span> 和 <span class="hljs-string">&quot;ghi&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：s = <span class="hljs-string">&quot;abcdefghij&quot;</span>, k = <span class="hljs-number">3</span>, <span class="hljs-built_in">fill</span> = <span class="hljs-string">&quot;x&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-string">&quot;jxx&quot;</span>]<br>解释：<br>与前一个例子类似，形成前三组 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span> 和 <span class="hljs-string">&quot;ghi&quot;</span> 。<br>对于最后一组，字符串中仅剩下字符 <span class="hljs-string">&#x27;j&#x27;</span> 可以用。为了补全这一组，使用填充字符 <span class="hljs-string">&#x27;x&#x27;</span> 两次。<br>因此，形成 <span class="hljs-number">4</span> 组，分别是 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span>、<span class="hljs-string">&quot;ghi&quot;</span> 和 <span class="hljs-string">&quot;jxx&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅由小写英文字母组成</li><li><code>1 &lt;= k &lt;= 100</code></li><li><code>fill</code> 是一个小写英文字母</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divideString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span>, fill: <span class="hljs-built_in">str</span></span>) -&gt; List[str]:</span><br>        li = []<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(s) / k)<br>        tmp = <span class="hljs-built_in">len</span>(s) % k<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> tmp):<br>            n = n + <span class="hljs-number">1</span><br>        x = <span class="hljs-number">0</span><br>        isok = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">int</span>(i)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(s[x:x + k]) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> isok == <span class="hljs-literal">True</span>):<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(s[x:x + k]) &lt; k):<br>                xtmp = <span class="hljs-built_in">len</span>(s[x:x + k])<br>                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                    s = s + fill<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(s[x:x + k]) &gt;= k):<br>                        li.append(s[x:x + k])<br>                        isok = <span class="hljs-literal">True</span><br>                        <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> (isok):<br>                <span class="hljs-keyword">break</span><br>            li.append(s[x:x + k])<br>            x = x + k<br>        <span class="hljs-keyword">return</span> li<br></code></pre></td></tr></table></figure><h3 id="5194-得到目标值的最少行动次数"><a href="#5194-得到目标值的最少行动次数" class="headerlink" title="5194. 得到目标值的最少行动次数"></a>5194. 得到目标值的最少行动次数</h3><p>你正在玩一个整数游戏。从整数 <code>1</code> 开始，期望得到整数 <code>target</code> 。</p><p>在一次行动中，你可以做下述两种操作之一：</p><ul><li><strong>递增</strong>，将当前整数的值加 1（即， <code>x = x + 1</code>）。</li><li><strong>加倍</strong>，使当前整数的值翻倍（即，<code>x = 2 * x</code>）。</li></ul><p>在整个游戏过程中，你可以使用 <strong>递增</strong> 操作 <strong>任意</strong> 次数。但是只能使用 <strong>加倍</strong> 操作 <strong>至多</strong> <code>maxDoubles</code> 次。</p><p>给你两个整数 <code>target</code> 和 <code>maxDoubles</code> ，返回从 1 开始得到 <code>target</code> 需要的最少行动次数。</p><p><strong>示例 1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">5</span>, maxDoubles = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br>解释：一直递增 <span class="hljs-number">1</span> 直到得到 <span class="hljs-keyword">target</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：target = 19, maxDoubles = 2<br>输出：7<br>解释：最初，x =<span class="hljs-number"> 1 </span>。<br>递增<span class="hljs-number"> 3 </span>次，x =<span class="hljs-number"> 4 </span>。<br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 8 </span>。<br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 9 </span>。<br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 18 </span>。<br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 19 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：target = 10, maxDoubles = 4<br>输出：4<br>解释：<br>最初，x =<span class="hljs-number"> 1 </span>。 <br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 2 </span>。 <br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 4 </span>。 <br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 5 </span>。 <br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 10 </span>。 <br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>0 &lt;= maxDoubles &lt;= 100</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minMoves</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, maxDoubles: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-comment"># 贪心</span><br>        <span class="hljs-comment"># n = 1</span><br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> (maxDoubles != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> target % <span class="hljs-number">2</span>):<br>                maxDoubles = maxDoubles - <span class="hljs-number">1</span><br>                target = target / <span class="hljs-number">2</span><br>                count = count + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> (target == <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(count)<br>            <span class="hljs-keyword">elif</span> (target % <span class="hljs-number">2</span>):<br>                target = target - <span class="hljs-number">1</span><br>                count = count + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> (maxDoubles == <span class="hljs-number">0</span>):<br>                count = count + target<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(count) - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="5982-解决智力问题"><a href="#5982-解决智力问题" class="headerlink" title="5982. 解决智力问题"></a>5982. 解决智力问题</h3><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>questions</code> ，其中 <code>questions[i] = [pointsi, brainpoweri]</code> 。</p><p>这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong> （也就是从问题 <code>0</code> 开始依次解决），针对每个问题选择 <strong>解决</strong> 或者 <strong>跳过</strong> 操作。解决问题 <code>i</code> 将让你 <strong>获得</strong> <code>pointsi</code> 的分数，但是你将 <strong>无法</strong> 解决接下来的 <code>brainpoweri</code> 个问题（即只能跳过接下来的 <code>brainpoweri</code> 个问题）。如果你跳过问题 <code>i</code> ，你可以对下一个问题决定使用哪种操作。</p><ul><li><p>比方说，给你 </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">questions = <span class="hljs-comment">[<span class="hljs-comment">[3, 2]</span>, <span class="hljs-comment">[4, 3]</span>, <span class="hljs-comment">[4, 4]</span>, <span class="hljs-comment">[2, 5]</span>]</span><br></code></pre></td></tr></table></figure><p> ：</p><ul><li>如果问题 <code>0</code> 被解决了， 那么你可以获得 <code>3</code> 分，但你不能解决问题 <code>1</code> 和 <code>2</code> 。</li><li>如果你跳过问题 <code>0</code> ，且解决问题 <code>1</code> ，你将获得 <code>4</code> 分但是不能解决问题 <code>2</code> 和 <code>3</code> 。</li></ul></li></ul><p>请你返回这场考试里你能获得的 <strong>最高</strong> 分数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：questions = [[3,2],[4,3],[4,4],[2,5]]<br>输出：5<br>解释：解决问题<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>得到最高分。<br>- 解决问题<span class="hljs-number"> 0 </span>：获得<span class="hljs-number"> 3 </span>分，但接下来<span class="hljs-number"> 2 </span>个问题都不能解决。<br>- 不能解决问题<span class="hljs-number"> 1 </span>和 2<br>- 解决问题<span class="hljs-number"> 3 </span>：获得<span class="hljs-number"> 2 </span>分<br>总得分为：3 +<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 5 </span>。没有别的办法获得<span class="hljs-number"> 5 </span>分或者多于<span class="hljs-number"> 5 </span>分。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]<br>输出：7<br>解释：解决问题<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 4 </span>得到最高分。<br>- 跳过问题 0<br>- 解决问题<span class="hljs-number"> 1 </span>：获得<span class="hljs-number"> 2 </span>分，但接下来<span class="hljs-number"> 2 </span>个问题都不能解决。<br>- 不能解决问题<span class="hljs-number"> 2 </span>和 3<br>- 解决问题<span class="hljs-number"> 4 </span>：获得<span class="hljs-number"> 5 </span>分<br>总得分为：2 +<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 7 </span>。没有别的办法获得<span class="hljs-number"> 7 </span>分或者多于<span class="hljs-number"> 7 </span>分。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= questions.length &lt;= 105</code></li><li><code>questions[i].length == 2</code></li><li><code>1 &lt;= pointsi, brainpoweri &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">mostPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; questions)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = questions.size();<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dp[i + <span class="hljs-number">1</span>] = max(dp[i], dp[i + <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">int</span> nxt = min(i + <span class="hljs-number">1</span> + questions[i][<span class="hljs-number">1</span>], n);<br>            dp[nxt] = max(dp[nxt], dp[i] + questions[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5983-同时运行-N-台电脑的最长时间"><a href="#5983-同时运行-N-台电脑的最长时间" class="headerlink" title="5983. 同时运行 N 台电脑的最长时间"></a>5983. 同时运行 N 台电脑的最长时间</h3><p>你有 <code>n</code> 台电脑。给你整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的整数数组 <code>batteries</code> ，其中第 <code>i</code> 个电池可以让一台电脑 <strong>运行</strong> <code>batteries[i]</code> 分钟。你想使用这些电池让 <strong>全部</strong> <code>n</code> 台电脑 <strong>同时</strong> 运行。</p><p>一开始，你可以给每台电脑连接 <strong>至多一个电池</strong> 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 <strong>任意次</strong> 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p><p>注意，你不能给电池充电。</p><p>请你返回你可以让 <code>n</code> 台电脑同时运行的 <strong>最长</strong> 分钟数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, batteries = [3,3,3]<br>输出：4<br>解释：<br>一开始，将第一台电脑与电池<span class="hljs-number"> 0 </span>连接，第二台电脑与电池<span class="hljs-number"> 1 </span>连接。<br>2 分钟后，将第二台电脑与电池<span class="hljs-number"> 1 </span>断开连接，并连接电池<span class="hljs-number"> 2 </span>。注意，电池<span class="hljs-number"> 0 </span>还可以供电<span class="hljs-number"> 1 </span>分钟。<br>在第<span class="hljs-number"> 3 </span>分钟结尾，你需要将第一台电脑与电池<span class="hljs-number"> 0 </span>断开连接，然后连接电池<span class="hljs-number"> 1 </span>。<br>在第<span class="hljs-number"> 4 </span>分钟结尾，电池<span class="hljs-number"> 1 </span>也被耗尽，第一台电脑无法继续运行。<br>我们最多能同时让两台电脑同时运行<span class="hljs-number"> 4 </span>分钟，所以我们返回<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/01/06/example2.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, batteries = [1,1,1,1]<br>输出：2<br>解释：<br>一开始，将第一台电脑与电池<span class="hljs-number"> 0 </span>连接，第二台电脑与电池<span class="hljs-number"> 2 </span>连接。<br>一分钟后，电池<span class="hljs-number"> 0 </span>和电池<span class="hljs-number"> 2 </span>同时耗尽，所以你需要将它们断开连接，并将电池<span class="hljs-number"> 1 </span>和第一台电脑连接，电池<span class="hljs-number"> 3 </span>和第二台电脑连接。<br>1 分钟后，电池<span class="hljs-number"> 1 </span>和电池<span class="hljs-number"> 3 </span>也耗尽了，所以两台电脑都无法继续运行。<br>我们最多能让两台电脑同时运行<span class="hljs-number"> 2 </span>分钟，所以我们返回<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= batteries.length &lt;= 105</code></li><li><code>1 &lt;= batteries[i] &lt;= 109</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>对方拍一拍你|在有限的时空里，过无限广大的日子</title>
    <link href="/2022/01/15/pic0113/"/>
    <url>/2022/01/15/pic0113/</url>
    
    <content type="html"><![CDATA[<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220126/_DSC3968.jpg?imageMogr4/format/webp"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220126/_DSC3977.jpg?imageMogr4/format/webp"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>对方拍一拍你|年年皆胜意，岁岁皆欢愉</title>
    <link href="/2022/01/01/pic-newyear/"/>
    <url>/2022/01/01/pic-newyear/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3786.jpg?imageMogr2/format/webp"></th></tr></thead><tbody><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3795.jpg?imageMogr3/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3801.jpg?imageMogr4/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3856.jpg?imageMogr5/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3872.jpg?imageMogr6/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3880.jpg?imageMogr7/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3894.jpg?imageMogr8/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3912.jpg?imageMogr9/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20220101/_DSC3935.JPG?imageMogr10/format/webp"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>对方拍一拍你</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|算法课OJ作业（全）</title>
    <link href="/2021/12/27/algorithm/"/>
    <url>/2021/12/27/algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="Problem-A-课堂作业-6-1"><a href="#Problem-A-课堂作业-6-1" class="headerlink" title="Problem A. 课堂作业-6-1"></a>Problem A. 课堂作业-6-1</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如果一个质数能被表示为三个不同的质数的和的形式，那么我们称它为立方质数。现在给你一个数n，判断它是不是立方质数。</p><h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>正整数n，n&lt;=1000</p><h4 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h4><p>Yes或者No</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">19<br></code></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure><p>比较容易的一道枚举题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//两个较小数另外处理</span><br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">2</span> || num == <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//不在6的倍数两侧的一定不是质数</span><br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">6</span> != <span class="hljs-number">1</span> &amp;&amp; num % <span class="hljs-number">6</span> != <span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">sqrt</span>(num);<br>    <span class="hljs-comment">//在6的倍数两侧的也可能不是质数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>; i &lt;= tmp; i += <span class="hljs-number">6</span>)<br>        <span class="hljs-keyword">if</span> (num % i == <span class="hljs-number">0</span> || num % (i + <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//排除所有，剩余的是质数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, a[<span class="hljs-number">168</span>], prime_n[<span class="hljs-number">168</span>];<br>    <span class="hljs-keyword">bool</span> IscuP = <span class="hljs-literal">false</span>, NIsCup = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">17</span>)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (!IsPrime(n))<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>            NIsCup = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (IsPrime(i))<br>                a[k++] = i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!NIsCup)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">168</span>; i++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">169</span>; j++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> ((a[i] + a[j]) &gt; n)<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">169</span>; k++)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (((a[i] + a[j] + a[k]) &gt; <span class="hljs-number">1000</span>) || ((a[i] + a[j] + a[k]) &gt; n))<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">if</span> ((a[i] + a[j] + a[k]) == n)<br>                        &#123;<br>                            <span class="hljs-comment">//cout &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; a[j] &lt;&lt; &quot; &quot; &lt;&lt; a[k] &lt;&lt; endl;</span><br>                            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>                            IscuP = <span class="hljs-literal">true</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (IscuP)<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (IscuP)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        <span class="hljs-keyword">if</span> (!IscuP &amp;&amp; !NIsCup)<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="Problem-B-课堂作业-6-2"><a href="#Problem-B-课堂作业-6-2" class="headerlink" title="Problem B. 课堂作业-6-2"></a>Problem B. 课堂作业-6-2</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们有n根的木棍。现在从这些木棍中切割出来m条长度相同的木棍，问这m根木棍最长有多长？</p><h4 id="输入数据-1"><a href="#输入数据-1" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行输入两个数字，n(1&lt;=n&lt;=1000)为木棍数目，m(1&lt;=m&lt;=1000)为需要切割出的相同长度的木棍数目 随后n个正整数，表示原始木棍的长度(&lt;=10000)</p><h4 id="输出数据-1"><a href="#输出数据-1" class="headerlink" title="输出数据"></a>输出数据</h4><p>每组输出一行结果，表示切割后绳子的最长长度(保留两位小数)</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>.<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">double</span> max;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == <span class="hljs-number">0</span>)<br>            max = a[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max &lt; a[i])<br>        &#123;<br>            max = a[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">0</span>, r = max;<br>    <span class="hljs-keyword">double</span> mid;<br>    <span class="hljs-keyword">while</span> (l + <span class="hljs-number">0.01</span> &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        mid = round(((l + r) / <span class="hljs-number">2.00</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100.00</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            num += (<span class="hljs-keyword">double</span>)(a[i] / mid);<br>        <span class="hljs-keyword">if</span> (num &gt;= m)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>, l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="Problem-C-课堂作业-6-3"><a href="#Problem-C-课堂作业-6-3" class="headerlink" title="Problem C. 课堂作业-6-3"></a>Problem C. 课堂作业-6-3</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>李老师的lucky number 是3，5和7，他爱屋及乌，还把所有质因数只有3，5，7的数字认定为lucky number，比如9, 15, 21, 25等等。请聪明的你帮忙算一算小于等于x的lucky number有多少个？</p><h4 id="输入数据-2"><a href="#输入数据-2" class="headerlink" title="输入数据"></a>输入数据</h4><p>一个正整数x，3=&lt;x&lt;=1000000000000</p><h4 id="输出数据-2"><a href="#输出数据-2" class="headerlink" title="输出数据"></a>输出数据</h4><p>小于等于x的lucky number的个数。</p><h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">49<br></code></pre></td></tr></table></figure><h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">11<br></code></pre></td></tr></table></figure><h4 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h4><p>int存不下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> llt;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    llt x, num = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>    llt n[<span class="hljs-number">10010</span>] = &#123;<span class="hljs-number">1</span>&#125;, n3, n5, n7;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        n3 = n[a] * <span class="hljs-number">3</span>;<br>        n5 = n[b] * <span class="hljs-number">5</span>;<br>        n7 = n[c] * <span class="hljs-number">7</span>;<br>        llt Min = min(min(n3, n5), n7);<br>        <span class="hljs-keyword">if</span> (Min == n3)<br>            a++;<br>        <span class="hljs-keyword">if</span> (Min == n5)<br>            b++;<br>        <span class="hljs-keyword">if</span> (Min == n7)<br>            c++;<br>        <span class="hljs-keyword">if</span> (Min &gt; x)<br>            <span class="hljs-keyword">break</span>;<br>        num++;<br>        n[num] = Min;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; num;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="Problem-D-思维之花-简单背包"><a href="#Problem-D-思维之花-简单背包" class="headerlink" title="Problem D. 思维之花-简单背包"></a>Problem D. 思维之花-简单背包</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>李老师正准备暑假旅行，他有一个容量为L的行李箱和n个物品（n不超过20），每个物品都有自己的体积，物品可以放入行李箱，但行李箱中物品的总体积不能超过行李箱容量，李老师现在想知道他有多少种携带物品的方案（一个物品都不带也算一种方案）</p><h4 id="输入数据-3"><a href="#输入数据-3" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行为两个正整数n和L，分别代表物品总数和行李箱容量，n&lt;=20，L&lt;=1e9 接下来一行为n个正整数vi，代表第i个物品的体积，vi&lt;=1e8</p><h4 id="输出数据-3"><a href="#输出数据-3" class="headerlink" title="输出数据"></a>输出数据</h4><p>方案数</p><h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">7<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>, n;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> L, n_v[<span class="hljs-number">21</span>];<br>;<br><span class="hljs-comment">//该轮循环总物品体积，第几轮递归，</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> times)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (times == n) <span class="hljs-comment">//如果次数没到最后一次</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (v &lt;= L) <span class="hljs-comment">//总物品体积小于这个容积</span><br>            num++;  <span class="hljs-comment">//次数+1</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    calculate(v, times + <span class="hljs-number">1</span>);<br>    calculate(v + n_v[times], times + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; L; <span class="hljs-comment">//物品总数和行李箱容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n_v[i]; <span class="hljs-comment">//物品的体积</span><br>    <span class="hljs-comment">//求方案数</span><br>    calculate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; num;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="Problem-E-课堂作业-7-2"><a href="#Problem-E-课堂作业-7-2" class="headerlink" title="Problem E. 课堂作业-7-2"></a>Problem E. 课堂作业-7-2</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一条河，河中间有一些石头，已知石头的数量和相邻两块石头之间的距离。现在可以移除一些石头，问最多移除m块石头后（首尾两块石头不可以移除），相邻两块石头之间的距离的最小值最大是多少。</p><h4 id="输入数据-4"><a href="#输入数据-4" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行输入两个数字，n（2&lt;=n&lt;=1000）为石头的个数，m（0&lt;=m&lt;=n-2）为可移除的石头数目 随后n-1个数字，表示顺序和相邻两块石头的距离d（d&lt;=1000）</p><h4 id="输出数据-4"><a href="#输出数据-4" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出最小距离的最大值</p><h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> a[MAXN], tmp[MAXN];<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> middle)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> rockNum = <span class="hljs-number">0</span>;             <br>    <span class="hljs-keyword">int</span> st = <span class="hljs-number">1</span>;                  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (tmp[i] - tmp[st] &lt; middle) <br>            rockNum++;<br>        <span class="hljs-keyword">else</span><br>            st = i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rockNum &gt; m) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a[i];                <br>        tmp[i] = a[i] + tmp[i - <span class="hljs-number">1</span>]; <br>    &#125;<br>    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> + <span class="hljs-number">5</span>; <br>    <span class="hljs-keyword">while</span> (high - low &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> middle = (low + high) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (solve(middle))<br>            low = middle;<br>        <span class="hljs-keyword">else</span><br>            high = middle; <br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; low;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="Problem-F-课堂作业-7-3"><a href="#Problem-F-课堂作业-7-3" class="headerlink" title="Problem F. 课堂作业-7-3"></a>Problem F. 课堂作业-7-3</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个长度为n的数组和一个正整数k，问从数组中任选两个数使其和是k的倍数，有多少种选法<br>对于数组a1=1 , a2=2 , a3=2而言：<br>(a1,a2)和(a2,a1)被认为是同一种选法；<br>(a1,a2)和(a1,a3)被认为是不同的选法。</p><h4 id="输入数据-5"><a href="#输入数据-5" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行有两个正整数n，k。n&lt;=1000000，k&lt;=1000000 第二行有n个正整数，每个数的大小不超过1e9</p><h4 id="输出数据-5"><a href="#输出数据-5" class="headerlink" title="输出数据"></a>输出数据</h4><p>选出一对数使其和是k的倍数的选法个数</p><h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><h4 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h4><p>样例解释：<br>a1+a5=6，a2+a4=6，都是6的倍数<br>所以符合条件的选法有（1，5），（2，4）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> llt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n, k;<br>llt count = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br><span class="hljs-keyword">int</span>*b,x;<br>b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1000010</span>]();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>b[x % k] ++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>&#123;<br><span class="hljs-keyword">int</span> j = (k - i) % k;<br><span class="hljs-keyword">if</span> (j &lt; i)<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (i == j)count += (llt)b[i] * (b[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <br><span class="hljs-keyword">else</span><br>count += (llt)b[i] * b[j]; <br>&#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;count;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><h3 id="Problem-A-集合划分"><a href="#Problem-A-集合划分" class="headerlink" title="Problem A. 集合划分"></a>Problem A. 集合划分</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>n个元素的集合{1,2,…, n }可以划分为若干个非空子集。例如，当n=4 时，集合{1，2，3，4}可以划分为15 个不同的非空子集如下：<br>略，md会报错<br>给定正整数n，计算出n 个元素的集合{1,2,…, n }可以划分为多少个不同的非空子集。</p><h4 id="输入数据-6"><a href="#输入数据-6" class="headerlink" title="输入数据"></a>输入数据</h4><p>多组输入(&lt;=10组数据，读入以EOF结尾) 每组一行输入一个数字，n(0&lt;n&lt;=18)</p><h4 id="输出数据-6"><a href="#输出数据-6" class="headerlink" title="输出数据"></a>输出数据</h4><p>每组输出一行结果。</p><h4 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><h4 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">15<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//设n个元素的集合可以划分为F(n, m) 个不同的由m个非空子集组成的集合。</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAllSubset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == m)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getAllSubset(n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>) + getAllSubset(n - <span class="hljs-number">1</span>, m) * m;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF)<br>    &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            count += getAllSubset(n, i);<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><h3 id="Problem-B-二叉树的后序遍历"><a href="#Problem-B-二叉树的后序遍历" class="headerlink" title="Problem B. 二叉树的后序遍历"></a>Problem B. 二叉树的后序遍历</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个二叉树，按照后序遍历的顺序输出这棵树。</p><h4 id="输入数据-7"><a href="#输入数据-7" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行一个整数 n (1≤n≤1e4) ，表示这棵树的节点数。 接下来有 n-1 行，每行有两个整数 u,v ，表示节点 u 到节点 v 有一条边，输入保证树以 1 为根，且 u 为 v 的父节点。对于一个节点的多个子节点，将更早输入的那一个子节点的视为他的左子节点。</p><h4 id="输出数据-7"><a href="#输出数据-7" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出该树的后序遍历，节点编号之间用一个空格分隔。</p><h4 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例说明-2"><a href="#样例说明-2" class="headerlink" title="样例说明"></a>样例说明</h4><p>后序遍历的定义是：对访问的每个树，先访问他的左子树，然后访问他的右子树，最后访问根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 10010</span><br><span class="hljs-keyword">int</span> n, a[MaxSize][<span class="hljs-number">2</span>];;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">post_order</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">bool</span> isdata = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i][<span class="hljs-number">0</span>] == x)<br>&#123;<br>post_order(a[i][<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (i++; i &lt; n - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i][<span class="hljs-number">0</span>] == x)post_order(a[i][<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<span class="hljs-comment">//6 1 2 2 3 3 4 1 5 5 6</span><br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][<span class="hljs-number">1</span>]);<br>&#125;<br>post_order(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><h3 id="Problem-C-整数的幂次方表示"><a href="#Problem-C-整数的幂次方表示" class="headerlink" title="Problem C. 整数的幂次方表示"></a>Problem C. 整数的幂次方表示</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p><img src="http://algo.bjtu.edu.cn/user-content/3/image/Cg20nUD2UVQiIeNujNqBC6KAj1nEHhcFtCy5MB0c.png" alt="img"></p><h4 id="输入数据-8"><a href="#输入数据-8" class="headerlink" title="输入数据"></a>输入数据</h4><p>一行一个正整数n(1&lt;=n&lt;=20000)</p><h4 id="输出数据-8"><a href="#输出数据-8" class="headerlink" title="输出数据"></a>输出数据</h4><p>符合约定的 n 的 0,2表示（在表示中不能有空格）。</p><h4 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1315</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>))+<span class="hljs-number">2</span>)+<span class="hljs-number">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>)))+<span class="hljs-number">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>)+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>))+<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"><span class="hljs-comment">//m为被分解的数，n为二进制位数，r为位数上的数值。</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> r;<br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<span class="hljs-comment">//m 已经被分解完，返回</span><br><span class="hljs-keyword">return</span>;<br>r = m % <span class="hljs-number">2</span>;<br>m = m / <span class="hljs-number">2</span>;<br>cal(m, n + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (m != <span class="hljs-number">0</span> &amp;&amp; r != <span class="hljs-number">0</span>)<br><span class="hljs-comment">//如果m不为0且r不为0证明这不是第一个2的幂次方，输出+</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2(0)&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2(2)&quot;</span>);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2(&quot;</span>);<br>cal(n, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//如果指数不能用2(0),2,2(2)表示则继续分解</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>cal(num, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><h3 id="Problem-D-最近点对"><a href="#Problem-D-最近点对" class="headerlink" title="Problem D. 最近点对"></a>Problem D. 最近点对</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>有n个坐标点，问这些点之间最近的一对点的距离是多少？</p><h4 id="输入数据-9"><a href="#输入数据-9" class="headerlink" title="输入数据"></a>输入数据</h4><p>多组输入(&lt;=10组数据，读入以EOF结尾)。 每组第一行输入一个数字，n(1&lt;=n&lt;=100000) 表示坐标点的个数。 随后n行，为两个整数，表示对应的坐标点。</p><h4 id="输出数据-9"><a href="#输出数据-9" class="headerlink" title="输出数据"></a>输出数据</h4><p>每组输出一行结果，保留两位有效数字</p><h4 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">41</span><br></code></pre></td></tr></table></figure><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><h3 id="Problem-E-小明的散步路径"><a href="#Problem-E-小明的散步路径" class="headerlink" title="Problem E. 小明的散步路径"></a>Problem E. 小明的散步路径</h3><p>时间限制 1000 ms<br>内存限制 64 MB</p><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p><img src="https://pic.imgdb.cn/item/61c7f2572ab3f51d91a4c649.png" alt="img"></p><h4 id="输入数据-10"><a href="#输入数据-10" class="headerlink" title="输入数据"></a>输入数据</h4><p>一行三个整数n,x,y(1&lt;=n&lt;=14,1&lt;=x,y&lt;=2n2n) 。</p><h4 id="输出数据-10"><a href="#输出数据-10" class="headerlink" title="输出数据"></a>输出数据</h4><p>一行一个整数k，表示坐标为(x,y)的格子是他第n天走过的第k个格子。</p><h4 id="样例输入-10"><a href="#样例输入-10" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-10"><a href="#样例输出-10" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (x == y &amp;&amp; y == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span> &amp;&amp; y == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (x == y &amp;&amp; y == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">2</span> &amp;&amp; y == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (n != <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, mid = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (x &lt;= mid &amp;&amp; y &lt;= mid) &#123;<br>res = fun(n - <span class="hljs-number">1</span>, y, x);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt;= mid &amp;&amp; y &gt; mid) &#123;<br>res = mid * mid + fun(n - <span class="hljs-number">1</span>, x, y - mid);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid &amp;&amp; y &gt; mid) &#123;<br>res = <span class="hljs-number">2</span> * mid * mid + fun(n - <span class="hljs-number">1</span>, x - mid, y - mid);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>res = <span class="hljs-number">3</span> * mid * mid + fun(n - <span class="hljs-number">1</span>, mid - y + <span class="hljs-number">1</span>, <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, n) - x + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n, x, y;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;x, &amp;y) != EOF) &#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; fun(n, x, y) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-1"><a href="#F-1" class="headerlink" title="Ｆ"></a>Ｆ</h2><h3 id="Problem-F-气球游戏"><a href="#Problem-F-气球游戏" class="headerlink" title="Problem F. 气球游戏"></a>Problem F. 气球游戏</h3><p>时间限制 10000 ms<br>内存限制 64 MB</p><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　刚刚今天去游乐场玩，发现了一个新的游戏项目，游戏是这样的，场上一共有 n 个气球，它们的编号是0到n-1，然后每个气球上还有一个数字，我们使用数组nums来保存这些数字。</p><p>　　现在游戏要求刚刚戳破所有的气球。每当刚刚戳破一个气球i时，刚刚可以获得nums[left] * nums[i] * nums[right]个积分。这里的left和right指的是和i相邻的两个气球的序号。（注意每当刚刚戳破了气球i后，气球left和气球right就变成了相邻的气球。）</p><p>　　求所能获得积分的最大值。</p><h4 id="输入数据-11"><a href="#输入数据-11" class="headerlink" title="输入数据"></a>输入数据</h4><p>　　输入中有若干组测试样例，第一行为一个正整数T(T≤1000)，表示测试样例组数。每组测试样例包含2部分： 第一部分有一行，包含1个正整数n（0≤n≤500），第二部分为一行，有n个数，第i个数表示num[i],(0≤num[i]≤100)。</p><h4 id="输出数据-11"><a href="#输出数据-11" class="headerlink" title="输出数据"></a>输出数据</h4><p>对每组测试数据，单独输出一行答案，表示最大的积分值</p><h4 id="样例输入-11"><a href="#样例输入-11" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-11"><a href="#样例输出-11" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">167<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = nums.size();<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; rec(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">2</span>));<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<br>val[<span class="hljs-number">0</span>] = val[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>val[i] = nums[i - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">2</span>; j &lt;= n + <span class="hljs-number">1</span>; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;<br><span class="hljs-keyword">int</span> sum = val[i] * val[k] * val[j];<br>sum += rec[i][k] + rec[k][j];<br>rec[i][j] = max(rec[i][j], sum);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> rec[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>&#125;<br>&#125;s;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T, n, tmp;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; num;<br><span class="hljs-built_in">cin</span> &gt;&gt; T;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;T;j++)<br>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; tmp;<br>num.push_back(tmp);<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; s.maxCoins(num) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>num.clear();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h2><h3 id="Problem-A-晴天小猪历险记之Hill"><a href="#Problem-A-晴天小猪历险记之Hill" class="headerlink" title="Problem A. 晴天小猪历险记之Hill"></a>Problem A. 晴天小猪历险记之Hill</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　这一天，他来到了一座深山的山脚下，因为只有这座深山中的一位隐者才知道这种药草的所在。但是上山的路错综复杂，由于小小猪的病情，晴天小猪想找一条需时最少的路到达山顶，但现在它一头雾水，所以向你求助。<br>　　山用一个三角形表示，从山顶依次向下有1段、2段、3段等山路，每一段用一个数字T（1&lt; =T&lt; =100）表示，代表晴天小猪在这一段山路上需要爬的时间，每一次它都可以朝左、右、左上、右上四个方向走（<strong>注意</strong>：在任意一层的第一段也可以走到本层的最后一段或上一层的最后一段）。<br>　　晴天小猪从山的左下角出发，目的地为山顶，即隐者的小屋。</p><h4 id="输入数据-12"><a href="#输入数据-12" class="headerlink" title="输入数据"></a>输入数据</h4><p>　　第一行有一个数 n (2≤n≤1000)，n (2≤n≤1000)， 表示山的高度。<br>　　从第二行至第 n+1n+1 行，第 i+1i+1 行有 ii 个数，每个数表示晴天小猪在这一段山路上需要爬的时间。</p><h4 id="输出数据-12"><a href="#输出数据-12" class="headerlink" title="输出数据"></a>输出数据</h4><p>　　一个数，即晴天小猪所需要的最短时间。</p><h4 id="样例输入-12"><a href="#样例输入-12" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-12"><a href="#样例输出-12" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">10<br></code></pre></td></tr></table></figure><h4 id="样例说明-3"><a href="#样例说明-3" class="headerlink" title="样例说明"></a>样例说明</h4><p>在山的两侧的走法略有特殊，请自己模拟一下，开始我自己都弄错了……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 1050</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MaxNum = <span class="hljs-number">987654321</span>;<br><span class="hljs-keyword">int</span> n, mountain[MaxSize][MaxSize], dp[MaxSize][MaxSize];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mountain[i][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">1010</span>; j++)<br>&#123;<br>dp[i][j] = MaxNum;<br>&#125;<br>&#125;<br>dp[n][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>)<br>dp[i][j] = min(min(dp[i][j], dp[i + <span class="hljs-number">1</span>][j] + mountain[i + <span class="hljs-number">1</span>][j]), min(dp[i + <span class="hljs-number">1</span>][i + <span class="hljs-number">1</span>] + mountain[i + <span class="hljs-number">1</span>][i + <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + mountain[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]));<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == i)<br>dp[i][j] = min(dp[i][j], min(dp[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + mountain[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], min(dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + mountain[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j] + mountain[i + <span class="hljs-number">1</span>][j])));<br><span class="hljs-keyword">else</span><br>dp[i][j] = min(dp[i][j], min(dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + mountain[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j] + mountain[i + <span class="hljs-number">1</span>][j]));<br>&#125;<br>dp[i][<span class="hljs-number">1</span>] = min(dp[i][<span class="hljs-number">1</span>], dp[i][i] + mountain[i][i]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt;= i; j++)<br>dp[i][j] = min(dp[i][j], dp[i][j - <span class="hljs-number">1</span>] + mountain[i][j - <span class="hljs-number">1</span>]);<br>dp[i][n] = min(dp[i][n], dp[i][<span class="hljs-number">1</span>] + mountain[i][<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--)<br>dp[i][j] = min(dp[i][j], dp[i][j + <span class="hljs-number">1</span>] + mountain[i][j + <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; sum(dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],mountain[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h2><h3 id="Problem-B-清帝之惑之顺治"><a href="#Problem-B-清帝之惑之顺治" class="headerlink" title="Problem B. 清帝之惑之顺治"></a>Problem B. 清帝之惑之顺治</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　顺治喜欢滑雪，这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待太监们来载你。顺治想知道载一个区域中最长的滑坡。<br>　　区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><p>　　 1 2 3 4 5<br>　　16 17 18 19 6<br>　　15 24 25 20 7<br>　　14 23 22 21 8<br>　　13 12 11 10 9</p><p>　　顺治可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。</p><h4 id="输入数据-13"><a href="#输入数据-13" class="headerlink" title="输入数据"></a>输入数据</h4><p>　　输入的第一行表示区域的行数 RR 和列数 C (1≤R,C≤500)C (1≤R,C≤500) 。下面是 RR 行，每行有 CC 个整数，代表高度 h,0≤h&lt;103h,0≤h&lt;103 。</p><h4 id="输出数据-13"><a href="#输出数据-13" class="headerlink" title="输出数据"></a>输出数据</h4><p>　　输出最长区域的长度。</p><h4 id="样例输入-13"><a href="#样例输入-13" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">16 </span><span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">20</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">14 </span><span class="hljs-number">23</span> <span class="hljs-number">22</span> <span class="hljs-number">21</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">12</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-13"><a href="#样例输出-13" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">25<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> high[<span class="hljs-number">550</span>][<span class="hljs-number">550</span>], dp[<span class="hljs-number">550</span>][<span class="hljs-number">550</span>];<br><span class="hljs-keyword">int</span> xx, yy, max_ans;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">inmap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; xx&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; yy;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (dp[x][y])<br><span class="hljs-keyword">return</span> dp[x][y];<br>dp[x][y] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> xu = x, yu = y - <span class="hljs-number">1</span>, xd = x, yd = y + <span class="hljs-number">1</span>, xr = x + <span class="hljs-number">1</span>, yr = y, xl = x - <span class="hljs-number">1</span>, yl = y;<br><span class="hljs-keyword">if</span> (inmap(xu, yu) &amp;&amp; high[xu][yu] &gt; high[x][y])<br>&#123;<br>dp[x][y] = max(dp[x][y], solve(xu, yu)+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (inmap(xd, yd) &amp;&amp; high[xd][yd] &gt; high[x][y])<br>&#123;<br>dp[x][y] = max(dp[x][y], solve(xd, yd)+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (inmap(xl, yl) &amp;&amp; high[xl][yl] &gt; high[x][y])<br>&#123;<br>dp[x][y] = max(dp[x][y], solve(xl, yl)+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (inmap(xr, yr) &amp;&amp; high[xr][yr] &gt; high[x][y])<br>&#123;<br>dp[x][y] = max(dp[x][y], solve(xr, yr)+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> dp[x][y];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-built_in">cin</span> &gt;&gt; xx &gt;&gt; yy;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; xx; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; yy; j++) &#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; high[i][j];<br>&#125;<br>max_ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; xx; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; yy; j++)<br>&#123;<br><span class="hljs-keyword">int</span> tmp = solve(i, j);<br><span class="hljs-keyword">if</span> (tmp &gt; max_ans)<br>max_ans = tmp;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; max_ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><h3 id="Problem-C-积木城堡"><a href="#Problem-C-积木城堡" class="headerlink" title="Problem C. 积木城堡"></a>Problem C. 积木城堡</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h4><p>XC的儿子小XC最喜欢玩的游戏用积木垒漂亮的城堡。城堡是用一些立方体的积木垒成的，城堡的每一层是一块积木。小XC是一个比他爸爸XC还聪明的孩子，他发现垒城堡的时候，如果下面的积木比上面的积木大，那么城堡便不容易倒。所以他在垒城堡的时候总是遵循这样的规则。<br>小XC想把自己垒的城堡送给幼儿园里漂亮的女孩子们，这样可以增加他的好感度。为了公平起见，他决定把送给每个女孩子一样高的城堡，这样可以避免女孩子们为了获得更漂亮的城堡而引起争执。可是他发现自己在垒城堡的时候并没有预先考虑到这一点。所以他现在要改造城堡。由于他没有多余的积木了，他灵机一动，想出了一个巧妙的改造方案。他决定从每一个城堡中挪去一些积木，使得最终每座城堡都一样高。为了使他的城堡更雄伟，他觉得应该使最后的城堡都尽可能的高。<br>任务：<br>请你帮助小XC编一个程序，根据他垒的所有城堡的信息，决定应该移去哪些积木才能获得最佳的效果。</p><h4 id="输入数据-14"><a href="#输入数据-14" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行是一个整数 N (N≤100)，N (N≤100)， 表示一共有几座城堡。以下 NN 行每行是一系列非负整数，用一个空格分隔，按从下往上的顺序依次给出一座城堡中所有积木的棱长。用<code>-1</code>结束。一座城堡中的积木不超过100块，每块积木的棱长不超过100。</p><h4 id="输出数据-14"><a href="#输出数据-14" class="headerlink" title="输出数据"></a>输出数据</h4><p>一个整数，表示最后城堡的最大可能的高度。如果找不到合适的方案，则输出 00 。</p><h4 id="样例输入-14"><a href="#样例输入-14" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> –<span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> –<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-14"><a href="#样例输出-14" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><h4 id="样例说明-4"><a href="#样例说明-4" class="headerlink" title="样例说明"></a>样例说明</h4><p>原数据有误,不知我修正后是不是对?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 105</span><br><span class="hljs-keyword">int</span> a[MaxSize], dp[MaxSize][MaxSize * MaxSize], n;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (dp[i][v] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[cnt]);<br>            <span class="hljs-keyword">if</span> (a[cnt] == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            sum = sum + a[cnt];<br>            cnt++;<br>        &#125;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = sum; k &gt;= a[j]; k--)<br>                <span class="hljs-keyword">if</span> (dp[i][k - a[j]])<br>                &#123;<br>                    dp[i][k] = <span class="hljs-number">1</span>;<br>                &#125;<br>    &#125;<br>    ans = <span class="hljs-number">10001</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dp[<span class="hljs-number">0</span>][ans] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        ans--;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (solve(ans) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        ans--;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h2><h3 id="Problem-D-Warcraft-III-守望者的烦恼"><a href="#Problem-D-Warcraft-III-守望者的烦恼" class="headerlink" title="Problem D. Warcraft III 守望者的烦恼"></a>Problem D. Warcraft III 守望者的烦恼</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h4><p>头脑并不发达的warden最近在思考一个问题，她的闪烁技能是可以升级的，k级的闪烁技能最多可以向前移动k个监狱，一共有n个监狱要视察，她从入口进去，一路上有n个监狱，而且不会往回走，当然她并不用每个监狱都视察，但是她最后一定要到第n个监狱里去，因为监狱的出口在那里，但是她并不一定要到第1个监狱。<br>守望者warden现在想知道，她在拥有k级闪烁技能时视察n个监狱一共有多少种方案？</p><h4 id="输入数据-15"><a href="#输入数据-15" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行是闪烁技能的等级 k (1≤k≤10)k (1≤k≤10)<br>第二行是监狱的个数 n (1≤n≤231−1)n (1≤n≤231−1)</p><h4 id="输出数据-15"><a href="#输出数据-15" class="headerlink" title="输出数据"></a>输出数据</h4><p>由于方案个数会很多，所以输出它 mod 7777777后的结果就行了</p><h4 id="样例输入-15"><a href="#样例输入-15" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>4<br></code></pre></td></tr></table></figure><h4 id="样例输出-15"><a href="#样例输出-15" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><h4 id="样例说明-5"><a href="#样例说明-5" class="headerlink" title="样例说明"></a>样例说明</h4><p>把监狱编号1 2 3 4,闪烁技能为2级，<br>一共有5种方案<br>→1→2→3→4<br>→2→3→4<br>→2→4<br>→1→3→4<br>→1→2→4</p><p>小提示：建议用int64，否则可能会溢出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 7777777</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matrix</span></span><br><span class="hljs-class">&#123;</span><br>    ll s[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>&#125; a, b;<br><span class="hljs-keyword">int</span> n, k;<br><br><span class="hljs-function">matrix <span class="hljs-title">Matrix</span><span class="hljs-params">(matrix x, matrix y)</span></span><br><span class="hljs-function"></span>&#123;<br>    matrix c;<br>    <span class="hljs-built_in">memset</span>(c.s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(c.s));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> kk = <span class="hljs-number">1</span>; kk &lt;= k; kk++)<br>            &#123;<br>                c.s[i][j] += x.s[i][kk] * y.s[kk][j];<br>                c.s[i][j] %= mod;<br>            &#125;<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(a.s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a.s));<br>    <span class="hljs-built_in">memset</span>(b.s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(b.s));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    init_();<br>    a.s[k][k] = <span class="hljs-number">1</span>; <span class="hljs-comment">//初始化，dp[1]=1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++)<br>        b.s[i][i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>        b.s[k][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123; <span class="hljs-comment">//dp[n]需要乘以n个矩阵b</span><br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>            a = Matrix(a, b);<br>        b = Matrix(b, b);<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, a.s[k][k]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><h3 id="Problem-E-加分二叉树"><a href="#Problem-E-加分二叉树" class="headerlink" title="Problem E. 加分二叉树"></a>Problem E. 加分二叉树</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：<br>　　subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数<br>　　若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。<br>　　试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；<br>　　（1）tree的最高加分<br>　　（2）tree的前序遍历</p><h4 id="输入数据-16"><a href="#输入数据-16" class="headerlink" title="输入数据"></a>输入数据</h4><p>　　第 11 行：一个整数 n (n＜30)，n (n＜30)， 为节点个数。<br>　　第 22 行 ：n：n 个用空格隔开的整数，为每个节点的分数（分数 ＜100）＜100） 。</p><h4 id="输出数据-16"><a href="#输出数据-16" class="headerlink" title="输出数据"></a>输出数据</h4><p>　　第 11 行：一个整数，为最高加分（结果不会超过 4,000,000,000）4,000,000,000） 。<br>　　第 22 行 ：n：n 个用空格隔开的整数，为该树的前序遍历。<br>若存在多种前序遍历均为最高加分，则输出字典序最小的前序遍历</p><h4 id="样例输入-16"><a href="#样例输入-16" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-16"><a href="#样例输出-16" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">145</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-keyword">int</span> n, a[<span class="hljs-number">40</span>], root[<span class="hljs-number">40</span>][<span class="hljs-number">40</span>];<br>ll dp[<span class="hljs-number">40</span>][<span class="hljs-number">40</span>];<br><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L &gt; R)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//因为要左右子节点相乘，所以如果是空则给1</span><br>    <span class="hljs-keyword">if</span> (dp[L][R])<br>        <span class="hljs-keyword">return</span> dp[L][R]; <span class="hljs-comment">//关键一步，记忆化，以前走过那就直接返回结果</span><br>    ll maxn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = L; i &lt; R; i++)<br>    &#123;<br>        ll t = dfs(L, i - <span class="hljs-number">1</span>) * dfs(i + <span class="hljs-number">1</span>, R) + a[i];<br>        <span class="hljs-keyword">if</span> (t &gt; maxn)<br>        &#123;<br>            maxn = t;<br>            root[L][R] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[L][R] = maxn;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L &gt; R)<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">//防止出现 L &gt;R</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, root[L][R]);<br>    dg(L, root[L][R] - <span class="hljs-number">1</span>);<br>    dg(root[L][R] + <span class="hljs-number">1</span>, R);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>        dp[i][i] = a[i];<br>        root[i][i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    init_();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dfs(<span class="hljs-number">1</span>, n));<br>    dg(<span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="期中"><a href="#期中" class="headerlink" title="期中"></a>期中</h2><h2 id="A-3"><a href="#A-3" class="headerlink" title="A"></a>A</h2><h3 id="Problem-A-陶陶摘苹果"><a href="#Problem-A-陶陶摘苹果" class="headerlink" title="Problem A. 陶陶摘苹果"></a>Problem A. 陶陶摘苹果</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。<br>　　现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。</p><h4 id="输入数据-17"><a href="#输入数据-17" class="headerlink" title="输入数据"></a>输入数据</h4><p>　　输入包括两行数据。第一行包含 1010 个100到200之间（包括100和200）的整数（以厘米为单位）分别表示 1010 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个100到120之间（包含100和120）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。</p><h4 id="输出数据-17"><a href="#输出数据-17" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。</p><h4 id="样例输入-17"><a href="#样例输入-17" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">100 </span><span class="hljs-number">200</span> <span class="hljs-number">150</span> <span class="hljs-number">140</span> <span class="hljs-number">129</span> <span class="hljs-number">134</span> <span class="hljs-number">167</span> <span class="hljs-number">198</span> <span class="hljs-number">200</span> <span class="hljs-number">111</span><br><span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-17"><a href="#样例输出-17" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><h2 id="B-3"><a href="#B-3" class="headerlink" title="B"></a>B</h2><h3 id="Problem-B-选数"><a href="#Problem-B-选数" class="headerlink" title="Problem B. 选数"></a>Problem B. 选数</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　已知 n 个整数 x1,x2,…,xn，以及一个整数 k（k＜n）。从 n 个整数中任选 k 个整数相加，可分别得到一系列的和。例如当 n=4，k＝3，4 个整数分别为 3，7，12，19 时，可得全部的组合与它们的和为：<br>　　3＋7＋12=22　　3＋7＋19＝29　　7＋12＋19＝38　　3＋12＋19＝34。<br>　　现在，要求你计算出和为素数共有多少种。<br>　　例如上例，只有一种的和为素数：3＋7＋19＝29）。</p><h4 id="输入数据-18"><a href="#输入数据-18" class="headerlink" title="输入数据"></a>输入数据</h4><p>n , k （1&lt; =n&lt; =20，k＜n）<br>x1,x2，…,xn （1&lt; =xi&lt; =5e5）</p><h4 id="输出数据-18"><a href="#输出数据-18" class="headerlink" title="输出数据"></a>输出数据</h4><p>一个整数（满足条件的种数）。</p><h4 id="样例输入-18"><a href="#样例输入-18" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">12</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-18"><a href="#样例输出-18" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(x); i++)<br><span class="hljs-keyword">if</span>(!(x % i))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> n, k, ans;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">30</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">force</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> used)</span></span>&#123;<br><span class="hljs-keyword">if</span>(used == k)&#123;<br><span class="hljs-keyword">if</span>(isPrime(sum))<br>ans++;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-keyword">if</span>(n - now + used &lt; k)<br><span class="hljs-keyword">return</span> ;<br>force(sum + a[now], now + <span class="hljs-number">1</span>, used + <span class="hljs-number">1</span>);<br>force(sum, now + <span class="hljs-number">1</span>, used);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>force(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-3"><a href="#C-3" class="headerlink" title="C"></a>C</h2><h3 id="Problem-C-Ricky队形"><a href="#Problem-C-Ricky队形" class="headerlink" title="Problem C. Ricky队形"></a>Problem C. Ricky队形</h3><p>时间限制 1000 ms<br>内存限制 256 MB</p><h4 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h4><p>Ricky班里有n(2&lt;=n&lt;=100000)个人，每个人有一个学号ai(1&lt;=ai&lt;=n)，保证学号ai互不相同。Ricky手里有一张班级合影，他发现虽然大家是按身高从低到高排好队的，但如果按学号看的话却不一定是从小到大，他想看一看如果按照学号来看，这个队排的有多乱。Ricky把混乱度定义为队列中逆序对的个数，即：如果从前往后看，大家正好是按照学号从小到大排列的，那逆序对为0个，混乱度为0；而每能找到两个人形成了学号大同学的在前，学号小的在后（即i &lt; j且ai &gt; aj），就称其为一个逆序对，混乱度计数也要加1。由于Ricky班里人可能很多，Ricky实在数不过来了，现在告诉你合影上同学们的学号（按从前往后），请你帮忙编写程序计算一下混乱度，满足一下Ricky的好奇心。</p><h4 id="输入数据-19"><a href="#输入数据-19" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行有一个整数n(2&lt;=n&lt;=100000)，表示Ricky班上的人数； 第二行有n个整数a1,a2,…,an(1&lt;=ai&lt;=n)，表示合影上同学们的学号。</p><h4 id="输出数据-19"><a href="#输出数据-19" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出一个整数，表示合影上排列的混乱度（逆序对个数）</p><h4 id="样例输入-19"><a href="#样例输入-19" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-19"><a href="#样例输出-19" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><h4 id="样例说明-6"><a href="#样例说明-6" class="headerlink" title="样例说明"></a>样例说明</h4><p>其中(3,2) (4,2)形成两个逆序对，所以混乱度为2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> tmp[<span class="hljs-number">112345</span>], a[<span class="hljs-number">112345</span>], n;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mysort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt;= r)<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>mysort(l, mid);<br>mysort(mid + <span class="hljs-number">1</span>, r);<br><span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br><span class="hljs-keyword">if</span>(a[i] &lt;= a[j])<br>tmp[k++] = a[i++];<br><span class="hljs-keyword">else</span>&#123;<br>ans += mid - i + <span class="hljs-number">1</span>;<br>tmp[k++] = a[j++]; <br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(; i &lt;= mid; i++)<br>tmp[k++] = a[i];<br><span class="hljs-keyword">for</span>(; j &lt;= r; j++)<br>tmp[k++] = a[j];<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>a[i + l] = tmp[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>mysort(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-3"><a href="#D-3" class="headerlink" title="D"></a>D</h2><h3 id="Problem-D-Ricky的蔬菜沙拉"><a href="#Problem-D-Ricky的蔬菜沙拉" class="headerlink" title="Problem D. Ricky的蔬菜沙拉"></a>Problem D. Ricky的蔬菜沙拉</h3><p>时间限制 1000 ms<br>内存限制 256 MB</p><h4 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h4><p>Ricky决定从今天起开始减肥，所以晚上就吃蔬菜沙拉了。现在Ricky家里就有n种食材（每种只有一份），他准备从中挑选一些来制作沙拉。每样食材都有两种属性，美味程度Di，以及热量值Ci。吃饭很讲究的Ricky有个小小的要求，最后挑选的所有食材的美味程度之和必须是热量值之和的k倍。现在想请你来帮忙计算，在满足Ricky的要求的情况下，挑选的所有食材美味值之和最大是多少。如果无法制作出符合要求的沙拉，请输出-1。</p><h4 id="输入数据-20"><a href="#输入数据-20" class="headerlink" title="输入数据"></a>输入数据</h4><p>第一行有两个整数n，k（1 ≤ n ≤ 100, 1 ≤ k ≤ 10），表示食材的数量，以及Ricky要求的倍数；<br>第二行有n个整数D1,D2,…,Dn (1 ≤ Di ≤ 100)，表示每个食材的美味程度；<br>第三行有n个整数C1,C2,…,Cn (1 ≤ Ci ≤ 100)，表示每个食材的热量值。</p><h4 id="输出数据-20"><a href="#输出数据-20" class="headerlink" title="输出数据"></a>输出数据</h4><p>如果无法制作出符合要求的沙拉，输出-1；否则输出一个整数，表示挑选的所有食材美味值之和最大值。</p><h4 id="样例输入-20"><a href="#样例输入-20" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">8</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-20"><a href="#样例输出-20" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">18<br></code></pre></td></tr></table></figure><h4 id="样例说明-7"><a href="#样例说明-7" class="headerlink" title="样例说明"></a>样例说明</h4><p>再给一组样例：<br>样例输入：<br>5 3<br>4 4 4 4 4<br>2 2 2 2 2<br>样例输出：<br>-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> n, k, add;<br><span class="hljs-keyword">int</span> d[<span class="hljs-number">110</span>], c[<span class="hljs-number">110</span>], dt[<span class="hljs-number">110</span>];<br><span class="hljs-keyword">int</span> f1[<span class="hljs-number">11234</span>], f2[<span class="hljs-number">11234</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><span class="hljs-built_in">cin</span> &gt;&gt; d[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; c[i];<br>dt[i] = d[i] - k * c[i];<br><span class="hljs-keyword">if</span>(dt[i] == <span class="hljs-number">0</span>)<br>add += d[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11234</span>; i++)<br>f1[i] = f2[i] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><span class="hljs-keyword">if</span>(dt[i] &gt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">10000</span>; j &gt;= dt[i]; j--)&#123;<br><span class="hljs-keyword">if</span>(f1[j - dt[i]] != <span class="hljs-number">-1</span>)<br>f1[j] = max(f1[j], f1[j - dt[i]] + d[i]);<br><span class="hljs-keyword">if</span>(j == dt[i])<br>f1[j] = max(f1[j], d[i]); <br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><span class="hljs-keyword">if</span>(dt[i] &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">10000</span>; j &gt;= -dt[i]; j--)&#123;<br><span class="hljs-keyword">if</span>(f2[j + dt[i]] != <span class="hljs-number">-1</span>)<br>f2[j] = max(f2[j], f2[j + dt[i]] + d[i]);<br><span class="hljs-keyword">if</span>(j == -dt[i])<br>f2[j] = max(f2[j], d[i]); <br>&#125;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br><span class="hljs-keyword">if</span>(f1[i] != <span class="hljs-number">-1</span> &amp;&amp; f2[i] != <span class="hljs-number">-1</span>)<br>ans = max(ans, f1[i] + f2[i]);<br><span class="hljs-keyword">if</span>(add != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(ans == <span class="hljs-number">-1</span>)<br>ans = add;<br><span class="hljs-keyword">else</span><br>ans += add;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-3"><a href="#E-3" class="headerlink" title="E"></a>E</h2><h3 id="Problem-E-24点游戏"><a href="#Problem-E-24点游戏" class="headerlink" title="Problem E. 24点游戏"></a>Problem E. 24点游戏</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　几十年前全世界就流行一种数字扑克游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算24点”。您作为游戏者将得到4个1-13（在扑克牌里用A代替1，J代替11，Q代替12，K代替13）之间的自然数作为操作数，而您的任务是对这4个操作数进行适当的算术运算（可以使用+、-、*、/、括号），判断运算结果是否等于24。能输出1，不能输出0。</p><h4 id="输入数据-21"><a href="#输入数据-21" class="headerlink" title="输入数据"></a>输入数据</h4><p>四个牌面值。牌面值与牌面值之间用一个空格隔开。</p><h4 id="输出数据-21"><a href="#输出数据-21" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出 00 或 11 。</p><h4 id="样例输入-21"><a href="#样例输入-21" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">8</span> <span class="hljs-number">10</span> Q<br></code></pre></td></tr></table></figure><h4 id="样例输出-21"><a href="#样例输出-21" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br></code></pre></td></tr></table></figure><h4 id="样例说明-8"><a href="#样例说明-8" class="headerlink" title="样例说明"></a>样例说明</h4><p>Q×(10/(8-3))=24</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> ctoi[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">bool</span> ans;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span>&#123;</span><br><span class="hljs-keyword">float</span> num[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">bool</span> sign[<span class="hljs-number">4</span>];<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">force</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, item a)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(a.num[<span class="hljs-number">0</span>] == <span class="hljs-number">24</span>)<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>item b;<br><span class="hljs-built_in">memset</span>(b.sign, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(b.sign));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>a.sign[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br><span class="hljs-keyword">if</span>(i != j)&#123;<br>a.sign[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)<br><span class="hljs-keyword">if</span>(!a.sign[k])<br>b.num[l++] = a.num[k];<br>b.num[l] = a.num[i] + a.num[j];<br>force(n - <span class="hljs-number">1</span>, b);<br>b.num[l] = a.num[i] - a.num[j];<br>force(n - <span class="hljs-number">1</span>, b);<br>b.num[l] = a.num[i] * a.num[j];<br>force(n - <span class="hljs-number">1</span>, b);<br><span class="hljs-keyword">if</span>(a.num[j] != <span class="hljs-number">0</span>)&#123;<br>b.num[l] = a.num[i] / a.num[j];<br>force(n - <span class="hljs-number">1</span>, b); <br>&#125;<br>a.sign[j] = <span class="hljs-number">0</span>;<br>&#125;<br>a.sign[i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>ctoi[i + <span class="hljs-number">48</span>] = i;<br>ctoi[<span class="hljs-string">&#x27;A&#x27;</span>] = <span class="hljs-number">1</span>;<br>ctoi[<span class="hljs-string">&#x27;J&#x27;</span>] = <span class="hljs-number">11</span>;<br>ctoi[<span class="hljs-string">&#x27;Q&#x27;</span>] = <span class="hljs-number">12</span>;<br>ctoi[<span class="hljs-string">&#x27;K&#x27;</span>] = <span class="hljs-number">13</span>;<br><br>item a;<br><span class="hljs-built_in">memset</span>(a.sign, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a.sign));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br><span class="hljs-keyword">char</span> x[<span class="hljs-number">5</span>];<br><span class="hljs-built_in">cin</span> &gt;&gt; x;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(x) == <span class="hljs-number">2</span>)<br>a.num[i] = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">else</span><br>a.num[i] = ctoi[x[<span class="hljs-number">0</span>]];<br>&#125;<br>force(<span class="hljs-number">4</span>, a);<br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="贪心与图"><a href="#贪心与图" class="headerlink" title="贪心与图"></a>贪心与图</h1><h2 id="A-4"><a href="#A-4" class="headerlink" title="A"></a>A</h2><h3 id="Problem-A-最小差距"><a href="#Problem-A-最小差距" class="headerlink" title="Problem A. 最小差距"></a>Problem A. 最小差距</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　给定一些不同的一位数字，你可以从这些数字中选择若干个，并将它们按一定顺序排列，组成一个整数，把剩下的数字按一定顺序排列，组成另一个整数。组成的整数不能以0开头（除非这个整数只有1位）。<br>　　例如，给定6个数字，0,1,2,4,6,7，你可以用它们组成一对数10和2467，当然，还可以组成其他的很多对数，比如210和764，204和176。这些对数中两个数差的绝对值最小的是204和176，为28。<br>　　给定N个不同的0~9之间的数字，请你求出用这些数字组成的每对数中，差的绝对值最小的一对（或多对）数的绝对值是多少？</p><h4 id="输入数据-22"><a href="#输入数据-22" class="headerlink" title="输入数据"></a>输入数据</h4><p>　　第一行包括一个数 T (T≤1000)，T (T≤1000)， 为测试数据的组数。<br>　　每组数据包括两行，第一行为一个数 N (2≤N≤10)，N (2≤N≤10)， 表示数字的个数。下面一行为 NN 个不同的一位数字。</p><h4 id="输出数据-22"><a href="#输出数据-22" class="headerlink" title="输出数据"></a>输出数据</h4><p>TT 行，每行一个数，表示第 ii 个数据的答案。即最小的差的绝对值。</p><h4 id="样例输入-22"><a href="#样例输入-22" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-22"><a href="#样例输出-22" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">28<br>5<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">15</span>]; <br><span class="hljs-keyword">int</span> visited[<span class="hljs-number">15</span>];<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">odd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">int</span> temp=a[<span class="hljs-number">1</span>];<br>a[<span class="hljs-number">1</span>]=a[<span class="hljs-number">2</span>];<br>a[<span class="hljs-number">2</span>]=temp;<br>&#125;<br><span class="hljs-keyword">int</span> s1 = <span class="hljs-number">0</span>, s2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>; i++)<br>s1 = s1*<span class="hljs-number">10</span> + a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n; i&gt;n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>; i--)<br>s2 = s2*<span class="hljs-number">10</span> + a[i];<br><span class="hljs-keyword">return</span> s1-s2;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">even</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">int</span> res = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br><span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>])&#123;<br><span class="hljs-built_in">memset</span>(visited, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(visited));<br><span class="hljs-keyword">int</span> s1=a[i], s2=a[i<span class="hljs-number">-1</span>];<br>visited[i]=<span class="hljs-number">1</span>;<br>visited[i<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> left=<span class="hljs-number">1</span>, right=n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=(n<span class="hljs-number">-2</span>)/<span class="hljs-number">2</span>; j++)&#123;<span class="hljs-comment">//每一轮选出两个数字 </span><br><span class="hljs-keyword">while</span>(visited[left]) left++;<br><span class="hljs-keyword">while</span>(visited[right]) right--;<br>visited[left]=<span class="hljs-number">1</span>;<br>visited[right]=<span class="hljs-number">1</span>;<br>s1 = s1*<span class="hljs-number">10</span> + a[left];<br>s2 = s2*<span class="hljs-number">10</span> + a[right];<br>&#125;<br>res = min(res, s1-s2);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> T;<br><span class="hljs-built_in">cin</span>&gt;&gt;T;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>; id &lt; T; id++)<br>&#123;<br><span class="hljs-keyword">int</span> N, ans;<br><span class="hljs-built_in">cin</span> &gt;&gt; N;<br><span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br><span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br><br>sort(a + <span class="hljs-number">1</span>, a + N + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (N == <span class="hljs-number">2</span>) &#123;<br>ans = a[<span class="hljs-number">2</span>] - a[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>ans = odd(N);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>ans = even(N);<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="B-4"><a href="#B-4" class="headerlink" title="B"></a>B</h2><h3 id="Problem-B-合并果子"><a href="#Problem-B-合并果子" class="headerlink" title="Problem B. 合并果子"></a>Problem B. 合并果子</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。<br>　　每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。<br>　　因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。<br>　　例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。</p><h4 id="输入数据-23"><a href="#输入数据-23" class="headerlink" title="输入数据"></a>输入数据</h4><p>输入包括两行，第一行是一个整数 n (1&lt;＝n&lt;103)，n (1&lt;＝n&lt;103)， 表示果子的种类数。第二行包含 nn 个整数，用空格分隔，第 ii 个整数 ai (1&lt;＝ai&lt;2×103)ai (1&lt;＝ai&lt;2×103) 是第 ii 种果子的数目。</p><h4 id="输出数据-23"><a href="#输出数据-23" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 231231 。</p><h4 id="样例输入-23"><a href="#样例输入-23" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-23"><a href="#样例输出-23" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">15 </span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n, ans = <span class="hljs-number">0</span>,x;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br><span class="hljs-comment">//这里使用优先队列的方法</span><br><span class="hljs-built_in">priority_queue</span> &lt; <span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;, greater &lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; x;<br>q.push(x);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> x1 = q.top();<br>q.pop();<br><span class="hljs-keyword">int</span> x2 = q.top();<br>q.pop();<br>ans += x1 + x2;<br>q.push(x1 + x2);<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="C-4"><a href="#C-4" class="headerlink" title="C"></a>C</h2><h3 id="Problem-C-北京2008的挂钟"><a href="#Problem-C-北京2008的挂钟" class="headerlink" title="Problem C. 北京2008的挂钟"></a>Problem C. 北京2008的挂钟</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　在2008北京奥运会雄伟的主会场的墙上，挂着如上图所示的3*3的九个挂钟（一开始指针即时针指向的位置请根据输入数据调整）。然而此次奥运会给与了大家一个机会，去用最少的移动操作改变上面的挂钟的时间全部为12点正（我们只考虑时针）。然而每一次操作并不是任意的，我们必须按照下面给出的列表对于挂钟进行改变。每一次操作我们给而且必须给指定的操作挂钟进行，每一个挂钟顺时针转动90度。列表如下：</p><p>　　操作 指定的操作挂钟<br>　　 1　　　　 ABDE<br>　　 2　　　　 ABC<br>　　 3　　　　 BCEF<br>　　 4　　　　 ADG<br>　　 5　　　　 BDEFH<br>　　 6　　　　 CFI<br>　　 7　　　　 DEGH<br>　　 8　　　　 GHI<br>　　 9　　　　 EFHI</p><h4 id="输入数据-24"><a href="#输入数据-24" class="headerlink" title="输入数据"></a>输入数据</h4><p>　　你的程序按照标准的 3∗33∗3 格式读入，一共 99 个 0−30−3 的数。 00 代表 1212 点 ，1，1 代表 33 点 ，2，2 代表 66 点 ，3，3 代表 99 点。<br>　　Your program is to read from standard input. Nine numbers give the start positions of the dials. 0=12 o’clock, 1=3 o’clock, 2=6 o’clock, 3=9 o’clock.</p><h4 id="输出数据-24"><a href="#输出数据-24" class="headerlink" title="输出数据"></a>输出数据</h4><p>　　你的程序需要写出标准的输出。输出一个最短的能够使所有挂钟指向 1212 点的移动操作序列，中间以空格隔开，最后有空格，加回车。这一条最短操作需要是所有最短操作中最小的，也就是说选择最小的第一个操作数，如果第一个操作数相等，那么选择最小的第二个操作数……以此类推。值得肯定的是，这一条操作序列是唯一的。<br>　　Your program is to write to standard output. Output a shortest sorted sequence of moves (numbers), which returns all the dials to 12 o’clock. You are convinced that the answer is unique.</p><h4 id="样例输入-24"><a href="#样例输入-24" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-24"><a href="#样例输出-24" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> way[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>] = &#123; &#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;,<span class="hljs-comment">// 操作1ABDE</span><br>&#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;,<span class="hljs-comment">// 操作2ABC</span><br>&#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;,<span class="hljs-comment">// 操作3BCEF</span><br>&#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;,<span class="hljs-comment">// 操作4ADG</span><br>&#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span> &#125;,<span class="hljs-comment">// 操作5BDEFH</span><br>&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;,<span class="hljs-comment">// 操作6CFI</span><br>&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span> &#125;,<span class="hljs-comment">// 操作7DEGH</span><br>&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span> &#125;,<span class="hljs-comment">// 操作8GHI</span><br>&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span> &#125; <span class="hljs-comment">// 操作9EFHI</span><br>&#125;;<br><span class="hljs-keyword">bool</span> judge;<span class="hljs-comment">//判断是否调整完成</span><br><span class="hljs-keyword">int</span> x[<span class="hljs-number">9</span>], ans[<span class="hljs-number">9</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (num == <span class="hljs-number">9</span>)<span class="hljs-comment">//9种方式全部搜完</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (x[i] % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>)<span class="hljs-comment">//有不是12点的钟</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>judge = <span class="hljs-literal">true</span>;<span class="hljs-comment">//全部调整完成</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>&#123;<br>ans[num] = i;<span class="hljs-comment">//第（i+1）钟方式的数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++)<br>&#123;<br>x[j] += way[num][j] * i;<span class="hljs-comment">//改变</span><br>&#125;<br>dfs(num + <span class="hljs-number">1</span>);<span class="hljs-comment">//深搜</span><br><span class="hljs-keyword">if</span> (judge)<span class="hljs-comment">//此时已经调整完成，而调整方式有且只有一种，因此可以输出答案</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++)<br>&#123;<br>x[j] -= way[num][j] * i;<span class="hljs-comment">//回溯</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printRes</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ans[i]; j++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; x[i];<br>&#125;<br><br>dfs(<span class="hljs-number">0</span>);<br>printRes();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-4"><a href="#D-4" class="headerlink" title="D"></a>D</h2><h3 id="Problem-D-毒药？解药？"><a href="#Problem-D-毒药？解药？" class="headerlink" title="Problem D. 毒药？解药？"></a>Problem D. 毒药？解药？</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　羽毛笔和im是抽签到同一个考场的，她们突然闻到一阵刺鼻的化学试剂的气味。<br>　　机灵鼠：（头都不抬）你们是考生么？还在门口磨蹭什么？快进来帮我忙！！……怎么还不进来？你们拖赛，拖赛，把你们的青春都拖掉赛……<br>　　im：开…开策了&gt; <em>&lt;<br>　　羽毛笔：哎呀~~机灵鼠大人要我们帮什么忙？^^<br>　　机灵鼠：你们看这里的这些药，都是我研制的对付各种症状的解药。可是我一个不小心，每种药都小小地配错了一点原料，所以这些药都有可能在治愈某些病症的同时又使人患上某些别的病症……（im：那…那是解药还是毒药啊？！）……经过我天才的努力（背景：我是天才！！），终于弄清了每种药的具体性能（路人甲：那是你自己配的吗？-</em>-），我会把每种药能治的病症和能使人患上的病症列一张清单给你们，然后你们要根据这张清单找出能治愈所有病症的最少药剂组合……顺便说一声，病症的数目不超过10种（小呆：偶是好人吧^^），我的药是用不完的，就是说每种药剂都可以被重复使用。给你们的单子里第一行是病症的总数n，第二行是药剂的种类m（0&lt; m&lt; =100），以下有m行，每行有n个数字用空格隔开，文件的第i+2行的n个数字中，如果第j个数为1，就表示第i种药可以治愈病症j（如果患有这种病的话则治愈，没有这种病则无影响），如果为0表示无影响，如果为-1表示反而能使人得上这种病（无病患上，有病无影响）。我制的药任何两种性能都不同。你们只要给我用的最少的药剂数就可以了。给你们个样例：</p><h4 id="输入数据-25"><a href="#输入数据-25" class="headerlink" title="输入数据"></a>输入数据</h4><h4 id="输出数据-25"><a href="#输出数据-25" class="headerlink" title="输出数据"></a>输出数据</h4><h4 id="样例输入-25"><a href="#样例输入-25" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">3<br>2<br>1<span class="hljs-number"> 0 </span>1<br>-1<span class="hljs-number"> 1 </span>0<br></code></pre></td></tr></table></figure><h4 id="样例输出-25"><a href="#样例输出-25" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><h4 id="样例说明-9"><a href="#样例说明-9" class="headerlink" title="样例说明"></a>样例说明</h4><p>　　其实还有可能用尽了所有的药也不能将所有病治愈（真是不好意思嗬^^bb），那样的话你们只要写上“The patient will be dead.”就可以了。<br>　　im：做不出来啊<del>哇啊啊啊</del>（暴走中）<br>　　羽毛笔：哎呀~~im……来来吃药了。^^</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 15</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  maxm 110</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxg 1040</span><br><br><span class="hljs-keyword">bool</span> stateT[maxn], hashT[maxg];<br><span class="hljs-keyword">int</span> mp[maxm][maxn];<br><span class="hljs-keyword">int</span> stateI[maxg][maxn];<br><span class="hljs-keyword">int</span> n, m, finish;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> a[])</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>, s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>s += x * a[i];<br>x *= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-built_in">cin</span> &gt;&gt; mp[i][j];<br><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br>finish = (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br><span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-number">1</span>) stateT[j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-number">-1</span>) stateT[j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> stateT[j] = stateI[l][j];<br>&#125;<br><span class="hljs-keyword">int</span> x = Hash(stateT);<br><span class="hljs-keyword">if</span> (x == finish) &#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; stateI[l][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!hashT[x]) &#123;<br>hashT[x] = <span class="hljs-number">1</span>;<br>stateI[r][<span class="hljs-number">0</span>] = stateI[l][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) stateI[r][j] = stateT[j];<br>r++;<br>&#125;<br>&#125;<br>l++;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The patient will be dead.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-4"><a href="#E-4" class="headerlink" title="E"></a>E</h2><h3 id="Problem-E-矩形覆盖"><a href="#Problem-E-矩形覆盖" class="headerlink" title="Problem E. 矩形覆盖"></a>Problem E. 矩形覆盖</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　在平面上有 n 个点（n &lt; = 50），每个点用一对整数坐标表示。例如：当 n＝4 时，4个点的坐标分另为：p1（1，1），p2（2，2），p3（3，6），P4（0，7）。<br>　　这些点可以用 k 个矩形（1&lt; =k&lt; =4）全部覆盖，矩形的边平行于坐标轴。当 k=2 时，可用如图二的两个矩形 sl，s2 覆盖，s1，s2 面积和为 4。问题是当 n 个点坐标和 k 给出后，怎样才能使得覆盖所有点的 k 个矩形的面积之和为最小呢。约定：覆盖一个点的矩形面积为 0；覆盖平行于坐标轴直线上点的矩形面积也为0。各个矩形必须完全分开（边线与顶点也都不能重合）。</p><h4 id="输入数据-26"><a href="#输入数据-26" class="headerlink" title="输入数据"></a>输入数据</h4><p>格式为<br>n k<br>xl y1<br>x2 y2<br>… …<br>xn yn （0&lt; =xi,yi&lt; =500)</p><h4 id="输出数据-26"><a href="#输出数据-26" class="headerlink" title="输出数据"></a>输出数据</h4><p>一个整数，即满足条件的最小的矩形面积之和。</p><h4 id="样例输入-26"><a href="#样例输入-26" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-26"><a href="#样例输出-26" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> n, m;<span class="hljs-comment">//输入值</span><br><span class="hljs-keyword">int</span> SquareAns = <span class="hljs-number">10000000</span>;<span class="hljs-comment">//结果</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-keyword">int</span> x, y;<br>&#125;Node[<span class="hljs-number">510</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node2</span> &#123;</span><br><span class="hljs-keyword">int</span> l, r, u, d;<br><span class="hljs-keyword">bool</span> IsChoosed;<br>&#125;rectangle[<span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsNodeInRectangle</span><span class="hljs-params">(node2 a, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &lt;= a.r &amp;&amp; x &gt;= a.l &amp;&amp; y &lt;= a.u &amp;&amp; y &gt;= a.d)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsRectangleInRectangle</span><span class="hljs-params">(node2 a, node2 b)</span>  <span class="hljs-comment">//判断是否包含 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (IsNodeInRectangle(a, b.l, b.u)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//左上角   任何一个顶点在已知矩阵内就不合法 </span><br><span class="hljs-keyword">if</span> (IsNodeInRectangle(a, b.l, b.d)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//左下角 </span><br><span class="hljs-keyword">if</span> (IsNodeInRectangle(a, b.r, b.u)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//右上角 </span><br><span class="hljs-keyword">if</span> (IsNodeInRectangle(a, b.r, b.d)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//右下角 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i, j, square = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= m; i++)  <br>&#123;<br><span class="hljs-keyword">if</span> (rectangle[i].IsChoosed)  <br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (i != j &amp;&amp; rectangle[j].IsChoosed &amp;&amp; IsRectangleInRectangle(rectangle[i], rectangle[j]))  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br>&#125;<br>square += (rectangle[i].r - rectangle[i].l) * (rectangle[i].u - rectangle[i].d);  <br>&#125;<br><span class="hljs-keyword">if</span> (square &gt;= SquareAns)  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (t &gt; n)   <br>&#123;<br>SquareAns = square;<span class="hljs-comment">//满足条件更新SquareAns</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= m; i++)  <br>&#123;<br>node2 tmp = rectangle[i];<br><span class="hljs-keyword">if</span> (rectangle[i].IsChoosed == <span class="hljs-number">0</span>)  <br>&#123;<br>rectangle[i].IsChoosed = <span class="hljs-number">1</span>;<br>rectangle[i].l = rectangle[i].r = Node[t].x;<br>rectangle[i].u = rectangle[i].d = Node[t].y;<br>Search(t + <span class="hljs-number">1</span>);<br>rectangle[i] = tmp;   <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>rectangle[i].l = min(rectangle[i].l, Node[t].x);  <br>rectangle[i].r = max(rectangle[i].r, Node[t].x);<br>rectangle[i].u = max(rectangle[i].u, Node[t].y);<br>rectangle[i].d = min(rectangle[i].d, Node[t].y);<br>Search(t + <span class="hljs-number">1</span>);<br>rectangle[i] = tmp;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="hljs-comment">//输入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;Node[i].x, &amp;Node[i].y);<br>Search(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, SquareAns);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-2"><a href="#F-2" class="headerlink" title="F"></a>F</h2><h3 id="Problem-F-传染病防治"><a href="#Problem-F-传染病防治" class="headerlink" title="Problem F. 传染病防治"></a>Problem F. 传染病防治</h3><p>时间限制 1000 ms<br>内存限制 128 MB</p><h4 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h4><p>　　研究表明，这种传染病的传播具有两种很特殊的性质；<br>　　第一是它的传播途径是树型的，一个人X只可能被某个特定的人Y感染，只要Y不<br>得病，或者是XY之间的传播途径被切断，则X就不会得病。<br>　　第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一<br>代患者，而不会再传播给下一代。<br>　　这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群<br>的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。你的程序要针对给定的树，找出合适的切断顺序。　　</p><h4 id="输入数据-27"><a href="#输入数据-27" class="headerlink" title="输入数据"></a>输入数据</h4><p>　　输入格式的第一行是两个整数 n (1≤n≤300)n (1≤n≤300) 和 pp 。接下来 pp 行，每一行有两个整数 ii<br>和 j，j， 表示节点 ii 和 jj 间有边相连（意即，第 ii 人和第 jj 人之间有传播途径相连）。其中节点<br>11 是已经被感染的患者。</p><h4 id="输出数据-27"><a href="#输出数据-27" class="headerlink" title="输出数据"></a>输出数据</h4><p>只有一行，输出总共被感染的人数。</p><h4 id="样例输入-27"><a href="#样例输入-27" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-27"><a href="#样例输出-27" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 305</span><br><span class="hljs-keyword">int</span> n, m;<span class="hljs-comment">//总结点数和节点联系</span><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>[maxn][maxn] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0x7ffffff</span>;<br><span class="hljs-keyword">int</span> child[maxn];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tree[maxn], <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">int</span> res)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> son[maxn];<br><span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s; i++)<br>&#123;<br><span class="hljs-keyword">int</span>&amp; a = tree[i];<br><span class="hljs-keyword">if</span> (a == d)    <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[a][i])<br>son[++cur] = i;<br>&#125;<br><span class="hljs-keyword">if</span> (!cur)<br>ans = min(ans, res);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur; i++)<br><span class="hljs-keyword">if</span> (res + cur - <span class="hljs-number">1</span> &lt;= ans)<br>dfs(son, cur, son[i], res + cur - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">int</span> a, b;<br><span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br><span class="hljs-keyword">if</span> (a &gt; b)<br>swap(a, b);<br><span class="hljs-built_in">map</span>[a][b] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>)    child[++cur] = b;<span class="hljs-comment">//记录1(根)的子节点</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur; i++)<br>dfs(child, cur, child[i], cur);<br><span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|kruscul-路由算法模拟</title>
    <link href="/2021/12/24/cnet-python-kruscul/"/>
    <url>/2021/12/24/cnet-python-kruscul/</url>
    
    <content type="html"><![CDATA[<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>选择python为编程语言编写Dijsktra算法。dilisktra算法的基本思想是：</p><p><em>[1] 以出发点初始化点的集合A</em></p><p><em>[2] 以未在A集合中的所有点为B集合</em></p><p>*[3] 找出A集合的所有点（依次取A中的点）到B集合中所有点（对于某一个A中的点，依次对B中的点进行判断）直接相连的情况（记录相连边的权+A中当前匹配的点到v0（起点）点的最短路径），记录A中的端点。(<em>可简化)</em></p><p><em>[4] 比较路径后，找出B中可到达起点的最短路径（权最小）的点k，标记此路径。</em></p><p><em>[5] 将k从B中移去，加入A。</em></p><p><em>[6] 重复3-5直到B中无点。</em></p><p><em>[7] 每一个被标记的路径，都是起点到该点的最短路径。</em></p><p>  下图是我选择的用于测试的路由图：</p><p><img src="https://pic.imgdb.cn/item/61c59fc82ab3f51d911855be.jpg"></p><p><img src="https://pic.imgdb.cn/item/61c59fdc2ab3f51d91185c26.jpg"></p><p><img src="https://pic.imgdb.cn/item/61c59fe82ab3f51d91185ed5.jpg"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span>:</span><br>    <span class="hljs-comment"># 顶点类</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, vid, outList</span>):</span><br>        self.vid = vid  <span class="hljs-comment"># 出边</span><br>        self.outList = outList  <span class="hljs-comment"># 出边指向的顶点id的列表，也可以理解为邻接表</span><br>        self.know = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 默认为假</span><br>        self.dist = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)  <span class="hljs-comment"># s到该点的距离,默认为无穷大</span><br>        self.prev = <span class="hljs-number">0</span>  <span class="hljs-comment"># 上一个顶点的id，默认为0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, self.__class__):<br>            <span class="hljs-keyword">return</span> self.vid == other.vid<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__hash__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.vid)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">graph</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, vertex, edges, v_set</span>):</span><br>        self.vlist = vertex<br>        self.edges = edges<br>        self.vset = v_set<br><br>e_dict = <span class="hljs-built_in">dict</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_edge</span>(<span class="hljs-params">front, back, value</span>):</span><br>    e_dict[(front, back)] = value<br><br><span class="hljs-comment"># 创建顶点对象</span><br>v1 = Vertex(<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>])<br>v2 = Vertex(<span class="hljs-number">2</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>v3 = Vertex(<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>])<br>v4 = Vertex(<span class="hljs-number">4</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])<br>v5 = Vertex(<span class="hljs-number">5</span>, [<span class="hljs-number">7</span>])<br>v6 = Vertex(<span class="hljs-number">6</span>, [])<br>v7 = Vertex(<span class="hljs-number">7</span>, [<span class="hljs-number">6</span>])<br>add_edge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>add_edge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br>add_edge(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>add_edge(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>add_edge(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>)<br>add_edge(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>add_edge(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>)<br>add_edge(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)<br>add_edge(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>)<br>add_edge(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>)<br>add_edge(<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>)<br>add_edge(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>)<br>v_list = [<span class="hljs-literal">False</span>, v1, v2, v3, v4, v5, v6, v7]<br>vset = <span class="hljs-built_in">set</span>([v1, v2, v3, v4, v5, v6, v7])<br>g = graph(v_list, e_dict, vset)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_unknown_min</span>():</span>  <span class="hljs-comment"># 此函数则代替优先队列的出队操作</span><br>    the_min = <span class="hljs-number">0</span><br>    the_index = <span class="hljs-number">0</span><br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(g.vlist)):<br>        <span class="hljs-keyword">if</span> (g.vlist[i].know <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>):<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>):<br>                the_min = g.vlist[i].dist<br>                the_index = i<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> (g.vlist[i].dist &lt; the_min):<br>                    the_min = g.vlist[i].dist<br>                    the_index = i<br>            j += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 此时已经找到了未知的最小的元素是谁</span><br>    vset.remove(g.vlist[the_index])  <span class="hljs-comment"># 相当于执行出队操作</span><br>    <span class="hljs-keyword">return</span> g.vlist[the_index]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 将v1设为顶点</span><br>    v1.dist = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">len</span>(vset) != <span class="hljs-number">0</span>):<br>        v = get_unknown_min()<br>        print(v.vid, v.dist, v.outList)<br>        v.know = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> v.outList:  <span class="hljs-comment"># w为索引</span><br>            <span class="hljs-keyword">if</span> (g.vlist[w].know <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>):<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> (g.vlist[w].dist == <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)):<br>                g.vlist[w].dist = v.dist + g.edges[(v.vid, w)]<br>                g.vlist[w].prev = v.vid<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> ((v.dist + g.edges[(v.vid, w)]) &lt; g.vlist[w].dist):<br>                    g.vlist[w].dist = v.dist + g.edges[(v.vid, w)]<br>                    g.vlist[w].prev = v.vid<br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 原路径长更小，没有必要更新</span><br>                    <span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">real_get_traj</span>(<span class="hljs-params">start, index</span>):</span><br>    traj_list = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_traj</span>(<span class="hljs-params">index</span>):</span>  <span class="hljs-comment"># 参数是顶点在vlist中的索引</span><br>        <span class="hljs-keyword">if</span> (index == start):  <span class="hljs-comment"># 终点</span><br>            traj_list.append(index)<br>            print(traj_list[::-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 反转list</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> (g.vlist[index].dist == <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)):<br>            print(<span class="hljs-string">&#x27;从起点到该顶点根本没有路径&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>        traj_list.append(index)<br>        get_traj(g.vlist[index].prev)<br><br>    get_traj(index)<br>    print(<span class="hljs-string">&#x27;该最短路径的长度为&#x27;</span>, g.vlist[index].dist)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br>    real_get_traj(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>    real_get_traj(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|GoBackN的python实现</title>
    <link href="/2021/12/23/python-gbn/"/>
    <url>/2021/12/23/python-gbn/</url>
    
    <content type="html"><![CDATA[<h1 id="看起来非常简略的gbn的python实现"><a href="#看起来非常简略的gbn的python实现" class="headerlink" title="看起来非常简略的gbn的python实现"></a>看起来非常简略的gbn的python实现</h1><h2 id="GBN介绍"><a href="#GBN介绍" class="headerlink" title="GBN介绍"></a>GBN介绍</h2><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211223/123.png" alt="GBN的有限状态机模型"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> threading<br><br>LENGTH = <span class="hljs-number">3</span>  <span class="hljs-comment"># 数据总长度</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timeout</span>():</span><br>    print(<span class="hljs-string">&#x27;timeout!&#x27;</span>)<br><br>    timer.cancel()<br><br>    <span class="hljs-keyword">if</span> end_ack != LENGTH - <span class="hljs-number">1</span>:<br>        Resend(end_ack)<br>        timer1 = threading.Timer(<span class="hljs-number">5</span>, timeout)<br>        timer1.start()<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;数据全部发送成功&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Resend</span>(<span class="hljs-params">EndAck</span>):</span><br>    <span class="hljs-comment"># 发端重传ack</span><br>    print(<span class="hljs-string">&#x27;发端重传数据包%d--%d&#x27;</span> % (EndAck + <span class="hljs-number">1</span>, LENGTH - <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EndAck + <span class="hljs-number">1</span>, LENGTH):<br>        RSendData = <span class="hljs-built_in">bin</span>(a)<br>        print(<span class="hljs-string">&#x27;发端重传数据%d&#x27;</span> % a)<br>        ReceiveSocket.sendto(RSendData.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>))<br><br><br>timer = threading.Timer(<span class="hljs-number">5</span>, timeout)  <span class="hljs-comment"># 设置定时器</span><br><span class="hljs-comment"># 创建socket</span><br>ReceiveSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br><br><span class="hljs-comment"># 发送数据包0,1,2</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, LENGTH):<br>    sendData = <span class="hljs-built_in">bin</span>(data)<br>    print(<span class="hljs-string">&#x27;发端发送数据%d&#x27;</span> % data)<br>    ReceiveSocket.sendto(sendData.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>))<br><br>timer.start()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 接收收端发回的ack</span><br>    ack_seq = ReceiveSocket.recv(<span class="hljs-number">1024</span>)<br>    print(<span class="hljs-string">&quot;发端接收ack%d&quot;</span> % <span class="hljs-built_in">int</span>(ack_seq, <span class="hljs-number">2</span>))<br>    end_ack = <span class="hljs-number">0</span><br>    end_ack = <span class="hljs-built_in">max</span>(end_ack, <span class="hljs-built_in">int</span>(ack_seq, <span class="hljs-number">2</span>))<br><br></code></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> random<br><br>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>s.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>))<br>print(<span class="hljs-string">&quot;waiting for connection...&quot;</span>)<br>HadReceive = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    ReceiveData, ReceiveAddress = s.recvfrom(<span class="hljs-number">1024</span>)<br>    seq = <span class="hljs-built_in">int</span>(ReceiveData, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 用一个随机数来模拟丢包的情况，丢包概率为0.3</span><br>    <span class="hljs-keyword">if</span> random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &lt;= <span class="hljs-number">0.7</span>:<br>        <span class="hljs-comment"># 没有丢包，向发端发送ack</span><br>        <span class="hljs-keyword">if</span> seq == HadReceive + <span class="hljs-number">1</span>:<br>            HadReceive = HadReceive + <span class="hljs-number">1</span><br>        print(<span class="hljs-string">&#x27;收端发送ack%d&#x27;</span> % HadReceive)<br>        AckData = <span class="hljs-built_in">bin</span>(HadReceive)<br>        s.sendto(AckData.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), ReceiveAddress)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;数据包%d丢失！&#x27;</span> % seq)<br><br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在实际网络环境或模拟不可靠网络环境中测试和验证自己的可靠数据传输软件。我在Server端采用随机数的方式模拟不可靠的网络环境，随机数(0,1)小于0.3则模拟发生丢包。采用三个包的测试，测试五次。情况如下：</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211223/1.png"></p><p><strong>第一次：</strong></p><p><strong>发端发送数据0</strong></p><p><strong>发端发送数据1</strong></p><p><strong>发端发送数据2</strong></p><p><strong>发端接收ack0</strong></p><p><strong>发端接收ack1</strong></p><p><strong>发端接收ack2</strong></p><p><strong>数据全部发送成功</strong></p><p>​      <strong>第二次：</strong></p><p>​       <strong>发端发送数据0</strong></p><p><strong>发端发送数据1</strong></p><p><strong>发端发送数据2</strong></p><p><strong>发端接收ack0</strong></p><p><strong>timeout!</strong></p><p><strong>发端重传数据包1–2</strong></p><p><strong>发端重传数据1</strong></p><p><strong>发端重传数据2</strong></p><p><strong>发端接收ack1</strong></p><p><strong>发端接收ack2</strong></p><p><strong>timeout!</strong></p><p><strong>数据全部发送成功</strong></p><p>​      <strong>第三次：</strong></p><p><strong>发端发送数据0</strong></p><p><strong>发端发送数据1</strong></p><p><strong>发端发送数据2</strong></p><p><strong>发端接收ack0</strong></p><p><strong>发端接收ack0</strong></p><p><strong>timeout!</strong></p><p><strong>发端重传数据包1–2</strong></p><p><strong>发端重传数据1</strong></p><p><strong>发端重传数据2</strong></p><p><strong>发端接收ack1</strong></p><p><strong>发端接收ack2</strong></p><p><strong>timeout!</strong></p><p><strong>数据全部发送成功</strong></p><p><strong>第四次：</strong></p><p><strong>发端发送数据0</strong></p><p><strong>发端发送数据1</strong></p><p><strong>发端发送数据2</strong></p><p><strong>发端接收ack1</strong></p><p><strong>timeout!</strong></p><p><strong>发端重传数据包2–2</strong></p><p><strong>发端重传数据2</strong></p><p><strong>发端接收ack2</strong></p><p><strong>timeout!</strong></p><p><strong>数据全部发送成功</strong></p><p><strong>第五次：</strong></p><p><strong>发端发送数据0</strong></p><p><strong>发端发送数据1</strong></p><p><strong>发端发送数据2</strong></p><p><strong>发端接收ack0</strong></p><p><strong>timeout!</strong></p><p><strong>发端重传数据包1–2</strong></p><p><strong>发端重传数据1</strong></p><p><strong>发端重传数据2</strong></p><p><strong>发端接收ack1</strong></p><p><strong>发端接收ack2</strong></p><p><strong>timeout!</strong></p><p><strong>数据全部发送成功</strong></p><p><em>结论：</em></p><p>  <em>通过编写GBN算法，可以加强对课上的内容的理解，要注意的是在模拟丢包的情况下，要在接收端阻止ack的回传和在发送端发现ack超时的情况下进行该包的重发，要注意整个包的传送组织结构和顺序；进行模拟时，注意标注丢包及正确收到的flag值。同时可以通过多次实验来判断编写的算法是否满足GBN的要求。</em></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notebook|CNetNotebook||计算机网络自顶向下方法笔记</title>
    <link href="/2021/12/20/CNetNotebook/"/>
    <url>/2021/12/20/CNetNotebook/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><blockquote><p>按照《计算机网络自顶向下》的目录整理的相关笔记</p></blockquote><h1 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1. 计算机网络"></a>1. 计算机网络</h1><p>构成因特网的软件和硬件，根据分布式应用提供服务的联网基础设施来描述因特网</p><blockquote><p>世界范围内的计算机网络 因特网就是将端系统彼此互联</p></blockquote><h2 id="1-1-具体构成和描述"><a href="#1-1-具体构成和描述" class="headerlink" title="1.1 具体构成和描述"></a>1.1 具体构成和描述</h2><h3 id="端系统，分组Packet"><a href="#端系统，分组Packet" class="headerlink" title="端系统，分组Packet"></a>端系统，分组Packet</h3><ul><li>所有连接的设备，叫做主机或者端系统 HOST END SYSTEM</li><li>端系统通过通信链路communication link和分组交换机连接在一起</li><li>通信链路又不同类型的物理媒介组成，链路的传输速率为 BIT/S bps 比特每秒来计算</li><li>分组Packet，发送端将数据分段并为每段加上首部字母，这样的信息包叫做分组</li></ul><h3 id="分组交换机"><a href="#分组交换机" class="headerlink" title="分组交换机"></a>分组交换机</h3><ul><li>分组交换机，从交换机的一条入链路将分组转发并从出通信链路发出</li><li>分组交换机包括，路由器Router，链路层交换机Link-layer switch</li><li>链路层交换机用于接入网，路由器用于核心网</li></ul><h3 id="通信链路"><a href="#通信链路" class="headerlink" title="通信链路"></a>通信链路</h3><ul><li>从发送端到接收端系统，一个分组所经历的一系列的通信链路和分组交换机称为通过该网络的路径，Path Route</li><li>分组类似于运载货物的卡车，通信链路类似于公路，分组交换机类似于立交桥；</li><li>链路的速率，主要取决于分组交换机的转发能力： RM bps表示路由器在1S内可以完成R兆bit的转发</li></ul><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><ul><li>端系统由 ISP internet service provider 接入因特网</li><li>每个ISP是一个由多个分组交换机和多段通信链路组成的网络，各ISP为端系统提供了各种不同类型的网络接入</li><li>底层ISP通过国际的高层ISP互联，独立管理，运行着IP协议</li><li>调制解调？</li></ul><h3 id="协议-Protocol"><a href="#协议-Protocol" class="headerlink" title="协议 Protocol"></a>协议 Protocol</h3><ul><li><p>协议控制着网络中或因特网中的信息接受和发送，TCP和IP协议是最重要的两个协议，主协议统称为TCP/IP</p></li><li><p>TCP Transmission Control Protocol 控制传输协议</p></li><li><p>IP Internet Protocol 网际协议，IP协议定义了在路由器和端系统之间发送和接受的分组格式</p></li><li><p>背景，Internet Standard 由 InternetEngineering Task Force研发，其他组织也会制定标准，例如以太网标准，Wi-Fi标准</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-20210711134244371.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="20210711134244371"></p></li></ul><h3 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h3><ul><li>应用程序提供服务的基础设施：分布式应用程序 distributed application，application运行在端系统上，分组交换机并不关心作为数据源或者宿的应用程序</li><li>端系统提供应用程序编程接口，API，API规定了运行在一个端系统上的软件向另一个端系统的特定目的地软件交付数据的方式</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>因特网中涉及两个或者多个远程通信的实体活动都受到协议的制约，交换报文或者采取动作的实体是硬件或者软件</li><li>硬件实现的协议控制了在两块“接口卡”之间的“线上”比特流</li><li>端系统中，拥塞控制协议控制了发送方和接受方之间传输的分组Packet发送频率</li><li><strong>一个协议定义了两个或者多个通信实体之间的交换的报文格式和次序，以及报文发送和接受所采取的动作（一系列约定俗成的动作）</strong>；</li><li>构成，原理，工作方式；</li></ul><h2 id="1-2-网络边缘-边缘计算"><a href="#1-2-网络边缘-边缘计算" class="headerlink" title="1.2 网络边缘 - 边缘计算"></a>1.2 网络边缘 - 边缘计算</h2><ul><li>在因特网中处于边缘的系统，叫做端系统；</li><li><strong>主机 = 端系统 HOST = END SYSTEM</strong> ，主机被划分为两类：Clinet和Server。web服务器属于大型的数据中心Data Center，client通常为桌面级pc和手机等，server为更为强大的服务器</li></ul><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><ul><li><p>端系统和应用程序位于网络边缘，access network，接入网是将端系统接到其边缘路由器的物理链路（edge router）- 端系统接入边缘路由的链路</p></li><li><p>边缘路由器，<strong>是端系统到其他任何远程端系统路径上的第一台路由器</strong></p><blockquote><p>端系统 —(A)— 边缘路由（第一台路由） A:这样的一条链路称为接入网</p></blockquote></li><li><p>上下行速率由编码频率控制，频率越高，速度越高，家庭DSL，家庭接入同轴电缆</p></li><li><p>调制解调为外部设备</p></li><li><p>物理链路的搭建方式 </p></li></ul><h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><ul><li>数字用户线和电缆</li></ul><h3 id="以太网和wifi"><a href="#以太网和wifi" class="headerlink" title="以太网和wifi"></a>以太网和wifi</h3><ul><li>局域网将端系统连接到边缘路由，以太网为接入技术</li></ul><h3 id="广域无线接入"><a href="#广域无线接入" class="headerlink" title="广域无线接入"></a>广域无线接入</h3><ul><li>5G</li></ul><h3 id="物理媒介"><a href="#物理媒介" class="headerlink" title="物理媒介"></a>物理媒介</h3><ul><li>通过跨越物理媒介 Physical Medium传播电磁波活着光脉冲来发送bit；</li><li>物理媒介：引导型媒介，电磁波沿着物理媒介前进；非引导型媒介，电磁波沿着空气前进</li><li>双绞铜线、同轴电缆、光纤等</li></ul><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><ul><li>网络核心：<strong>由互联因特网端系统的分组交换机和链路构成的网状网络</strong>；</li><li><strong>分组交换机包括路由和链路层交换机</strong>；</li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li><p>端系统彼此交换报文（message），报文包含了协议设计者需要的所有的东西；</p></li><li><p>源端系统向目的端系统发送一个报文，“源”将长报文划分为较小的数组快，为“分组”Packet；</p></li><li><p>在源和目的之间，每个分组都通过通信链路的分组交换机（packet swith）传送；路由器和链路层交换机</p></li><li><p>每个分组以等于该链路最大传输速率的速度传输通过通信链路</p></li><li><p>一个Lbit的分组，链路速率为Rbit/s，则传输时间为L/R s</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230227175614947.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230227175614947"></p></li></ul><h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><ul><li>指交换机在开始向输出链路传输该分组的第一个bit前，必须已经接收到了整个分组；缓存分组比特，当路由器由输入链路接收完了整个分组后（此时花费L/R的时间），才开始向出链路传输（传输完成需要花费L/R），总延时为2L/R s</li><li>N条速录为R的链路，转发一个分组，d源到端 = N L/R</li></ul><h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><ul><li>每个分组交换机与多条线路相连，分组交换机有一个输出缓存，output buffer，output Queue；到达的分组的传输链路处于繁忙状态，传输其他分组，达分组会在“输出缓存”中等待；</li><li>时延，1. 存储转发时延，2. 排队时延，时延处于变化的状态，变化程度取决于网络中的拥塞程度</li><li>丢包，一个分组发现“输出缓存”已经被其他的等到传输的分组完成充满了，这时就会出现“分组丢包”，Packet lost，到达分组或者已经排队的分组之一会被丢弃；</li><li>分组达到率（每秒比特）超过了输出链路的速率，这些分组在通过链路传输前，在“链路输出缓存中排队”，在该路由器中将出现拥塞；</li></ul><h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><ul><li>因特网中，每个端系统具有IP地址，源向目的端发送分组，分组的首部都包含了IP地址；</li><li>路由器具有转发表，forwarding table，用于将目的地址（或者地址中的几段）映射为输出链路；</li><li>分组到达路由器，路由器检查分组地址，并用目的地址搜索转发表，发现出链路，则将该分组导向出链路；</li><li>转发表配置问题，路由选择协议 routing protocol，用于自动设置转发表；</li></ul><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>网络链路和交换机转发数据的两种基本方式：1. 电路交换 2. 分组交换；</li><li>电路交换需要提前预留报文要使用的资源，缓存链路传输速率等，传统的电话就是一种电路交换，连接期间预留了恒定的传输速率；</li><li>实现方式：频分复用 Frequency-Division Multiplexing， 时分复用Time-Division Multiplexing；</li><li>带宽 bandwidth：频段的宽度 80——100Mhz；</li><li>相关计算在P21</li></ul><h3 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h3><ul><li><p>分组交换的性能优于电路交换；</p><blockquote><p>例子：假设10个用户，某个用户产生1000个1000bit的分组，其他用户保持静默。每帧具有10个间隙且每个间隙保护1000bit的TDM电路交换情况下，活跃用户只能使用每帧中的一个间隙来传输数据，传完1000，000的bit数据需要10S时间，而分组交换的情况下，活跃用户能连续的以1Mbps的速率使用链路，完成数据的发送只需要1S；</p></blockquote></li><li><p>电路交换需要预先分配传输链路，使得已分配但是不需要的链路时间未被使用；分组交换按需分配链路使用，链路传世能力在所有用户之间逐分组共享；</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分组交换</td><td>① 加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输一份报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的机率及等待的时间也必然少得多。② 简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。③ 减少了出错机率和重发数据量。因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。④ 由于分组短小，更适用于采用优先级策略。</td><td>① 尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。② 分组交换中的每个分组都要加上源、目的地址和分组编号等信息，这将增大传送的信息量，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。③ 当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</td></tr><tr><td>电路交换</td><td>① 由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。② 通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。③ 双方通信时按发送顺序传送数据，不存在失序问题。④ 电路交换既适用于传输模拟信号，也适用于传输数字信号。⑤ 电路交换设备控制均较简单。</td><td>① 电路交换的平均连接建立时间对计算机通信来说偏长。② 电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用低。③ 电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。</td></tr></tbody></table></li></ul><h3 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h3><ul><li>十多个第一层ISP和数十万个底层ISP组成，ISP覆盖大洲，大洋，有些覆盖小的地理区域；底层与高层互联，高层彼此互联；</li></ul><h2 id="1-4-分组交换网中的时延、丢包、吞吐量"><a href="#1-4-分组交换网中的时延、丢包、吞吐量" class="headerlink" title="1.4 分组交换网中的时延、丢包、吞吐量"></a>1.4 分组交换网中的时延、丢包、吞吐量</h2><ul><li><p>时延：节点处理时延，排队时延，传输时延，传播时延，节点总时延；</p></li><li><p>处理时延，检查分组首部需要的处理时延，用来决定将该分组导向何处</p></li><li><p>排队时延，分组在链路上等待传输是排队的时延（“输出缓存” output buffer）</p></li><li><p>传输时延/发送时延，<strong>数据长度/信道带宽</strong> 先到先服务，仅当所有已到达分组被传输后，才能传输刚到达的分组，链路速率R bps，R个bit每秒，时延=分组比特/链路速率，毫秒微秒量级</p></li><li><p>传播时延，<strong>信道长度/传播速率</strong>，是分组从一个路由器传输到另一个路由器，所在的链路的传播需要的时间，它和链路的物理长度及物理媒介有关，和链路的速率以及分组长度无关；</p></li><li><p>区别：传输时延是由路由器将整个分组推出所需要的时间，这里的速率完全取决于路由器的转发能力，R Mbps表示路由器在1S内可以完成R兆bit的转发，速率也和编码频率有关； 传播时延表示分组或者数据比特在物理或者媒介中传播所需要的时间；</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228151743340.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228151743340"></p></li></ul><h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><ul><li>排队时延取决于流量到达该队列的速率，链路传输的速率和流量到达的性质；</li><li>R表示链路的传输速率，就是从队列中推出bit的速率 bps</li><li>假设a表示分组达到队列的速率，L表示分组的比特数量，则La bps表示比特到达队列的平均速率，La/R为 流量强度 traffic intensity； 流量强度不能大于 1</li></ul><h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h3><ul><li>随着”流量强度” 接近1，分组交换机或路由器将会对已经满了的队列，丢弃新的分组，Drop，该分组将会丢失Lost；</li><li>一个结点的性能是根据分组的丢失概率来度量的；</li></ul><h3 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h3><ul><li>N-1台路由器 总时延 = N （主机和路由器上的处理时延 + 链路传播时延 + 传输时延L/R</li><li>traceroute软件做时延分析</li></ul><h3 id="端系统、应用程序、其他时延"><a href="#端系统、应用程序、其他时延" class="headerlink" title="端系统、应用程序、其他时延"></a>端系统、应用程序、其他时延</h3><ul><li>对于某些协议，端系统application处理的延时；</li></ul><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li><strong>单位时间通过某个接口的数据量</strong></li><li>瞬时吞吐量：端系统接受到该文件的速率 bps，例如下载文件的的速率显示</li><li>平均吞吐量：F比特的文件，主机接收到所以的bit用了T秒时间，平均吞吐量为F/T</li><li>有些Application中吞吐量比时延更重要；</li><li>Rs表示服务器与路由器之间的链路速率，Rc表示路由器和客户端之间的链路速率，对于Server来说他的吞入量为min{Rs, Rc}，这里的吞入量为瓶颈链路速率，bottleneck link，当然这里的吞吐量还需要考虑分组层次和传输协议的问题；</li><li>吞吐量取决于数据流过链路的传输速率；在没有其他条件干扰时，吞吐量近似等于源和目的之间的最小传输速率；</li></ul><h3 id="bandwidth-带宽"><a href="#bandwidth-带宽" class="headerlink" title="bandwidth 带宽"></a>bandwidth 带宽</h3><ul><li><p><strong>网络设备所能支持的最高速度</strong>，理想的极限传输速率</p></li><li><p>Bandwidth (signal processing) or analog bandwidth, frequency bandwidth or radio bandwidth, a measure of the width of a range of frequencies, measured in hertz</p></li><li><p>Bandwidth (computing), the rate of data transfer, bit rate or throughput, measured in bits per second (bit/s)</p></li><li><p>Spectral linewidth, the width of an atomic or molecular spectral line, measured in hertz</p></li><li><p>对于信号处理中，bandwidth表示当前信号的频段宽度，例如模拟信号或者数字信号的”频率范围“ hz为单位</p></li><li><p>对于计算机网路链路，带宽为当前最大传输速率，没秒钟链路能够传输或处理的比特，bit/s为单位，注意在电路交换中带宽表示的是频率范围；</p></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><ul><li>*<em>时延带宽积(bit)=传播时延(s)<em>带宽(bit/s)</em></em></li><li>时延带宽积是描述一个链路中，此时此刻的bit数量<h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3></li><li>从发送方发送数据开始，到发送方收到接收方的确认（接收方收到后立即发送确认），总共经历的时延</li><li>RTT包括：*<em>2</em>传播时延、末端处理时间**<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3></li><li>信道利用率=有数据通过时间/总共时间</li><li>网络利用率=信道利用率加权平均值</li><li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228152734030.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228152734030"><h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h2></li></ul><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><ul><li>网络以分层的方式组织协议，某层会向上一层提供服务，就是服务模型；</li><li>应用层协议在端系统中以软件方式实现，物理层和数据链路层则复杂处理跨越链路的通信，通常实现在给定的接口卡中；网络层则有软硬件的混合；</li></ul><h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><ul><li>各层所有的协议被称为协议栈 protocol stack</li><li>因特网的协议栈由5层组成 <strong>1. 物理层 2. 数据链路层 3. 网络层 4. 传输层 5. 应用层</strong></li><li><strong>应用层</strong>：<strong>用户与网络的界面</strong>，网络应用程序之间定义的协议留存的分层，分布在多个端系统上，一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，位于应用层的信息分组称为报文（message）<strong>FTP、SMTP、HTTP</strong></li><li>表示层：数据格式的变换、数据的解密加密、数据的压缩和恢复</li><li>会话层：像表示层提供建立连接并且有序的传输数据</li><li><strong>传输层</strong>、运输层：用于传输应用层报文，主要有TCP和UDP，TCP向他的应用程序提供了面向连接的服务。TCP也将长报文划分为短报文，提供拥塞机制；TCP源代码；UDP无连接，不提供服务的服务，运输分组可以称为<strong>报文段 segment</strong>，端到端的通信。<strong>可靠传输、差错控制、流量控制、复用分用功能</strong>   主要协议： <strong>TCP、UDP</strong></li><li><strong>网络层</strong>：分组单位是<strong>数据报 datagram</strong>，将数据报 datagram 的网络层分组从一台主机移动到另一台主机；源主机中TCP或者UDP运输协议向网络层递交运输层报文段segment和目的地址，网络层IP协议定义了数据报中的各个字段和端系统及路由器如何作用这些字段，IP协议和路由选择协议，IP协议连接了硬件和软件层；</li><li><strong>数据链路层</strong>：分组单位是<strong>帧 Frame</strong>，网络层从源到目的之间经过路由器路由数据报，将分组从一个结点移动到另一个结点，必须“依靠数据链路层的服务”，网络层将数据报下传给链路层，链路层沿着链路将数据传递给下个结点，下个结点链路层又将数据报上报给了网络层；链路层提供的服务取决于链路层的协议。链路层的分组为”帧“Frame，以太网，Wi-Fi，DOCsis；</li><li><strong>物理层</strong>：<strong>在物理媒体上实现比特流的传输</strong>，物理层的任务是将链路层中的帧中的一个一个bit从一个结点移动到下一个结点，物理层协议于链路相关，也与物理介质相关，例如同轴电缆卡，光纤；</li></ul><h3 id="OSI、TCP-IP与五层参考模型"><a href="#OSI、TCP-IP与五层参考模型" class="headerlink" title="OSI、TCP/IP与五层参考模型"></a>OSI、TCP/IP与五层参考模型</h3><ul><li><p>ISO国际标准化组织提出OSI，开发系统互联模型，理论模型，服务、协议、接口。</p></li><li><p>与之相对的TCP/IP参考模型有四层</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228144700581.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228144700581"></p></li><li><p>应用层 表示层 会话层 传输层 网络层 链路层 物理层</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-1-1Z1241445324H.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="OSI 七层网络模型和 TCP/IP 四层网络模型的对比"></p><ul><li>五层参考模型</li></ul><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228145106620.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228145106620"></p></li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote><p>应用层 报文 mesasge 传输层 报文段 segment = message + header 网络层 数据报 datagram = segment + header<br>链路层 帧 frame = datagram + header 物理层</p></blockquote><ul><li>application-layer message — transport-layer segment — network-layer datagram — link-layer frame</li><li>链路层交换机实现第一层和第二层，路由器实现第一层到第三层，路由器能够实现IP协议，链路交换机不能，链路层交换机能够实现第二层地址，以太网地址；网络边缘的端系统可以实现一到五层，将复杂性较高的结构放在边缘；</li><li>封装 （encapsulation）：在发送端，一个应用层报文（application-layer message） — 应用层报文+传输层首部=运输层报文段（transport-layer segment） — 网络层增加了源和目的端地址等网络数据报的首部，产生了网络层数据报 — 链路层增加链路层首部信息并创建链路层帧</li><li>每个分层：首部字段+有效载荷字段（header + payload field），有效载荷为上一层分组</li></ul><h2 id="1-6-攻击的网络"><a href="#1-6-攻击的网络" class="headerlink" title="1.6 攻击的网络"></a>1.6 攻击的网络</h2><h2 id="1-7-历史，分组交换的发展，专用网络和互联网络，因特网的发展"><a href="#1-7-历史，分组交换的发展，专用网络和互联网络，因特网的发展" class="headerlink" title="1.7 历史，分组交换的发展，专用网络和互联网络，因特网的发展"></a>1.7 历史，分组交换的发展，专用网络和互联网络，因特网的发展</h2><hr><hr><h1 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h1><h2 id="2-1-网路应用程序体系结构"><a href="#2-1-网路应用程序体系结构" class="headerlink" title="2.1 网路应用程序体系结构"></a>2.1 网路应用程序体系结构</h2><ul><li>客户 - 服务器体系结构 client-server architecture 如Web应用，客户之间并不直接通信</li><li>P2P结构， per to per architecture，对于服务器有最小依赖，“对等方”在主机间直接通信，p2p特性，自扩展性；</li></ul><h3 id="2-1-1进程通信"><a href="#2-1-1进程通信" class="headerlink" title="2.1.1进程通信"></a>2.1.1进程通信</h3><ul><li>进行通信的实际是进程</li><li>运行在不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信；</li><li>进程通过<strong>“套接字” socket的软件接口</strong>向网络发送报文和从网络接受报文，Socket下面使用运输层TCP或UDP协议，套接字也称为“网络程序编程接口”，套接字对运输层仅仅能 1.选择运输层协议 2.设定运输层参数如最大缓存，最大报文长度等。<strong>套接字是应用层和运输层之间的接口</strong></li><li>开发者选择了运输层协议，应用程序就建立在由该协议提供的运输层服务至上；</li><li>进程寻址，“IP地址”来标识主机地址，“端口号Port”来表示主机中的进程，从而定位到通信的进程；</li></ul><h3 id="2-1-2可供应用程序使用的运输服务"><a href="#2-1-2可供应用程序使用的运输服务" class="headerlink" title="2.1.2可供应用程序使用的运输服务"></a>2.1.2可供应用程序使用的运输服务</h3><ul><li><strong>可靠数据传输</strong>：分组交换机的缓存溢出导致的分组丢失，可靠数据传输（reliable data transfer），运输层协议向应用程序提供进程到进程的可靠数据传输</li><li><strong>吞吐量</strong>：两个进程之间，可用吞吐量就是发送进程到接收进程交付比特的速率，会话会共享沿着网络路径的带宽，可用吞吐量会随着时间波动，运输层协议能够以某种特定的速率提供确保的可用吞吐量；具有吞吐量要求的应用程序为”宽铭感应用”，“弹性应用”是或多或少的利用可用吞吐量；</li><li><strong>定时</strong>：运输层协议保障提供数据传输的总时延小于一个特定值；</li><li><strong>安全性</strong>：运输层协议保障加密进程发送的数据</li></ul><h3 id="2-1-3运输服务"><a href="#2-1-3运输服务" class="headerlink" title="2.1.3运输服务"></a>2.1.3运输服务</h3><ul><li>TCP/IP网络中两个运输层协议，TCP和UDP</li></ul><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>TCP服务模型包括<strong>面向连接服务和可靠数据传输服务</strong></li><li>面向连接服务：连接的三次握手，握手完成后，TCP连接就在两个进程的套接字之间建立了。四次分手</li><li>可靠的数据传输服务：TCP，会无差错、按照顺序交付所发送的数据，当App的一端将字节流传进套接字是，能够依靠TCP将相同的字节流交付给接收方的套接字，没有字节的丢失和冗余；</li><li><strong>拥塞控制机制，在网络发送拥塞时，TCP的拥塞控制机制会抑制发送进程；或使每个连接达到公平共享带宽的目的；</strong></li><li>TCP UDP 不提供任何加密机制，安全套接字，SSL secure sockets layer；SSL是对TCP运输协议的加强，这样的<strong>安全强化是在应用层实现的（很容易）</strong>；SSL有独立的一套SOCKET API</li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul><li>轻量级运输协议，提供最小服务，UDP是无连接的，提供一种不可靠的数据传输服务；</li><li>UDP不保证报文到达接收方进程，到达的数据有可能是乱序到达；</li><li><strong>UDP没用拥塞机制，发送端可以使用UDP选定任何速率向下层注入数据；</strong></li></ul><h4 id="运输协议不提供的服务"><a href="#运输协议不提供的服务" class="headerlink" title="运输协议不提供的服务"></a>运输协议不提供的服务</h4><ul><li>不能提供定时和带宽保证；</li><li>网络语音，以UDP作为主要运输协议，TCP作为当UDP流量被防火墙阻挡后的备选方案；</li></ul><h3 id="2-1-4应用层协议"><a href="#2-1-4应用层协议" class="headerlink" title="2.1.4应用层协议"></a>2.1.4应用层协议</h3><ul><li>应用层协议定义了</li></ul><blockquote><p>交换的报文类型，如请求报文和响应报文 报文语法 字段含义 进程何时及如何发送报文，报文的响应规则</p></blockquote><p>HTTP 超文本传输协议，公共域的RFC SMTP 简单邮件传输协议</p><h2 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2 Web和HTTP"></a>2.2 Web和HTTP</h2><h3 id="2-2-1HTTP"><a href="#2-2-1HTTP" class="headerlink" title="2.2.1HTTP"></a>2.2.1HTTP</h3><ul><li>一个客户程序和一个服务器程序，运行在不同的端系统中，通过交换HTTP报文进行会话；HTTP定义了报文格式，已经报文的交换方式；</li><li>术语</li></ul><blockquote><p>Web页面 webpage 对象 object</p></blockquote><ul><li>HTTP定义了web客户端向服务器请求页面的方式；</li><li>HTTP使用<strong>TCP</strong>运输层服务，客户向他的套接字发送http报文，并从套接字接收响应报文；</li><li>HTTP服务每次发送报文，都会将报文通过套接字交给TCP服务，<strong>HTTP协议不用担心数据的丢失和乱序问题，分层体系结构的最大优点</strong>；</li><li>HTTP服务器不保存每次客户访问的信息，是一个“无状态协议“ stateless protocol</li></ul><h4 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h4><ul><li>非持续连接：每个请求是经过每次的单独的TCP连接发送，每次发送报文新建TCP连接</li><li>持续连接：所有的请求以同一个的TCP连接发送；</li><li><strong>HTTP既能使用非持续，也能使用持续连接</strong>，默认方式是使用持续连接，可以配置成非持续</li></ul><h4 id="非持续连接的HTTP"><a href="#非持续连接的HTTP" class="headerlink" title="非持续连接的HTTP"></a>非持续连接的HTTP</h4><ul><li>每个TCP连接只传输一个请求报文和一个响应报文；</li><li>往返时间： Round-Trip Time RTT，一个短分组从客服到服务器，再返回客户端所花费的时间；</li><li>RTT：分组传播时延，分组传输时延、排队时延、处理时延</li><li><strong>三次握手</strong>，客户向服务器发起一个TCP连接，客户向服务器发送一个小的TCP报文段，服务器用一个小TCP段作出确认和响应，最后客户向服务器返回确认（此时客户结合这部分发送一个http请求报文，一旦该报文被服务器接收，服务器就在该TCP连接上发送HTML文件）；</li><li><strong>采用非持续连接经受双倍的RTT交付延迟，第一个RTT用于创建TCP，第二个RTT用于请求和接受对象。值得注意的是，三次握手的第三次同时在请求。</strong></li></ul><h4 id="持续连接的HTTP"><a href="#持续连接的HTTP" class="headerlink" title="持续连接的HTTP"></a>持续连接的HTTP</h4><ul><li>非持续中，每个TCP都需要在服务器中分配TCP的缓冲区和保持TCP变量，给服务器带来较大负担，而且每个对象都需要经受两倍的RTT交付时延；一个RTT用来创建TCP连接，一个用来请求和接收对象；</li><li>HTTP的默认模式是使用带流水线的持续连接，服务器在发送响应后保持TCP连接打开，同一个客户和服务器的后续请求和响应报文通过相同的TCP连接进行；服务器可以以流水线的方式一个接一个的发出对象的请求，不必等待回答；超时后HTTP服务器就会关闭连接；</li></ul><h3 id="2-2-2HTTP报文格式"><a href="#2-2-2HTTP报文格式" class="headerlink" title="2.2.2HTTP报文格式"></a>2.2.2HTTP报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ul><li><p>使用ASCII编写，最少一行，最后一行附加一个换行符；</p></li><li><ol><li>请求行，后续叫做首部行 【方法字段】【URL统一资源定位】【HTTP版本】</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- 方法字段： <span class="hljs-keyword">GET</span> POST HEAD PUT <span class="hljs-keyword">DELETE</span><br>- 首部行：HOST指明了对象所在主机，Web代理高速缓存所要求的<br>- <span class="hljs-keyword">Connection</span>：<span class="hljs-keyword">close</span> 要求服务器在发送完被请求对象后关闭这条连接<br>- <span class="hljs-keyword">User</span>-agent：用户代理，不同的agent表示不同的设备或者浏览器。Mozilla标准<br></code></pre></td></tr></table></figure></li><li><p>绝大部分使用GET方法</p></li><li><p>POST报文仍然可以向服务器请求对象，表单的请求报文不是必须使用POST方法；</p></li><li><p>HEAD方法和GET方法类似，但是服务器不返回请求对象；</p></li><li><p>PUT方法多用于上传路径的服务</p></li><li><p>DETELE方法允许用户删除服务器上的对象</p></li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul><li><p>状态行status line，协议版本+状态码+状态信息</p></li><li><p>首部行 header line</p></li><li><p><strong>实体行 entity body</strong>   实体部分是报文的主要部分，包含了对象本身；</p></li><li><p>Connection：close 表示告诉客户，发送完报文后服务器将关闭TCP连接</p></li><li><p>Date：响应报文的时间</p></li><li><p>Server：Server类型和版本</p></li><li><p>Last—Modified：对象的最后修改时间</p></li><li><p>Content-Length：被发送对象的字节数</p></li><li><p>Content-Type：内容类型</p></li><li><p>常见短语和状态码<br><code>200 OK</code>：请求成功</p><p><code>301 Moved Permanently</code>：请求的对象被永久转移了</p><p><code>400 Bad request </code>：请求不能被服务器理解 </p><p><code>404 Not Found</code>：请求的对象不在服务器</p><p><code>505 HTTP Version Not Supported</code>服务器不支持请求报文使用的http协议版本</p></li></ul><h3 id="2-2-3cookie"><a href="#2-2-3cookie" class="headerlink" title="2.2.3cookie"></a>2.2.3cookie</h3><ul><li><p>HTTP服务是无状态的，cookie允许站点对用户进行跟踪；包含以下四个部分</p></li><li><pre><code>- HTTP响应报文中包含一个cookie首部行- HTTP请求报文中的一个cookie首部行- 用户系统中保留一个cookie文件- web站点后端数据库<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Set-cookie首部识别码可以确定一个用户，在站点上每次访问的路径，跟踪用户的活动；<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**过程：在用户首次访问网站时，网站产生一个唯一识别码并保存在web站点后端数据库，接下来Web服务器把包含该识别码的报文传给用户，用户的浏览器收到报文后，将该识别码记录在浏览器的cookie文件中，这条记录包含服务器的主机名和识别码。当用户后面再次浏览该网站时，用户查询到目标服务器和识别码对应，就将识别码加入到http请求报文中。这样网站就可以跟踪用户的活动。**</span><br><br><span class="hljs-section">### 2.2.4Web缓存</span><br><br><span class="hljs-bullet">-</span> Web cache &amp; proxy server 也叫代理服务器<br><span class="hljs-bullet">-</span> 代表初始的web服务器来满足http请求的网络实体<br><span class="hljs-bullet">-</span> 有自己的磁盘空间用来存储最近保存过的对象的副本<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**过程：浏览器创建一个到web cache的tcp连接，并向web cache发送HTTP请求，Web缓存对对象做检查，有则直接返回给浏览器，无则与对象的初始服务器建立TCP连接。Web缓存器在这个TCP连接上发送HTTP请求，初始服务器Web cache进行响应，接收到对象的web cache会在本地存储一份副本，并向浏览器发送对象，web cache和浏览器也是TCP连接；**</span><br><span class="hljs-bullet">-</span> 通常由ISP提供，比如一所大学可能在校园网上安装一台WEB缓存器。<br><span class="hljs-bullet">-</span> 内容分发网络 Content Distribution Network CDN，CDN在地理位置上安装了很多缓存器，使得大量流量本地化<br><br><span class="hljs-section">### 2.2.5条件GET方法</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**过程：web缓存器在收到报文后记录一个时间，在下次向服务器请求时带上这个时间并询问服务器这个页面是否在这个时间之后被修改，若修改，则发送新的报文给缓存器，若无，则回复 `304 not modified`**</span><br><span class="hljs-bullet">-</span> 请求使用 GET method<br><span class="hljs-bullet">-</span> header line： “If-Modified-Since：”<br><span class="hljs-section">## 2.3 电子邮件</span><br><span class="hljs-section">### 2.3.1SMTP</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**过程：发送方调用邮件代理程序并提供接收方的邮件地址然后指示用户代理发送该报文，用户代理将报文发送给`发送方的邮件服务器`，在那里报文进入报文队列中，运行在发送方的邮件服务器的SMTP客户端发现了这个队列中的报文，（25号端口）创建一个到`接收方的邮件服务器`的TCP连接，在经过一些初始的SMTP握手后，SMTP客户通过该TCP连接发送报文，接收方的邮件服务器SMTP服务器端接收到了该报文，邮件服务器将报文放入接收方的邮箱之中。接收方调用用户代理阅读该报文。**</span><br><span class="hljs-bullet">-</span> 需要值得注意的是只有<span class="hljs-code">`发送方的邮件服务器`</span>和<span class="hljs-code">`接收方的邮件服务器`</span>，SMTP一般不使用中间服务器。如果接收方的邮件服务器没有开机，那么发送方的邮件服务器在后续会进行多次尝试。<br><br><span class="hljs-section">### 2.3.2与HTTP对比</span><br><br>|      | 相同                         | 不同                                                         |<br>| ---- | ---------------------------- | ------------------------------------------------------------ |<br>| HTTP | 都是一台主机向另一台发送信息 | 1、HTTP是一个拉协议；2、HTTP没有7比特ASCLL字符限制；3、HTTP把每个对象封装到一个报文中 |<br>| SMTP | 都是一台主机向另一台发送信息 | 1、SMTP是一个推协议；2、SMTP只能发送7比特的ASCLL字符；3、SMTP把所有对象封装到一个报文中 |<br><br><span class="hljs-section">### 2.3.3邮件报文格式</span><br><br></code></pre></td></tr></table></figure>From：alice@crepes.frTo:bob@hamburger.eduSubject:Searching for the meaning of life<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br><span class="hljs-comment">### 2.3.4邮件访问协议</span><br><br>- 之前我们默认是需要登录去访问邮件服务器的，而今天，邮件访问使用了一种<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>`客户-服务器体系结构`<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，即用户使用桌面客户端来阅读电子邮件。<br>- 如果邮件服务器运行到用户设备上，那么保持持续在线是一件很困难的事。所以通常用户运行代理程序，而他访问总是开机的共享服务器上的邮件服务器。但是这又引发了一个问题：<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>接收方是如何通过本地的代理程序来阅读程序的呢？（SMTP是一个推协议，所以无法使用SMTP来得到）<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- 上面这个问题的解决用到了一些特殊的邮件协议：<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>`POP3`和`IMAP`以及`HTTP`<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>  - POP3：<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>过程分为三个阶段，第一阶段特许，服务器鉴别用户；第二阶段事务处理，用户代理取回报文，同时还可以选择对报文进行删除标记等；第三阶段更新阶段，即客户发出了quit命令之后，断开POP3连接，服务器删除被标记的报文<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>  - IMAP：<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>POP3无法为用户创建远程文件夹，也无法指派文件进入文件夹，所以IMAP应运而生，IMAP可以在邮件服务器接收邮件时与收件夹自动关联，后续在用户代理操作时可以指派文件夹，同时IMAP还可以选择只读取报文的首部，就可以避免一些下载不必要的大邮件。<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br><span class="hljs-comment">## 2.4 DNS，域名解析服务</span><br><br>工作机理：浏览器向用户DNS客户端发送主机名（gethostbyname），DNS客户端从缓存中查找，找不到向网络发送一个DNS查询报文，DNS请求和回答报文都是用UDP数据报经过53端口发送，DNS客户端将映射结果返回给调用的程序；<br><br><span class="hljs-comment">### 2.4.1DNS提供的服务</span><br><br>- 从主机名到ip地址转换目录服务。<br><br>- DNS通常是其他应用层协议所使用的，它提供如下服务：<br><br>  - 从主机名到ip地址转换目录服务<br><br>  - 主机别名<br><br>  - 邮件服务器别名<br><br>  - 负载分配<br><br><span class="hljs-comment">### 2.4.2DNS工作机理概述</span><br><span class="hljs-comment">#### 分布式、层次数据库</span><br><br>- 没有一台DNS服务器能够囊括全球域名，因此需要大量的DNS服务器，大致来说有三种：根DNS服务器，顶级域DNS服务器（tld），权威DNS服务器，还有一类： 本地DNS服务器，不过严格来说他不处于这个层次中<br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>过程：客户访问一个网址，首先向他的本地DNS服务器查询，本地DNS服务器将该报文转发到根DNS服务器，根DNS服务器再向本地DNS服务器返回负责这部分顶级域的tld-DNS服务器的ip地址列表，本地DNS服务器再向tld发送查询报文，tld再发送相关权威DNS服务器的ip地址，最后本地服务器再向权威服务器的ip发送报文，最后权威DNS服务器给出要访问的网址的ip地址，最后终于得到了ip地址<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><span class="hljs-comment">#### DNS缓存</span><br><br>- DNS服务器会缓存IP/主机名的信息，在查询过程中的一级DNS服务器存储了这个ip就可以直接找到。<br><br><span class="hljs-comment">### 2.4.3DNS记录 DNS报文</span><br><br>- 资源记录：NAME|<span class="hljs-string">VALUE</span>|<span class="hljs-string">TYPE</span>|TTL<br>  - NAME和VALUE的值主要取决于TYPE<br>  - TYPE分为A（主机名-ip）、NS（域如auswitz.top-知道如何获取该域主机ip的权威服务器）、CNAME（规范主机名-别名）、MX（邮件服务器的别名-规范主机名）<br>  - TTL：该记录的生存时间<br><span class="hljs-comment">### 2.4.4DNS脆弱性</span><br><br>- 针对DNS的DDos分布式拒绝服务带宽洪泛攻击，将大量分组发送到DNS服务器，以至于合法的分组得不到回答<br>- 但是，总而言之，DNS已经显示了惊人的鲁棒性，迄今为止，没有一个攻击有效的妨碍了DNS服务。<br><br><br><span class="hljs-comment">## 2.5 P2P</span><br><br><span class="hljs-comment">## 2.7 TCP 套接字编程</span><br><br>- 服务器端应用和客户端应用使用统一的RFC标准，就能实现交互操作；<br>- 选择TCP还是UDP，TCP面向连接并提供两个端系统之间数据流动的可靠字节流通道，UDP无连接，发送独立的分组，不对交付进行任何保证；<br><br><span class="hljs-comment">### UDP套接字</span><br><br>- 发送进程为分组附上目的地址，为主机的ip地址和目的地套接字的端口号，发送方的原地址也是由套接字端口号和源主机的IP地址组成，该源地址也要附着在分组之上；将源地址附在分组上的操作并不是由UDP应用程序代码所为，而是由底层操作系统自动完成；<br>- PG108<br><br><span class="hljs-comment">### TCP套接字</span><br><br>- 1. UDP，TCP服务器在客户端开始发出接触前，必须已经准备好，服务器进程必须处于运行的状态；<br>     - 客户进程创建一个TCP套接字，向服务器进程发起一个TCP连接，客户端套接字知道拿过来主机的IP和端口号，生成套接字后客户发起一个三次握手创建与服务器的TCP连接，发生在运输层的三次握手对客户和服务器是完全透明的；<br>     - 欢迎套接字：客户与服务器通信的起始接触点，欢迎套接字处进行三次握手<br>     - 连接套接字：服务器侧为每个客户通信生成的套接字，连接套接字表示连接成功<br>- PG112<br><br><span class="hljs-comment"># 3. 运输层</span><br><br><span class="hljs-comment">## 3.1 运输层服务</span><br><br>- 运输层协议为运行在不同主机之间的应用程序提供了<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>逻辑通信<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>的功能 Logic communication<br>- 运输层从应用程序接受报文并转化成<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>”报文段“<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，实现方式是将报文划分成较小的块，并为每块加上一个运输层首部以生成运输层报文段；<br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>报文分块<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> – <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>添加首部<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> – <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>生成报文段<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> – 运输层将这些报文传递给网络层，网络层将其封装成数据报分组并向目的地发送；<br>- 路由器只会作用于网络层字段，不会检查封装在该数据报的运输层报文段和字段；运输层则处理接受到的报文段，使该报文的数据为接受应用程序使用；<br><br><span class="hljs-comment">### 运输层和网络层的关系</span><br><br>- 网络层提供了主机之间的逻辑通信<br>- 运输层提供了进程之间的逻辑通信<br>- 运输层协议只在端系统中工作；对报文在网络核心中如何移动不做任何规定；<br>- 不同的运输层协议为应用程序提供不同的服务模型<br>- 底层的网络层协议不可靠，分组交换机会发送分组丢失等，但是运输层协议仍然能够为应用程式提供可靠的数据传输；<br><br><span class="hljs-comment">### 概述</span><br><br>- 运输层分组：报文段 segment TCP：报文段 UDP：数据报 网络层：数据报<br>- IP的服务模型：<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>尽力为交付服务<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> best-effort delivery service，尽最大努力交付，但是不做任何确保，不确保报文段的交付、不确保报文段的按序交付、不确保报文段中的数据的完整性<br>- IP：不可靠服务<br>- TCP UDP的基本责任是：将两个端系统之间的IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务；<br>- 主机间的交付扩展到进程间的交付： <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>运输层的多路复用<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> 与 <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>多路分解<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> （transport-layer multiplexing, demultiplexing)<br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>进程和进程的数据交付<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>和<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>差错检查<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>是两种最低限度的运输层服务<br><br><span class="hljs-comment">### TCP概述</span><br><br>- 可靠数据传输 reliable data transfer<br>- 流量控制<br>- 序号<br>- 确认<br>- 定时器<br>- TCP能够正确的、按序的将数据从发送进程交付给接收进程<br>- 拥塞控制 congestion control<br>- 提供给调用它的应用程序的一种服务，也是提供给因特网的一种服务，防止任何一条TCP连接用过多的流量来淹没主机之间的链路和设备交换<br>- TCP调节流量速率来让每个连接平均的共享链路带宽<br>- UDP的流量是不可调节的<br><br><span class="hljs-comment">## 3.2 多路复用与多路分解</span><br><br><span class="hljs-comment">### 多路分解</span><br><br>- 接收主机的运输层将数据交付给套接字，<br>- 每一个套接字都有一个唯一的标识符<br>- 主机将到达运输层的报文段定向到适当的套接字，运输层会检查报文字段，标识处接收套接字，进而将报文定向到套接字；<br>- 多路分解：将运输层报文段的数据交付给正确的套接字<br>- 多路复用：源主机将不同套接字数据封装上首部信息从而生成报文段，将报文段传递到网络<br><br><span class="hljs-comment">### 工作方式</span><br><br>- 要求： 1. 套接字有唯一的标识符 2. 每个报文段有特殊的字段来指示该报文要交付给的套接字<br>- 源端口号字段+目的端口号字段 一个端口好是16bit （source port number field + destination port number field)<br>- 每个套接字都能分配一个端口号<br>  - 当报文到达主机时，运输层检查报文中的<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>目的端口号<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> ，并将报文段定向到相应的套接字<br><br><span class="hljs-comment">### 端口</span><br><br>- 0~1023的端口号为 well-known port number 保留给已知应用<br>- 0~65535<br>- 16bit<br><br><span class="hljs-comment">### 无连接的多路复用和多路分解</span><br><br>- 对于UDP协议，运输层会创建运输层报文段，包括源端口，目的端口和数据<br>- 接收主机的UDP服务会设别目的端口，并将数据交给对应的套接字<br>- UDP的套接字：一个二元组来标识，保护一个目的IP和一个目的端口号<br>- UDP使用二元组中的两个值，来将报文定向到相应的套接字上<br>- 来自不同源地址的UDP报文，只要目的地址和目的IP相同，那么报文就会到达同一个套接字<br>- UDP套接字中包含源ip地址和源端口号，用于接收端进行回包的时候从报文中提取源地址和源端口作为目的地址和目的端口<br><br><span class="hljs-comment">### 面向连接的多路复用和多路分解</span><br><br>- TCP套接字是一个<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>4元组<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> 源地址 源端口 目的地址 目的端口<br>- 到达主机的报文，TCP服务会是使用全部4个值来将报文段定向到相应的套接字<br>- 4元组中任意一个不同，报文都会到达不同的套接字<br>- 服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程相联系，并由4元组来标识套接字；当一个TCP报文到达主机时，所有4个字段都将会用来定向报文到相应的套接字；<br><br><span class="hljs-comment">### Web服务器与TCP</span><br><br>- Web服务器具有多个新连接套接字的新线程，任意时间内会有不同标识的套接字连接到相同的进程中；线程管理的套接字可以接收或者发送HTTP请求和响应<br><br><span class="hljs-comment">## 3.3 无连接运输-TCP</span><br><br>- 运输层必须最低限度的提供一种 复用/分解 的服务<br>- UDP协议的功能：多路复用，多路分解，差错检测<br>- UDP发送方和接收方之间没有握手，UDP是无连接的<br>- 选择UDP的原因依据：<br>  - 时间和数据：不希望过分的延迟发送报文，且能容忍一定的数据丢失、<br>  - 无需建立连接：UDP无连接时延<br>  - 无连接状态：UDP无需维护连接状态，无需跟踪参数，无拥塞控制机制<br>  - 分组首部开销小：源端口、目的端口、校验和、数据大小<br>- RIP路由表选择协议使用UDP，更新的丢失会被最新的更新替代，可以容忍数据丢失<br>- SNMP简单网络控制协议，对于处于重压下的网络，对于可靠的且有拥塞控制的协议无法完成对网络的实时管理；<br>- UDP中缺乏拥塞控制，会导致UDP的接收方和发送方之间的高丢包率，并有可能会挤垮了TCP会话；<br>- 使用UDP也可以实现可靠的数据传输，需要在应用程序自身建立可靠性机制，在应用程序中进行开发，可以不依赖TCP的服务和拥塞控制；<br><br><span class="hljs-comment">### UDP的报文段结构</span><br><br>- 首部包含四个字段每个字段由2个字节组成，每个字节是8个bit<br>- 每个字段包含16个比特Bit<br><br>|<span class="hljs-string"> 16bit                     </span>|<span class="hljs-string"> 16bit                                           </span>|<br>|<span class="hljs-string"> ------------------------- </span>|<span class="hljs-string"> ----------------------------------------------- </span>|<br>|<span class="hljs-string"> 源端口                    </span>|<span class="hljs-string"> 目的端口                                        </span>|<br>|<span class="hljs-string"> UDP报文首部和数据的总长度 </span>|<span class="hljs-string"> 校验和，对UDP报文段中的所有16比特字的和进行反码 </span>|<br>|<span class="hljs-string"> 报文数据                  </span>|<span class="hljs-string"> 报文数据                                        </span>|<br><br><span class="hljs-comment">### UDP校验和</span><br><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>校验和的值<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>： 发送方的所有16比特字的和，进行反码运算，且相加溢出需要回卷<br>- 接收方将所有16比特字及校验和相加，无差错的情况下相加结果全为1<br>- 链路层路由协议及以太网协议也都提供了差错检测，传输层的差错检测存在的意义就是因为不能保证每一条链路都使用了差错检测的协议；这既是无法确保链路的可靠性；<br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>端到端原则<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>： 必须基于端到端实现功能，因为相比在较高级别实现这些功能的代价，在较低级别上实现可以是冗余或者几乎无价值的；<br>- UDP对检验出的受损报文段：1. 直接丢弃 2. 交给套接字并向应用程序发出<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>警告<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br><span class="hljs-comment">## 3.4 可靠数据传输原理</span><br><br>- 可靠数据传输为上层实体提供的服务抽象： <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>数据可以通过一条可靠的信道传输<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- 传输数据不会受损例如数据bit从0变为1或者从1变为0，且数据按照发送顺序交付<br>- TCP的下层不可靠，TCP在不可靠的IP协议端到端网络层上实验可靠数据传输，且<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>可靠数据传输协议<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>下层可能是一条或者多条物理链路<br><br><span class="hljs-comment">### 可靠传输</span><br><br>- 发送方：rdt_send()函数， 数据接收：rdt_rcv()，数据交付高层服务：deliver_data() 交换控制分组；udt_send()<br>- 单向数据传输 unidirectional data transfer<br>- 双向数据传输 bidirectional data transfer 全双工数据传<br><br><span class="hljs-comment">### 3.4.1 构造可靠数据传输</span><br><br><span class="hljs-comment">#### 1. rdt1.0</span><br><br>&gt; 有限状态机 Finite-state Machine，FSM<br>&gt;<br>&gt; 有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。<br>&gt;<br>&gt; [有限状态机-外部文档](https://www.jianshu.com/p/5eb45c64f3e3)<br><br>|<span class="hljs-string"> rdt1.0 - 发送端    </span>|<span class="hljs-string"> &#123;action&#125;                                  </span>|<br>|<span class="hljs-string"> ------------------ </span>|<span class="hljs-string"> ----------------------------------------- </span>|<br>|<span class="hljs-string"> 等待上次应用的调用 </span>|<span class="hljs-string"> rdt_send(data)                            </span>|<br>|<span class="hljs-string">                    </span>|<span class="hljs-string"> packet = make_pkt(data); udt_send(packet) </span>|<br><br>|<span class="hljs-string"> rdt1.0 - 接收端    </span>|<span class="hljs-string"> &#123;action&#125;                                  </span>|<br>|<span class="hljs-string"> ------------------ </span>|<span class="hljs-string"> ----------------------------------------- </span>|<br>|<span class="hljs-string"> 等待来自下层的调用 </span>|<span class="hljs-string"> rdt_rev(packet)                           </span>|<br>|<span class="hljs-string">                    </span>|<span class="hljs-string"> extract(packet, data); deliver_data(data) </span>|<br><br>- 发送方和接收方都有各自的FSM，上图FSM各自只有一个状态<br>- 发送端：rdt的发送端只通过rdt_send(data)事件接收来自较高层的数据，然后生成一个包含数据的分组，并将分组发送到信道中；事件由上层应用的过程调用产生；<br><br>&gt; 过程调用和系统调用<br><br>- 接收端：rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，然后从分组中取出数据extract，并将数据上传给高层deliver；rdt_rcv事件由较为底层的协议过程调用产生<br><br><span class="hljs-comment">#### 2. rdt2.0</span><br><br>- 肯定确认 (positive acknowledgement) 否定确认 (negative acknowledgment)，控制报文使得接收方可以让发送发知道哪些内容被正确接收，哪些内容接收有误需要自动请求重传；<br><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>自动重传协议<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> Automatic Repeat reQuest ARQ<br><br>- 自动重传协议<br><br>   <br><br>  需要的支持<br><br>  - 差错检测，分组<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>检验和<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>字段<br>  - 接收方反馈，“肯定确认” ACK，“否定确认” NAK<br>  - 重传，接收方收到有差错的分组时，发送方收到反馈后将进行重传<br><br>|<span class="hljs-string"> 发送方               </span>|<span class="hljs-string">                                                              </span>|<br>|<span class="hljs-string"> -------------------- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> STATE                </span>|<span class="hljs-string"> ACTION                                                       </span>|<br>|<span class="hljs-string"> 等待来自上层的调用   </span>|<span class="hljs-string"> rdt_send(data)                                               </span>|<br>|<span class="hljs-string">                      </span>|<span class="hljs-string"> sndpkt = make_pkt(date, checksum); udt_send(sndpkt)          </span>|<br>|<span class="hljs-string"> 等待ACK或NAK         </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; isNAK(rcvpkt); udt_send(sndpkt) #接收到NAK分组并重发sndpkt分组 </span>|<br>|<span class="hljs-string"> ⬆ # 返回等待调用状态 </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt) # 接收到ACK确认分组，不再做其他操作，状态返回“等待过程调用” </span>|<br><br>|<span class="hljs-string"> 接收方                         </span>|<span class="hljs-string">                                                              </span>|<br>|<span class="hljs-string"> ------------------------------ </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> STATE                          </span>|<span class="hljs-string"> ACTION                                                       </span>|<br>|<span class="hljs-string"> 等待来自下层的调用（过程调用） </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt)                           </span>|<br>|<span class="hljs-string">                                </span>|<span class="hljs-string"> sndpkt = make_pkt(NAK); udt_send(sndpkt) #检验后发现分组数据受损，给发送方回发NAK分组 </span>|<br>|<span class="hljs-string">                                </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt)                        </span>|<br>|<span class="hljs-string">                                </span>|<span class="hljs-string"> extract(rcvpkt, data); deliver_data(data); sndpkt = make_pkt(ACK); udt_send(sndpkt) #检验后发现分组数据无损，将数据提交给高层应用后，给发送方回发ACK分组 </span>|<br><br>- 发送方有两种状态，等待上层过程调用状态和等待ACK或者NAK状态，<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>当发送方处于<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>行rdt_send()调用，发送方只有收到确认ACK分组后，才会发送新的数据<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- 这样的等待协议为 <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>停等<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> 协议 stop-and-wait<br>- 接收方的FSM只有一个状态，当分组到达时，接收方检验分组是否受损，要么回答一个ACK要么回答一个NAK；<br>- 解决ACK或者NAK分组受损导致发送方无法明确分组是否被正确接收的方法是：引入新字段，<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>分组编号<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，就是发送数据的分组<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>序号 sequence number<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br><span class="hljs-comment">#### rdt 2.1 2.2</span><br><br>- 新增，接收方收到受损分组发送否定确认，发送方收到受损返回分组则重新发送分组<br>- 接收方包括一个由ACK报文所确认的分组序号，make_pkt()中包含ACK 0 ACK1<br>- 发送方必须检查接收到的确认分组中的序号<br><br><span class="hljs-comment">#### 3. rdt3.0 具有比特差错的丢包信道的可靠数据传输</span><br><br>&gt; 检测丢包和丢包后的action<br><br>- 当前已经包含的： 检验和、序号、ACK分组、重传机制<br>- 发送方等待超时，如果等待足够长的时间没有收到接收方的响应，便对该分组进行重传<br>- 等待时间： 发送方与接收方之间的一个往返时延（传输时延，传播时延，排队时延） + 接收方处理一个分组的时间， 实践中，发送方明智的选择一个确定的时间值作为等待时间<br>- 如果一个分组经历了比较长的时延，但是并没有丢包，发送方也会重传该分组，这样的情况下接收方就会 <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>“冗余数据分组<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，分组序号可以解决冗余数据分组的问题<br>- 过度延时或者分组丢失都会导致重传<br>- 倒计数定时器 countdown timer， 用于给定时间过期后，中断发送方；<br><br>|<span class="hljs-string"> 发送方               </span>|<span class="hljs-string">                                                              </span>|<br>|<span class="hljs-string"> -------------------- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> 等待来自上层的调用 0 </span>|<span class="hljs-string"> rdt_send(data)                                               </span>|<br>|<span class="hljs-string">                      </span>|<span class="hljs-string"> sndpkt = make_pkt(0, data, checksum); udt_send(sndpkt); start_timer; </span>|<br>|<span class="hljs-string"> 等待ACK 0            </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) \</span>|<span class="hljs-string">\</span>|<span class="hljs-string"> isACK(rcvpkt, 1)) # 等待响应分组，1. 下层过程调用rdt_rcv 2. 如果检验后数据受损 或 获得的确认包序号不是当前0序号 则保持当前状态 </span>|<br>|<span class="hljs-string">                      </span>|<span class="hljs-string"> timeout; udt_send(sndpkt); start_timer; #如果出现超时(数据丢失或者网络延时)，则重新发送序号为0的分组，并启动新的timer，发送后依然保持当前等待0响应的状态 </span>|<br>|<span class="hljs-string"> ⬇ 到下一状态         </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 0)); stop_timer; #当在该状态下收到响应分组，调用rdt_rcv函数后，检验数据无损，且当前响应分组的序号与当前等待状态序号一致，此处为0，则进入下一状态 </span>|<br>|<span class="hljs-string"> 等待来自上层的调用1  </span>|<span class="hljs-string"> rdt_send(data)                                               </span>|<br>|<span class="hljs-string">                      </span>|<span class="hljs-string"> sndpkt = make_pkt(1, data, checksum); udt_send(sndpkt); start_timer; </span>|<br>|<span class="hljs-string"> 等待ACK 1            </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) \</span>|<span class="hljs-string">\</span>|<span class="hljs-string"> isACK(rcvpkt, 0)) # 等待响应分组，1. 下层过程调用rdt_rcv 2. 如果检验后数据受损 或 获得的确认包序号不是当前1序号 则保持当前状态, 继续等待正确响应分组 </span>|<br>|<span class="hljs-string">                      </span>|<span class="hljs-string"> timeout; udt_send(sndpkt); start_timer; #如果出现超时(数据丢失或者网络延时)，则重新发送序号为1的分组，并启动新的timer，发送后依然保持当前等待0响应的状态 </span>|<br>|<span class="hljs-string"> ⬇ 到下一状态         </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 1); stop_timer; #当在该状态下收到响应分组，调用rdt_rcv函数后，检验数据无损，且当前响应分组的序号与当前等待状态序号一致，此处为1，则进入下一状态 </span>|<br>|<span class="hljs-string">                      </span>|<span class="hljs-string">                                                              </span>|<br><br>|<span class="hljs-string"> 接收方                          </span>|<span class="hljs-string">                                                              </span>|<br>|<span class="hljs-string"> ------------------------------- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> STATE                           </span>|<span class="hljs-string"> ACTION                                                       </span>|<br>|<span class="hljs-string"> 等待来自下层的调用0（过程调用） </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) \</span>|<span class="hljs-string">\</span>|<span class="hljs-string"> has_seq1(rcvpkt)) ; sndpkt = make_pkt(NAK, 0, checksum); udt_send(sndpkt) #下层调用，检验数据是否受损, 检测分组序号，当数据受损或序号为1时，继续保持该状态等待下层调用0, 并发送0的NCK响应 </span>|<br>|<span class="hljs-string"> ⬇ 到下一状态                    </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &amp;&amp; has_seq0(rcvpkt); extract(rcvpkt, data); deliver_data(data); sndpkt = make_pkt(ACK, 0, checksum); udt_send(sndpkt) # 接收分组，解出数据，校验数据无损且分组序号为0，则将数据提交给上层应用，并向发送方响应序号为0的ACK，当前状态转移到等待下层调用序号1 </span>|<br>|<span class="hljs-string"> 等待来自下层的调用1（过程调用） </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) \</span>|<span class="hljs-string">\</span>|<span class="hljs-string"> has_seq0(rcvpkt)) ; sndpkt = make_pkt(NCK, 1, checksum); udt_send(sndpkt) #下层调用，检验数据是否受损, 检测分组序号，当数据受损或序号为1时，继续保持该状态等待下层调用0, 并发送0的NCK响应 </span>|<br>|<span class="hljs-string"> 返回初始状态                    </span>|<span class="hljs-string"> rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &amp;&amp; has_seq1(rcvpkt); extract(rcvpkt, data); deliver_data(data); sndpkt = make_pkt(ACK, 1, checksum); udt_send(sndpkt) # 接收分组，解出数据，校验数据无损且分组序号为1，则将数据提交给上层应用，并向发送方响应序号为1的ACK，返回初始状态 </span>|<br><br><span class="hljs-comment">### 3.4.2 流水线可靠传输协议</span><br><br>- rdt3.0的停等协议有着非常低的发送利用率 每个分组到达接收方后返回ACK的延时为一个RTT<br><br>- 解决方法：不使用停等协议等方式运行，允许发送方发送多个分组而无需等待确认；<br><br>- 流水线 pipelining<br><br>   <br><br>  带来的影响<br><br>  - 必须增加序号范围，每个分组必须有一个唯一的序号<br>  - 协议的发送方和接收方两端必须<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>缓存多个分组<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>  - 序号范围和缓冲 取决于数据传输协议如何处理丢失、损坏、延时过大的分组；流水线的差错恢复的方法： <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>回退N步 （Go-back-N GBN)<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>选择重传 (Seletive Repeat, SR)<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br><span class="hljs-comment">### 3.4.3 回退N步</span><br><br>&gt; |<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<br>&gt; |<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<br>&gt; |<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<br>&gt;<br>&gt; base nextseqnum<br>&gt;<br>&gt; —–窗口长度—-<br>&gt;<br>&gt; 窗口到nextseqnum前是已发送但未确认分组，nextseqnum后是未发送分组<br><br>- 已经被发送但是还没有确认的分组的许可序号范围可以被看成一个在序号范围内的N的<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>窗口<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>；<br>- N为<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>窗口长度 window size<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>， GBN协议也被称为<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>滑动窗口协议 sliding window protocol<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- 运输层分组首部：分组序号，szie为k比特，则序号范围=[0, 2^k -1]，序号使用模2^k运算；<br>- TCP的序号按照字节流中的字节计数<br>- GBN响应的三种类型<br>  - 上层调用 rdt_send()，当前窗口未满时（判断是否已经有N个已经发送但是未被确认的分组），产生一个分组并发送，并更新变量；如果窗口已满，发送方需要将数据返回给上层，上层会稍等再试；<br>  - 收到一个ACK，在GBN中，对序号为n的分组采用<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>累计确认 cumulative acknowledgment<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> 的方式，表明接收方已经正确接收n及n在内的所有的分组<br>  - 超时事件，出现丢失和时延过长分组的情况下，发送方重传所有已经发送但是还未确认的分组，也就是重传当前窗口中的所有分组；<br>- GBN中，接收方，序号为n的分组被<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>按序正确接收<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>则接收方发送一个ACK，其他情况下接收方丢弃分组，并为最近按序接收的分组重新发送ACK；<br>- 如果序号为k的分组已经交付给上层，则证明k-1个分组都已经交付<br>- 因为数据必须按序交付，如果接收方等待分组n但是却收到了分组n+1，接收方会直接丢弃分组n+1，因为如果不丢弃会导致发送方重传，因此只需丢弃n+1，优点是接收缓存简单，接收方无需缓存失序分组；<br>- 发送方需要维护窗口的上下边界及nextseqnum在该窗口的位置，接收需要维护下一个按序接收的分组序号；且保存在expectedseqnum;<br><br>&gt; 基于事件编程 event-based programming<br><br><span class="hljs-comment">### 3.4.4 选择重传</span><br><br>- 选择重传 SR 协议通过让发送方仅重传那些它怀疑在接收方出错（丢失、受损）的分组<br><br>&gt; |<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<br>&gt; |<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<br>&gt; |<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<br>&gt;<br>&gt; base nextseqnum<br>&gt;<br>&gt; —–窗口长度—-<br>&gt;<br>&gt; nextseqnum前包含 已经确认的分组 和 已发送未确认分组<br>&gt;<br>&gt; nextseqnum之后是 未发送分组<br><br>- 发送方和接收方的序号空间<br>- 发送发<br>  - 从上层接收数据，序号位于窗口内，将数据打包发送，如果不在窗口内，则将数据缓存或者将数据返回给上层；<br>  - 超时，每个分组有自己的逻辑定时器，超时发生后只能发送一个分组，使用一个硬件定时器模拟多个逻辑定时器；<br>  - 收到ACK，发送方收到ACK且判断在窗口内时，SR发送方将分组标记为“已接收”；当收到的序号等于send_base时，则base向前移动到<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>“最小序号的未确认处”<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，如果序号为窗口内未发送分组，则发送这些分组<br>- 接收方，将确认每个正确接收的分组，失序的分组将被缓存直到所有丢失分组都被收到为止；所有分组被收到后，将分组按序交付给上层；<br>  - 序号在[rcv_base, rcv_base + n -1]内的分组被正确接收，收到的分组落在接收方的窗口内，选择ACK被会送给发送方；分组以前没有收到过，则缓存；分组序号为base序号，则触发该分组前的连续分组交付给上层；窗口向前移动并按照编号交付分组；<br>  - 序号在[rcv_base, rcv_base + n -1]内的分组被正确接收，此时，必须产生一个AC<br>- 接收方会重新确认（ACK）已经收到过的序号小于当前窗口base的分组；<br>- SR中接收方和发送方的窗口不总是一致的；<br><br>![img](file:///C:/%5CUsers%5Cteddy%5COneDrive%5C2020%5CCS-Learning-curve%5C%E7%BD%91%E7%BB%9C%5C3.4.4%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0.png)<br><br>- 对于SR协议，窗口的长度必须小于或者等于序号空间大小的一半；<br>- Page153，对于发送方窗口序号为0，1，2，3，0，1，2 窗口长度为3，接收方无法判断序号为0的分组是重传还是第五个分组的初次传输；此处序号空间是4，但是窗口size为3，导致协议无法工作；<br><br><span class="hljs-comment">##### 可靠数据传输机制总结</span><br><br>|<span class="hljs-string"> 机制                        </span>|<span class="hljs-string"> 说明                                                         </span>|<br>|<span class="hljs-string"> --------------------------- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> 检验和 checksum             </span>|<span class="hljs-string"> 检验分组数据bit是否受损                                      </span>|<br>|<span class="hljs-string"> 定时器timer                 </span>|<span class="hljs-string"> 用于分组丢失的情况下的超时重传，分组丢失或者ACK回复在链路中丢失，或者因为链路时延导致超时；重传可能会导致接收方的分组冗余 </span>|<br>|<span class="hljs-string"> 序号 sequence number        </span>|<span class="hljs-string"> 对从发送方到接收方的数据按序编号，发送方可以按序交付数据给接收方，接收方通过序号检测数据是否受损或者丢失并向发送方回复；接收方还可以通过序号检测是否收到了冗余副本； </span>|<br>|<span class="hljs-string"> 确认 ACK                    </span>|<span class="hljs-string"> 接收方用于确认一个分组或者一组分组是否正确接收，携带被确认的分组的序号或者多个序号，确认可以逐个也可以是积累的； </span>|<br>|<span class="hljs-string"> 否定确认 NAK                </span>|<span class="hljs-string"> 接收方用于回复发送方某一个序号的分组未正确接收，例如数据顺坏，携带被否定确认的分组的序号； </span>|<br>|<span class="hljs-string"> 窗口、流水线 sliding window </span>|<span class="hljs-string"> 发送方通过一次发送多个分组，不断更新窗口位置，接收方每次收到base序号的分组后，则将缓存中的分组交付给上层；窗口长度根据接收方 接收 和 缓存 报文的能力、网络拥塞程度来配置； </span>|<br><br>- 通过假定一个分组在网络中“存活”时间不会超过一个最大的固定时间（最大分组寿命3分钟），来确保一个序号的分组都已经不再网络中，则可以重复使用该序号；对序号的重复使用会导致冗余分组和当前分组的混乱，所有重复使用序号的前提是必须保证网络中不再包含该序号的分组；<br><br><span class="hljs-comment">## 3.5 面向连接的运输：TCP</span><br><br><span class="hljs-comment">### 3.5.1 TCP连接</span><br><br>- 发送预备报文段，进行握手，以建立确保数据传输的参数，进而建立<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>“连接”<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>；<br>- TCP/IP Transmission Control Protocol/Internet Protocol，建立之初为单一的实体，后来将其分开为TCP和IP协议，存在于网络的不同层次<br>- 连接状态完全保留在两个端系统中，中间网络不会维持TCP连接，中间网络对TCP连接完全“视而不见”<br>- 全双工服务（full-duplex service）；进程A和进程B可以同时发送数据；<br>- 点对点（point-to-point），单个发送方和单个接收方；<br><br><span class="hljs-comment">##### 连接的建立</span><br><br>- 客服进程、服务器进程<br><br>&gt; clientSocket.connect((serverName, serverport))<br><br>- 两个进程之间发送了3个报文段，前两个不承载“有效载荷”，建立的过程被称为三次握手（three-way handshake）<br>- 客户进程通过套接字将数据传递给TCP服务，TCP将数据引导到发送缓存（send buffer）；TCP从缓存中取出数据放入报文段并发送，取出数据受限于<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>最大报文段长度 MSS 1460byte<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，最大链路层帧长度<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>最大传输单元 MTU<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- MSS指的是TCP报文段中的数据的最大长度；<br>- TCP为每一块数据加上<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>TCP首部<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，从而形成多个TCP<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>报文段 TCP segment<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，报文段被传给网络层，IP协议的服务将其封装在IP数据报中；然后IP数据报被发送到网络中；TCP的接收端有自己的接收缓存；<br>- 组成：一台主机上的缓存、变量、与进程连接的套接字，另一台主机上的缓存、变量、与进程连接的套接字<br><br><span class="hljs-comment">### 3.5.2 报文段 结构</span><br><br>- 32bit<br><br>|<span class="hljs-string">                            32bit                             </span>|<br>|<span class="hljs-string"> :----------------------------------------------------------: </span>|<br>|<span class="hljs-string">                    源端口号 \</span>|<span class="hljs-string"> 目的端口号                    </span>|<br>|<span class="hljs-string">                             序号                             </span>|<br>|<span class="hljs-string">                            确认号                            </span>|<br>|<span class="hljs-string"> 首部长度\</span>|<span class="hljs-string">保留未用\</span>|<span class="hljs-string">URG\</span>|<span class="hljs-string">ACK\</span>|<span class="hljs-string">PSH\</span>|<span class="hljs-string">RST\</span>|<span class="hljs-string">SYN\</span>|<span class="hljs-string">FIN \</span>|<span class="hljs-string"> 接收窗口 </span>|<br>|<span class="hljs-string">                    检验和 \</span>|<span class="hljs-string"> 紧急数据指针                    </span>|<br>|<span class="hljs-string">                             选项                             </span>|<br>|<span class="hljs-string">                             数据                             </span>|<br><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>MSS限制了报文段数据字段的最大长度<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，对于较大的文件，TCP会将文件划分成若干块进行处理<br>- 和UDP相同，首部包括了源和目的端口、检验和字段（checksum）<br>- 32bit的序号字段，32bit的确认号字段<br>- 16bit的接收窗口字段，用于流量控制，用于指定接收方愿意接收的字节数量<br>- 4bit的首部长度字段，典型长度为20byte<br>- 选项字段，可变长度用于协商MSS<br>- 6bit的标志字段 flag field<br>  - ACK 用于确认报文段是否被成功接收，1 bit<br>  - RST、SYN、FIN用于连接的建立和拆除，1bit<br>  - PSH表示，是否立即将数据交付给上层，1bit<br>  - URG表示，报文段中是否 ”存在“ 被发送端的上层实体置为”紧急“的数据<br>  - 紧急数据指针字段用于指出紧急数据，存在时TCP会通知上层服务；16bit<br><br><span class="hljs-comment">##### 序号和确认号</span><br><br>- 一个报文段的序号（sequence number for a segment）是报文段的首字节的字节流编号；<br><br>&gt; 例如MSS为1000，一个500 000字节的文件，TCP每个报文段的序号应该是：0，1000， 2000…<br><br>- <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>确认号<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>： 接收方填充进报文段的<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>确认号<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>为接收方等待发送方发送的数据流中下一个的字节；<br>- TCP只确认该数据流中至第一个丢失字节位置的字节，<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>TCP为 累计确认\<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> （cumulative acknowledgement）<br>- 报文失序到达的处理选择：<br>  - 接收方将直接丢弃失序报文<br>  - 接收方保留失序的字节，并等待缺少的自己以填补间隔。实践中采用此方法<br>- TCP连接双方可以随机的选择初始序号，目的是防止同端口的先前已经断开的连接但是有报文段存在与网络中，可能会导致这个报文段被认为是新连接的报文段；<br><br>&gt; Telnet 远程登录的应用层协议，运行在TCP之上的交互式应用；Telnet和ssh的区别是没有加密<br>&gt;<br>&gt; 回显：echo back<br>&gt;<br>&gt; telnet用例，Page160<br><br>- 捎带：服务器对来自客户数据的确认被装载在一个承载了服务器到客户数据的报文段中；<br>- TCP数据为空时，也会存在序号字段；<br><br><span class="hljs-comment">### 3.5.3 往返时间与超时</span><br><br>- TCP使用超时重传机制<br>- TCP使用 SampleRTT来预估 一次的RTT时间，TCP会维持一个平均值<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>EstimateRTT<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，当获取到新的SampleRTT，计算加权平均值的方式如下：<br><br></code></pre></td></tr></table></figure>EstimatedRTT = （1- α）· EstimatedRTT + α · SampleRTTDevRTT = (1-β) · DevRTT + β · |SampleRTT - EstimatedRTT|<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&gt; α参考值为0.125，β推荐值为0.25<br>&gt;<br>&gt; 指数加权移动平均<br>&gt;<br>&gt; 定义了DevRTT为SampleRTT到EstimatedRTT的偏离程度<br><br>- 考虑到SampleRTT的波动，超时重传的时间间隔<br><br></code></pre></td></tr></table></figure>TimeoutInterval = EstimatedRTT + 4 · DevRTT<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> 初始推荐为<span class="hljs-number">1</span>秒</span><br><br><span class="ruby"><span class="hljs-comment">##### 实践原则</span></span><br><br><span class="ruby">- TCP的快速重传，收到对一个报文段的<span class="hljs-number">3</span>个冗余ACK就可作为对**后面**报文段的一个隐式的NAK，从而在超时触发前就对报文段重传；</span><br><span class="ruby">- TCP使用流水线，发送方在任意时刻都有多个已经发出但是还未被确认的报文段存在；</span><br><br><span class="ruby"><span class="hljs-comment">### 3.5.4 可靠数据传输</span></span><br><br><span class="ruby">- 回顾：IP协议的不可靠，数据报可能会溢出路由器输出缓存，数据报达到目的地址乱序，数据报在传输过程中比特可能损坏；</span><br><span class="ruby">- TCP是在IP的不可靠服务上创建的可靠数据传输服务（reliable data transfer service）</span><br><span class="ruby">- 确保：进程从接收缓存中读取的数据流是无损坏、无间隔、非冗余、按序</span><br><br><span class="ruby"><span class="hljs-comment">#### 单一重传定时器简化描述</span></span><br><br><span class="ruby">- 事件一，TCP从应用层接收数据，并将数据进行封装，报文段被发送给IP时，TCP启动**定时器**，这里定时器的timeout时间是前面提到的TimeoutInterval，由EstimatedRTT和DevRTT计算得出</span><br><span class="ruby">- 事件二，发送方处理来自接收方的ACK（这里的ACK被包含数据的报文段捎带），TCP将ACK确认号与窗口变量SendBase进行比较，因为累计确认，ACK的值确认了该值前的所有序号的数据都已经正确接收，发送方更新SendBase后，TCP需要重启定时器；</span><br><br><span class="ruby"><span class="hljs-comment">##### 情况描述，A为发送方，B为接收方</span></span><br><br><span class="ruby"><span class="hljs-number">1</span>. A发送序号为<span class="hljs-number">92</span>的长度为<span class="hljs-number">8</span>的报文段，等待B的确认号为<span class="hljs-number">100</span>的报文段；B发送给A的报文丢失，A超时重发，B收到了已经收到的报文段，B中的TCP服务将丢弃报文段中的字节；</span><br><span class="ruby"><span class="hljs-number">2</span>. A发送序号为<span class="hljs-number">92</span>的长度为<span class="hljs-number">8</span>的报文段和序号<span class="hljs-number">100</span>长度为<span class="hljs-number">20</span>的报文段，两个报文段完好到达B，B为每个报文发送一个确认，第一个确认号为<span class="hljs-number">100</span>，第二个确认号为<span class="hljs-number">120</span>，两个确认报文段在超时前未到达B，A将重传序号为<span class="hljs-number">92</span>的报文段，并重启定时器，<span class="hljs-number">120</span>的ACK报文段到达，第二个报文段就不被重传；</span><br><span class="ruby"><span class="hljs-number">3</span>. 和<span class="hljs-number">2</span>中情况一样，<span class="hljs-number">100</span>的确认号的报文段在网络中丢失，<span class="hljs-number">120</span>的确认号的报文段到达A，A确认<span class="hljs-number">199</span>及之前的所有字节都已经正确接收，A不会重传任何一个报文段；</span><br><br><span class="ruby"><span class="hljs-comment">#### 超时间隔加倍</span></span><br><br><span class="ruby">- 超时事件发生，TCP重传具有最小序号的还未被确认的报文段；每次重传将下一次的超时时间间隔设置为先前值的<span class="hljs-number">2</span>倍，而不是使用计算值，定时器在收到上层数据或者收到ACK报文段时将恢复计算时间为超时时间间隔；</span><br><span class="ruby">- 这里的超时时间间隔的指数型增长，提供了一种简单形式的拥塞控制；</span><br><br><span class="ruby"><span class="hljs-comment">#### 快速重传</span></span><br><br><span class="ruby">&gt; TCP不使用否定确认 NAK</span><br><br><span class="ruby">- TCP接收方发送ACK的动作</span><br><span class="ruby">  - 收到比期望序号要大的报文段，检测出现了间隔，则发送冗余ACK，也就是间隔低端的序号的确认号；</span><br><span class="ruby">  - 按序到达的报文段，等待下一个按序到达的报文段500ms，下一个没有在此时间间隔内到达，则发送ACK</span><br><span class="ruby">  - 单个积累ACK</span><br><span class="ruby">  - 接收数据间隔的报文段到达，发送ACK</span><br><span class="ruby">- 接收方收到<span class="hljs-number">3</span>个冗余ACK（快速重传的条件是<span class="hljs-number">3</span>个冗余 ？为什么），TCP执行**快速重传**，即在该报文段定时器超时前重传丢失报文段；</span><br><span class="ruby">- 选择确认，有选择的确认失序报文段，而不是累积到最后一个正确接收的有序报文段，与选择重传相结合；</span><br><br><span class="ruby">![img](<span class="hljs-symbol">file:</span>/<span class="hljs-regexp">//</span><span class="hljs-symbol">C:</span>/%5CUsers%5Cteddy%5COneDrive%5C2020%5CCS-Learning-curve%5C%E7%BD%<span class="hljs-number">91</span>%E7%BB%9C%5C3.<span class="hljs-number">5.4</span>%E5%BF%AB%E9%<span class="hljs-number">80</span>%9F%E9%<span class="hljs-number">87</span>%8D%E4%BC%A0.png)</span><br><br><span class="ruby"><span class="hljs-comment">### 3.5.5 流量控制</span></span><br><br><span class="ruby">- TCP缓存溢出：TCP的两则都有接收缓存，TCP接收到正确的、按序的字节后，将数据放入缓存，应用程序从缓存中读取数据，如果应用当前其他事务繁忙，则有可能发送缓存溢出的情况；</span><br><span class="ruby">- 流量控制服务（Flow-control service），匹配发送方的发送速率和接收方应用程序的读取速率；</span><br><span class="ruby">- 流量控制</span><br><span class="ruby">  - RcvBuffer：配置的接收缓存的大小</span><br><span class="ruby">  - LastByteRead：从缓存中读取的数据的最后一个字节的编号</span><br><span class="ruby">  - LastByteRcvd：达到的按序报文段放入缓存的数据流的最后一个字节的编号</span><br><span class="ruby">  - LastByteRcvd - LastByteRead &lt;= RcvBuffer 必须成立才可不发生溢出</span><br><span class="ruby">  - 当前的接收窗口：rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</span><br><span class="ruby">  - rwnd空间为动态变化的空间，rwnd值会被接收主机放入发给发送方的报文段的**”接收窗口“**字段，开始时rwnd = RcvBuffer</span><br><span class="ruby">  - 发送方跟踪的变量：LastByteSent, LastByteAcked</span><br><span class="ruby">  - 发送方在整个连接的生命周期内必须保证： LastByteSent - LastByteAcked &lt;= rwnd</span><br><span class="ruby">  - 发送方要保证，当前所有未被确认的数据长度一定小于等于接收方返回的窗口长度</span><br><span class="ruby">  - 特殊情况：接收方窗口为<span class="hljs-number">0</span>时，发送发将继续发送只有一个字节数据的报文段，接收方确认，当缓存清空后，确认报文将包含一个非<span class="hljs-number">0</span>的窗口值rwnd；这里再清空前还是会发生重传；</span><br><span class="ruby">  - 注意：UDP不存在流量控制，所有对于UDP会出现缓存溢出</span><br><br><span class="ruby"><span class="hljs-comment">### TCP的连接管理</span></span><br><br><span class="ruby">- TCP连接的建立与拆除</span><br><span class="ruby">- 连接建立的过程会显著增加用户感受到的时延</span><br><span class="ruby">- 网络攻击利用TCP连接管理的弱点、</span><br><br><span class="ruby"><span class="hljs-comment">#### 连接建立的步骤</span></span><br><br><span class="ruby">&gt; isn = identity sequence number</span><br><br><span class="ruby"><span class="hljs-number">1</span>. 第一步，**客户的TCP服务向服务端的TCP发送一个特殊的TCP报文段，该报文段不包含应用层数据，但是报文段的首部的标志位“SYN”的比特被置为<span class="hljs-number">1</span>**；客户随机选择一个起始序号（client_isn），并将该编号放在TCP SYN报文段的序号字段中；**表示发起建立新的连接**</span><br><span class="ruby"><span class="hljs-number">2</span>. 第二步，包含TCP SYN报文段的IP数据报到达服务端，服务器从数据报中提取TCP SYN报文段，为TCP连接分配缓存和变量（这里分配的缓存和变量容易受到洪泛攻击），**并发送允许连接的报文段**，允许连接的报文段：不包含任何应用层数据，SYN标志位被置为<span class="hljs-number">1</span>，确认号为client_isn+<span class="hljs-number">1</span>，序号为随机选择的服务器初始序号 server_isn；**表示收到了发起连接的SYN的client_isn，同意建立连接，称作SYNACK报文段(SYNACK segment)**</span><br><span class="ruby"><span class="hljs-number">3</span>. 第三步，客户收到SYNACK报文段后，客户给该连接分配缓存和变量，**客户向服务端发送一个对服务端SYNACK的确认，确认序号为server_isn+<span class="hljs-number">1</span>，且SYN被置为<span class="hljs-number">0</span>，这个数据报中可以携带客户应用层数据；</span><br><br><span class="ruby">- 这个步骤被称为“<span class="hljs-number">3</span>次握手”，从第三个步骤开始次周的报文段传输的过程中SYN标志位都为<span class="hljs-number">0</span>，建立的过程中交换了<span class="hljs-number">3</span>个分组；</span><br><br><span class="ruby"><span class="hljs-comment">#### 连接拆除的步骤</span></span><br><br><span class="ruby">&gt; 两个进程都可以终止当前的连接，连接接收后，TCP服务分配的缓存和变量都会被释放和回收；</span><br><br><span class="ruby"><span class="hljs-number">1</span>. 客户应用程序发起关闭连接的命令，客户TCP向服务器发送报文段：首部标志位FIN被置为<span class="hljs-number">1</span>；</span><br><span class="ruby"><span class="hljs-number">2</span>. 服务器收到FIN 为<span class="hljs-number">1</span>的报文段后，向发送发会送一个确认报文段；</span><br><span class="ruby"><span class="hljs-number">3</span>. 服务器发送自己的终止报文段，其FIN比特被置为<span class="hljs-number">1</span>；</span><br><span class="ruby"><span class="hljs-number">4</span>. 客户向服务端发送的终止报文段，发送一个确认，此时两台主机上用于该连接的所有资源都被释放；</span><br><br><span class="ruby"><span class="hljs-comment">#### 状态变迁</span></span><br><br><span class="ruby">- **TCP状态 TCP state**</span><br><span class="ruby">- 客户连接状态变化：</span><br><span class="ruby">  - CLOSED -&gt; 客户向服务端发起一个连接，并发送SYN <span class="hljs-number">1</span>的无数据报文段</span><br><span class="ruby">  - SYN_SENT -&gt; 接收到服务端会送的SYN <span class="hljs-number">1</span>的无数据报文段并且携带了对client_isn的确认，并发送对server_isn的确认 ，该确认只进行确认，SYN为<span class="hljs-number">0</span>，且可以携带应用层数据</span><br><span class="ruby">  - ESTABLISHED -&gt; 客户端连接建立成功； **拆除**： 应用层调用了关闭连接，TCP发送FIN标志位 <span class="hljs-number">1</span>的报文段，客户进入等待FIN确认的状态</span><br><span class="ruby">  - FIN_WAIT_1 -&gt; 接受到服务端回送的对FIN1的确认报文段，进入等待服务端发送FIN <span class="hljs-number">1</span>的报文段的状态；</span><br><span class="ruby">  - FIN_WAIT_2 -&gt; 接收服务端回送的FIN <span class="hljs-number">1</span>的报文段，发送对该报文段的确认；</span><br><span class="ruby">  - TIME_WAIT -&gt; 等待状态，等待30S后关闭连接，ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文，TIME_WAIT消耗的时间与集体实现有关系，典型值30s，1min，2min</span><br><span class="ruby">  - CLOSED -&gt; 连接关闭资源释放</span><br><span class="ruby">- 服务端连接的状态变化：</span><br><span class="ruby">  - CLOSED -&gt; 服务器创建一个监听套接字，进入LISTEN状态</span><br><span class="ruby">  - LISTEN -&gt; 处于LISTEN状态的TCP服务，接收来自客户的SYN，并回送SYN和确认号+序号</span><br><span class="ruby">  - SYN_RCVD -&gt; 进入已经接收SYN并等待ACK的状态</span><br><span class="ruby">  - ESTABLISHED -&gt; 接收来自客户对SYN回报的确认正确接收ACK，ACK中包含服务端等待的的报文序号和服务端发送SYN的确认号，且可能包含数据，此时TCP服务将分配缓存及变量开始处理数据；</span><br><span class="ruby">  - CLOSE_WAIT -&gt; **拆除**：处于已经建立了连接的服务端，收到一个FIN标志位为<span class="hljs-number">1</span>数据报，并对客户发送收到确认，确认号及序号</span><br><span class="ruby">  - LAST_ACK -&gt; 服务端主动向客户发送一个FIN标志位为<span class="hljs-number">1</span>的的数据报</span><br><span class="ruby">  - CLOSED -&gt; 接收来自客户对服务端发送的FIN数据报的ACK确认，不在发送数据，TCP和套接字 、进入关闭状态；</span><br><span class="ruby">- 客户的TIME_WAIT作用，</span><br><span class="ruby">  - <span class="hljs-number">1</span>. 当主动关闭方处于TIME_WAIT状态时，一般会等待两个MSL（一般为60S），目的是确保，最后对被动方发送的FIN <span class="hljs-number">1</span>的报文的ACK确认报文段如果在网络中穿线丢失或者网络拥塞未到达处于LAST_ACK的被动关闭方，则被动关闭方可能会多次重传最后一个FIN <span class="hljs-number">1</span>的报文段，这样主动方可以发送ACK回复；</span><br><span class="ruby">    <span class="hljs-number">2</span>. 如果做超时等待和重传，当该该端口和套接字再次建立新的TCP连接时，可能会导致新的连接收到被动关闭方最后的多次重传FIN <span class="hljs-number">1</span>的报文段的影响；所以TIME_WAIT时保障被动关闭方完全进入CLOSED状态，超时后主动发起方才会进入关闭状态并释放相应缓存和变量；</span><br><span class="ruby">- 三次握手的最后一次，服务端等待客户发送最后的携带数据的ACK报文段，如果超时时间内没有收到（超时时间一般 为60s），则服务端将终止当前的半开连接，并回收资源；</span><br><span class="ruby">- DoS攻击(Denial-of-service attack)，SYN洪泛攻击（SYN flood attack），攻击者发送大量的TCP SYN报文段，不完成与server的三次握手，服务端不断对这样的半开连接分配资源（但资源未得到使用），导致服务器的连接资源被消耗殆尽；</span><br><span class="ruby">- 防止攻击的手段时，使用SYN cookie，使用散列函数生成对SYN的特殊TCP序号，对返回的ACK报文段中的确认号和再次以相同方式计算散列函数的值相比较，也就是ACK=服务器返回的序号+<span class="hljs-number">1</span>，这种情况下就可以判断是否要建立连接，否则对服务器无危害，因为服务器并没有分配任何资源，仅仅只使用了散列函数；</span><br><span class="ruby">- 当TCP向一个不处于监听状态或者说不接收任何连接的端口，发送SYN建立连接的报文段时，接收主机的TCP将向源地址回送一个重置报文段，该报文段首部的RST标志位置为<span class="hljs-number">1</span>；这个标志位表示的是**”我没有那个报文段的套接字，请不要再发送该报文段了“**；同样的问题出现再UDP套接字不匹配的情况时，接收主机将会发送一个特殊的ICMP数据报；</span><br><br><span class="ruby">&gt; nmap端口扫描工具</span><br><span class="ruby">&gt;</span><br><span class="ruby">&gt; 扫描一个TCP端口，发送一个TCP SYN <span class="hljs-number">1</span>的报文段，有可能的三种情况</span><br><span class="ruby">&gt;</span><br><span class="ruby">&gt; <span class="hljs-number">1</span>. 目的主机回送SYN ACK报文段，该端口的TCP连接处于打开状态（LISTEN）</span><br><span class="ruby">&gt; <span class="hljs-number">2</span>. 目的主机回送一个RST报文段，SYN报文段到达了目标主机，但是目标主机该端口未运行TCP应用</span><br><span class="ruby">&gt; <span class="hljs-number">3</span>. 源主机没有收到任何返回，标识SYN报文段被防火墙阻挡，无法到达目标主机</span><br><span class="ruby">&gt;</span><br><span class="ruby">&gt; nmap工具可以检查TCP打开的端口，打开的UDP端口，哈可以检查防火墙配置</span><br><br><span class="ruby"><span class="hljs-comment">### 3.6 TCP拥塞控制原理</span></span><br><br><span class="ruby">- **异步传递方式 ATM**</span><br><span class="ruby">- **可用比特率 ABR**</span><br><br><span class="ruby"><span class="hljs-comment">#### 3.6.1 拥塞原因和代价</span></span><br><br><span class="ruby">- 两个发送方和一台具有无穷大缓存的路由器</span><br><span class="ruby">  - 两个主机各自有一条连接，且共享源和目的之间的单跳路由，PAGE <span class="hljs-number">175</span></span><br><span class="ruby">  - 代价<span class="hljs-number">1</span>：当分组到达的速率接近链路容量时，分组经历了巨大的排队时延；</span><br><span class="ruby">  - 共享输出**链路的容量** R</span><br><span class="ruby">  - 代价<span class="hljs-number">2</span>：发送方必须执行重传以补偿因为缓存益处导致的分组丢失</span><br><span class="ruby">  - 代价<span class="hljs-number">3</span>：发送方再遇到网络时延较大的情况下，会重传分组，导致路由器会利用链路带宽来转发一个不需要的分组副本；</span><br><span class="ruby">  - 代价<span class="hljs-number">4</span>：一个分组沿着一条路径被丢弃时，每个上游的路由器对该分组的转发都是在浪费传输容量；</span><br><br><span class="ruby"><span class="hljs-comment">#### 3.6.2 拥塞控制方法</span></span><br><br><span class="ruby">- 端到端拥塞控制：TCP通过端到端的方法解决拥塞问题，IP层不会向端系统提供有关网络拥塞的反馈；TCP接收方通过三次冗余确认告知接收方报文段的丢失，报文段的丢失就是一种网络拥塞的迹象，TCP会**相应的减小窗口长度**，往返的时延值作为网络拥塞程度的指示；</span><br><span class="ruby">- 网络辅助的拥塞控制，网络层的路由器会向发送方提供关于链路中的拥塞情况；反馈方式为，阻塞分组（choke packet），路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生；收到标记的分组后，接收方就会向发送方通知网络的拥塞；</span><br><br><span class="ruby"><span class="hljs-comment">#### 3.6.3 网络辅助的拥塞控制的例子：ATM ABR 拥塞控制</span></span><br><br><span class="ruby">- ATM ABR拥塞控制算法，采用网络辅助的方法解决拥塞控制的协议；</span><br><br><span class="ruby"><span class="hljs-comment">##### ATM</span></span><br><br><span class="ruby">- ATM采用面向虚电路（VC）的方法来处理分组交换；交换机将维护有关源到目的的VC状态；逐个VC的状态允许交换机跟踪各个发送方的行为，并采取相应的拥塞控制动作；例如跟踪分组的平均速率，显示的通知发送方减少发送分组的速率；</span><br><span class="ruby">- ABR是一种弹性数据传输服务，ABR服务会在网络轻载时充分利用空闲的可用带宽；网络拥塞时，ABR服务会将其传输速率抑制为某些预先确定的最小传输速率；</span><br><br><span class="ruby">&gt; 详细：PAGE <span class="hljs-number">180</span></span><br><br><span class="ruby"><span class="hljs-comment">### 3.7 TCP 拥塞控制</span></span><br><br><span class="ruby">- TCP使用端到端的拥塞控制机制，IP层不向端系统显示的提供任何网络拥塞程度的反馈；</span><br><br><span class="ruby">- 采用的方法：让每个发送方根据所感知的到的网络的拥塞程度来限制向连接发送流量的速率，动态调整流量发送速率，无拥塞时增加速率，有拥塞时降低速率；</span><br><br><span class="ruby">- 拥塞控制的实现：</span><br><br><span class="ruby">  - 流量速率限制：TCP连接维护一个发送缓存，和一个接收缓存，和多个变量（接收方LastByteRead，LastByteRcvd，RcvBuffer，rwnd 发送方：LastByteSent，LastByteAcked）；发送方会跟踪变量</span><br><br><span class="ruby">    ”拥塞窗口“（congestion window）</span><br><br><span class="ruby">    ，表示为</span><br><br><span class="ruby">    cwnd</span><br><br><span class="ruby">    ；</span><br><br><span class="ruby">    - LastByteSent - LastByteAcked &lt;= min &#123; cwnd, rwnd&#125;</span><br><span class="ruby">    - 发送方中**未被确认**的数据量不会超过 接收窗口和拥塞窗口中的最小值；</span><br><span class="ruby">    - 通过调节cwnd的值，发送方能够调整它向连接发送数据的速率；</span><br><br><span class="ruby">  - 感知拥塞：分组丢失后接收方发送<span class="hljs-number">3</span>个冗余ACK，或者接收方出现超时，这时发送方就认为路径上出现了拥塞；</span><br><br><span class="ruby">    - TCP使用确认（或者计时）来触发增大拥塞窗口的长度，<span class="hljs-keyword">self</span>-clocking;</span><br><span class="ruby">    - 一个丢失的报文段意味着拥塞，因此当丢失报文段时应该降低TCP的发送方的速率；</span><br><span class="ruby">    - 一个确认报文段指示网络在向接收方交付发送方的报文，因此，当先前未确认的报文段的确认达到时，能够增加发送方的速率；</span><br><span class="ruby">    - 带宽探测；增加传输速率以响应到达的ACK确认报文段，除非出现丢包事件，此时才减小传输速率；TCP发送方增加发送速率，到出现拥塞，从该速率后退，进而再次进行探测，检查拥塞是否发生了变化；ACK和丢包事件充当了隐式的信号；</span><br><span class="ruby">    - TCP发送方根据异步于其他TCP发送方的”本地信息“行动；</span><br><br><span class="ruby">- TCP拥塞控制算法（TCP congestion control algorithm）</span><br><br><span class="ruby">  - 慢启动</span><br><span class="ruby">  - 拥塞避免</span><br><span class="ruby">  - 快速恢复</span><br><br><span class="ruby"><span class="hljs-comment">##### 慢启动</span></span><br><br><span class="ruby">- slow-start，发送方的起始cwnd值为一个MSS，起始发送速率为MSS/RTT，每当传输的报文段首次被确认接收ACK，cwnd就增加一个MSS，在这个过程中每一个RTT，cwnd的值就会翻番，起始阶段很慢，但是在整个慢启动阶段以指数增加；</span><br><span class="ruby">- 慢启动对超时和丢包事件的处理，即发送拥塞时的处理，有两种方式，<span class="hljs-number">1</span>是将cwnd设置为<span class="hljs-number">1</span>重新开始慢启动过程，将ssthresh（慢启动阀门）设置为cwnd/<span class="hljs-number">2</span>，当出现拥塞将ssthresh设置为拥塞窗口的一半；当cwnd的值等于ssthresh时，结束慢启动并且将TCP转移到**”拥塞避免模式“**；</span><br><span class="ruby">- 当检测到<span class="hljs-number">3</span>个冗余ACK，这时TCP执行一种快速重传并进入**快速恢复状态**；</span><br><br><span class="ruby">&gt; TCP分叉 PAGE <span class="hljs-number">193</span></span><br><br><span class="ruby"><span class="hljs-comment">##### 拥塞避免</span></span><br><br><span class="ruby">- 进入拥塞避免的TCP，cwnd的值大约是遇到拥塞时的一半，这时每个RTT的确认ACK只将cwnd的值增加<span class="hljs-number">1</span>个MSS；例如当前窗口每次发送<span class="hljs-number">10</span>个报文段，假设每个报文段都有自己的确认ACK，则每次收到一个ACK，拥塞窗口的长度就增加<span class="hljs-number">1</span>/10MSS，当<span class="hljs-number">10</span>个ACK都收到时，就增加了一个MSS；</span><br><span class="ruby">- 出现超时：cwnd的值被设置为<span class="hljs-number">1</span>个MSS，ssthresh被设置为cwnd/<span class="hljs-number">2</span>，并进入慢启动状态；</span><br><span class="ruby">- 出现冗余ACK事件：TCP将cwnd减半，加上三个ACK的<span class="hljs-number">3</span>个MSS，进入快速恢复状态</span><br><br><span class="ruby"><span class="hljs-comment">##### 快速恢复</span></span><br><br><span class="ruby">- 进入快速恢复后，对每个收到的冗余报文段的ACK，cwnd的值增加一个MSS，当丢失报文的一个ACK到达时，TCP再降低cwnd后进入拥塞避免状态；</span><br><span class="ruby">- 出现超时，执行与拥塞避免相同的操作，进入慢启动状态；</span><br><span class="ruby">- 出现丢包，cwnd的值设置为<span class="hljs-number">1</span>个MSS，将ssthresh的值设置为cwnd的一半；</span><br><br><span class="ruby">![img](<span class="hljs-symbol">file:</span>/<span class="hljs-regexp">//</span><span class="hljs-symbol">C:</span>/%5CUsers%5Cteddy%5COneDrive%5C2020%5CCS-Learning-curve%5C%E7%BD%<span class="hljs-number">91</span>%E7%BB%9C%5C3.<span class="hljs-number">7</span>%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%<span class="hljs-number">88</span>%B6.png)</span><br><br><span class="ruby"><span class="hljs-comment">#### 全局回顾</span></span><br><br><span class="ruby">&gt; 当TCP通过<span class="hljs-number">3</span>个冗余ACK感知到了丢包，TCP进行的拥塞控制是：每个RTT内cwnd线性增加1MSS，出现<span class="hljs-number">3</span>个冗余ACK事件时cwnd减半；</span><br><br><span class="ruby">- TCP拥塞控制：**加性增**，**乘性减** additive-increase， multiplicative-Decrease AIMD</span><br><span class="ruby">- TCP线性的增加他的拥塞窗口的长度（线性增加发送速率），直到出现<span class="hljs-number">3</span>个冗余ACK事件，然后以两个因子来减少拥塞窗口的长度，然后又开始线性增长，探测是否还有另外可用的带宽；</span><br><span class="ruby">- Reno算法</span><br><br><span class="ruby"><span class="hljs-comment">#### 吞吐量的宏观描述</span></span><br><br><span class="ruby">- PAGE187</span><br><span class="ruby">- 一天连接的平均吞吐量<span class="hljs-string">`0.75 x w /RTT`</span> ，这里的w表示当前拥塞窗口的长度；</span><br><br><span class="ruby"><span class="hljs-comment">#### 经高带宽路径的TCP</span></span><br><br><span class="ruby">- PAGE187</span><br><br><span class="ruby"><span class="hljs-comment">#### 公平性</span></span><br><br><span class="ruby">- UDP没有内置的拥塞控制，UDP上的应用需要好以恒定的速率将数据注入网络中，UDP连接在TCP的观点看来时不公平的，因为它不与其他的连接合作，也不会适时的调整传输速率，TCP的拥塞控制在面临拥塞增加时，会降低其传输速率，原则上UDP并不会这样做；UDP源可能会压制TCP流量；</span><br><span class="ruby">- TCP应用建立的并行连接会导致网络中应用程序带宽分配的不公平；</span><br><br><span class="ruby"><span class="hljs-comment">### 3.8 本章总结</span></span><br><br><span class="ruby">------</span><br><br><span class="ruby"><span class="hljs-comment"># 4. 网络层</span></span><br><br><span class="ruby">- 交付方式</span><br><span class="ruby">  - 数据报模式</span><br><span class="ruby">  - 虚电路模式</span><br><span class="ruby">- 网络层功能</span><br><span class="ruby">  - 转发 forwarding</span><br><span class="ruby">  - 路由选择 routing</span><br><span class="ruby">  - 网际协议IP IPv4, IPv6</span><br><span class="ruby">  - 网络地址转换NAT</span><br><span class="ruby">  - 数据报分段</span><br><span class="ruby">  - 因特网控制报文协议ICMP</span><br><span class="ruby">  - 路由选择算法：链路状态和距离矢量算法，等级制路由选择方法；RIP，OSPF，IS-IS，BGP</span><br><br><span class="ruby"><span class="hljs-comment">### 概述</span></span><br><br><span class="ruby">- 路由器的主要作用是将数据报（data grama）从入链路转发到出链路，路由器具有截断的协议栈，即没有网络层以上的部分；路由器除了控制目的外，不运行网络层以上的协议；、</span><br><br><span class="ruby"><span class="hljs-comment">### 4.1.1 转发和路由选择</span></span><br><br><span class="ruby">- **转发：**将分组从输入链路移动到适当的输出链路的过程</span><br><span class="ruby">- **路由选择：**网络层需要决定分组从发送方到接收方所要采用的路径或者路由，计算这些路径的算法为**路由选择算法** routing algorithm；</span><br><br><span class="ruby">&gt; 类比驾驶：驾驶车辆通过路段可以看作转发，查看地图选择到达目的地的路径可以看作路由选择；</span><br><br><span class="ruby">- 每台路由器有一张</span><br><br><span class="ruby">  转发表（forwarding table）</span><br><br><span class="ruby">  ；</span><br><br><span class="ruby">  - 转发表存储：分组首部的值和路由表的输出链路接口</span><br><span class="ruby">  - 路由器通过检查到达的分组首部的字段，用该字段值再转发表中查询，从而找出输出链路的接口</span><br><span class="ruby">  - 路由选择算法，决定了插入路由器的转发表中的值，路由选择算法可能是集中式的也可能是分布式的；</span><br><span class="ruby">  - 路由器接收路由选择协议报文，将报文信息用以配置路由转发表；</span><br><br><span class="ruby">- 重要术语</span><br><br><span class="ruby">  - 分组交换机：一台通用分组交换设备，根据分组首部字段，从输入链路到输出链路来转移分组；</span><br><span class="ruby">  - 包括**链路层交换机** link-layer switches，基于链路层字段做转发决定；</span><br><span class="ruby">  - **路由器** router，基于网络层字段做转发决定；</span><br><span class="ruby">  - 连接建立 connection setup</span><br><br><span class="ruby"><span class="hljs-comment">### 4.2.1 网络服务模型</span></span><br><br><span class="ruby">- 网络服务模型 network service model 定义了分组再发送与接收端系统之间端到端的端运输特性</span><br><span class="ruby">- 网络层提供的服务</span><br><span class="ruby">  - 确保交付：确保分组最终到达目的地</span><br><span class="ruby">  - 具有时延上界的确保交付：确保分组交付，且再特定主机到主机时延上界内交付</span><br><span class="ruby">  - 有序分组交付：分组按照发送顺序达到目的地</span><br><span class="ruby">  - 确保最小带宽：主机以低于特定比特率的速率传输比特，则不会发送分组丢失，且分组再预定的时延内到达；</span><br><span class="ruby">  - 确保最大时延抖动：确保发送方两个相继分组间的时间量 = 目的地接收两个分组之间的时间量</span><br><span class="ruby">  - 安全性服务，使用源和目的主机知道的会话密钥，再源主机的网络层加密向目的主机发送的所有数据报负载；</span><br><span class="ruby">- 因特网尽力而为服务（best-effort service），分组间的定时不能被保证，分组接受顺序也不能保证，发送分组最终是否能交付也不能保证；</span><br><span class="ruby">- 恒定比特率（Constant bit rate，CBR） ATM网络服务；像发送方和接收方之间的一条专用的、固定带宽的传输链路；信元的端到端时延、时延抖动、丢失、推迟交付的比率都确保再特定值一下；</span><br><span class="ruby">- 可用比特率（Available Bit Rate，ABR）ATM网络服务；最小信元传输速率（MCR）可以得到保证；网络有足够的空闲资源的情况下，发送方也会使用比MCR高的速率发送数据；</span><br><br><span class="ruby"><span class="hljs-comment">## 4.2 虚电路和数据报网络</span></span><br><br><span class="ruby">- 网络层的面向连接服务和无连接服务</span><br><span class="ruby">  - 网络层的面向连接服务和无连接服务向运输层提供主机到主机的服务，运输层则是向应用层提供进程到进程之间的服务；</span><br><span class="ruby">  - 只在网络层提供连接服务的网络：**虚电路网络 Virtual-Circuit VC**</span><br><span class="ruby">  - 只在网络层提供无连接服务的网络：**数据报网络 datagram network**</span><br><span class="ruby">  - 运输层的连接服务只在网络边缘的端系统中实现，网络层的连接服务再端系统中和网络核心的路由器中实现；</span><br><span class="ruby">  - 计算机网路的两种基本类型：**虚电路网络， 数据报网络**</span><br><br><span class="ruby"><span class="hljs-comment">#### 虚电路网络</span></span><br><br><span class="ruby">&gt; 因特网时一个数据报网络</span><br><br><span class="ruby">- ATM、帧中继的体系结构都是虚电路网络，在网络层使用连接，成为虚电路；</span><br><span class="ruby">- 虚电路的组成：</span><br><span class="ruby">  - 源和目的之间的路径，链路和路由器</span><br><span class="ruby">  - VC号，沿着该路径的每段链路的一个号码；</span><br><span class="ruby">  - 沿着路径的每台路由器中的转发表表项；</span><br><span class="ruby">    - 每台路路由器会为分组替换一个新的VC号，分组在每条链路上有不同的VC号，且再分组的首部携带；</span><br><span class="ruby">    - 路由器的转发表会管理入VC号字段和对应的出VC号字段；</span><br><span class="ruby">    - 创建虚电路对路由器新增转发项，终止一条虚电路，删除相应的转发表项；</span><br><span class="ruby">    - 路由器需要对进行中的连接 维持**连接状态信息**，分组跨越一个路由器就创建新连接，增加路由器的表项，每释放一个连接从表中删除表项；</span><br><span class="ruby">- 虚电路的<span class="hljs-number">3</span>个阶段</span><br><span class="ruby">  - 虚电路建立，运输层向网络层指定接收方地址，网络层决定一条分组通过的路径，网络层沿着路径向链路中的每一个路由器节点决定VC，在转发表中增加表项；</span><br><span class="ruby">  - 数据传输，分组沿着创建号的虚电路流动；</span><br><span class="ruby">  - 虚电路拆除，发送方或者接收方通知网络层希望终止该电路时，网络层会通知另一侧的端系统结束呼叫并更新路径上的每台路由器的转发表；</span><br><span class="ruby">- 沿着两个端系统之间的路径上的路由器都要参与虚电路的建立，且**每台路由器都完全知道通过它的所有虚电路**；</span><br><span class="ruby">- 端系统向网络发送的指示网络层终止虚电路的报文，和路由器之间用来传递修改路由表的虚电路建立报文，位**信令报文** （signaling message），用来交换这些报文的协议位**信令协议** （signaling protocol）；</span><br><br><span class="ruby"><span class="hljs-comment">#### 数据报网络</span></span><br><br><span class="ruby">- 端系统为想要发送的分组加上目的端系统的地址，然后将分组推进网络中；路由器不维护任何虚电路；</span><br><span class="ruby">- 分组在链路中经过每一台路由器，**路由器都是用分组目的地址来对分组进行转发**；</span><br><span class="ruby">- 每台路由器维护一个**链路接口转发表**用来给目的地址做映射，对于到达分组，路由器会使用其首部的目的地址在链路转发表中查找适当的输出链路接口；然后路由器将分组向该接口转发；</span><br><span class="ruby">- IPv4地址长度 <span class="hljs-number">32</span> 位bit，<span class="hljs-number">4</span>段（<span class="hljs-number">4</span> group）</span><br><span class="ruby">- IPv6地址长度<span class="hljs-number">128</span>位bit，<span class="hljs-number">8</span>段（<span class="hljs-number">16</span>进制，8group）</span><br><span class="ruby">- 转发表：路由器用分组的目的地址的**前缀（prefix）**与该表中的表项进行匹配；当初先多匹配时，例如一个分组的目的地址与转发表中的<span class="hljs-number">21</span>位表项匹配且又与<span class="hljs-number">24</span>位表项匹配，**则路由器使用最长前缀匹配规则**，将该分组转发到<span class="hljs-number">24</span>位表项相匹配的输出链路接口上，路由器总是在**链路接口转发表中**匹配最长的prefix，最长匹配项；最长匹配与编址规则有关；</span><br><span class="ruby">- 路由器维护的转发表，维持了转发转台信息，转发表由**路由选择算法进行更新和修改**，路由器建立新连接和拆除一条连接都会更新转发表；</span><br><br><span class="ruby"><span class="hljs-comment">## 4.3 路由器的工作原理</span></span><br><br><span class="ruby">&gt; 回顾：链路层交换机实现第一层和第二层，路由器实现第一层到第三层，路由器能够实现IP协议，链路交换机不能，链路层交换机能够实现第二层地址，以太网地址</span><br><br><span class="ruby">- **转发功能 （forwarding function）**</span><br><span class="ruby">- 路由器的体系结构</span><br><br><span class="ruby">![img](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/teddygoodman.github.io/</span>Users/teddyna/OneDrive/<span class="hljs-number">2020</span>/CS-Learning-curve/%E7%BD%<span class="hljs-number">91</span>%E7%BB%9C/%E8%B7%AF%E7%<span class="hljs-number">94</span>%B1%E5%<span class="hljs-number">99</span>%A8%E4%BD%<span class="hljs-number">93</span>%E7%B3%BB%E7%BB%<span class="hljs-number">93</span>%E6%9E%<span class="hljs-number">84</span>.png)</span><br><br><span class="ruby">- 输入端口：</span><br><br><span class="ruby">  - 物理层功能：将一条输入链路与路由器相连接</span><br><br><span class="ruby">  - 数据链路层功能：与位于入链路远端的数据链路层交互</span><br><br><span class="ruby">  - 通过查询转发表决定输出端口，到达分组通过路由器的交换结构转发到输出端口；</span><br><br><span class="ruby">  - 将“控制分组”从输入端口转发到路由器的“选择处理器”，（携带路由选择控制协议的分组）</span><br><br><span class="ruby">    &gt; **端口**，这个词语在网络硬件中表示，路由器物理的输入和输出接口；</span><br><br><span class="ruby">- 交换结构：</span><br><br><span class="ruby">  - 与输入端口和输出端口相连，交换结构完全包换在路由器中，网络路由器中的网络；</span><br><br><span class="ruby">- 输出端口：</span><br><br><span class="ruby">  - 存储从交换结构接收的分组</span><br><span class="ruby">  - 执行相应的物理层和链路层功能，在输出链路上传输分组</span><br><span class="ruby">  - 双向链路，输出端口和输入端口在同一线路卡上成对出现；</span><br><br><span class="ruby">- 路由选择处理器：</span><br><br><span class="ruby">  - 执行路由选择协议</span><br><span class="ruby">  - 维护路由表及连接的链路状态信息</span><br><span class="ruby">  - 计算转发表</span><br><span class="ruby">  - 执行网络管理功能</span><br><br><span class="ruby">- **路由转发平面 router forwarding plane** ：路由转发是路由器用输入输出端口、交换结构共同实现的转发功能，总是用“硬件”实现；</span><br><br><span class="ruby">  - 路由器对n个端口数据的处理，数据处理流水线需要n倍的处理速率，通过厂商定制的硬件来实现这样的功能；</span><br><br><span class="ruby">- **路由器控制平面 router control plane** ：通过软件实现，路由器的控制功能，包括执行路由选择协议，对上线和下线的连接链路进行响应，及路由的管理功能；</span><br><br><span class="ruby">- 路由器和交换机的设计面对一系列的拥堵问题；</span><br><br><span class="ruby"><span class="hljs-comment">### 4.3.1 输入端口</span></span><br><br><span class="ruby">- 输入端口的**线路端接功能** 与 **链路层处理** 实现了用于各个输入链路的物理层和链路层，执行输出链路处理，包括链路协议，和分组的拆封；</span><br><br><span class="ruby">- 输入端口中：路由器使用转发表来查找输出端口，使得到达的分组能够经过交换结构转发到该输出端口；</span><br><br><span class="ruby">- 转发表由路由器的选择处理器计算和更新，转发表的一份影子副本通常会被存放在每个输入端口；</span><br><br><span class="ruby">- 转发表从路由选择处理器经过独立总线，复制到线路卡；</span><br><br><span class="ruby">- 影子副本的作用：在每个端口本地作出转发决策，无需调用中央路由选择处理器，避免了集中式处理的瓶颈；</span><br><br><span class="ruby">- 对于Gbps的链路，要求对转发表的查询必须在纳秒级别完成；</span><br><br><span class="ruby">  - 硬件执行查找</span><br><span class="ruby">  - 快速查找算法，快速搜索算法使用二分的思想，平均时间复杂度为logn，对于n为百万的情况，只需要执行<span class="hljs-number">20</span>次</span><br><span class="ruby">  - DRAM和更快的SRAM的嵌入式芯片设计</span><br><span class="ruby">  - 三态内容可寻址寄存器（Tenary Content Address Memory, TCRM），该寄存器可以在常数时间内对地址的转发表项内容做返回</span><br><br><span class="ruby">- 因为交换结构可能会被其他的分组使用，当前已经匹配了转发表项的输入分组需要在输入端口排队，并等待 被调度通过交换结构；</span><br><br><span class="ruby">  - 物理层和链路层处理</span><br><span class="ruby">  - 检查分组版本号、检验和、寿命字段，重写字段</span><br><span class="ruby">  - 更新用于网络管理的计数器（例如IP数据报的数目）</span><br><br><span class="ruby">  \&gt; 对于路由器的输入端口，查找转发表然后进入交换结构进行转发，的过程可以抽象为“匹配加动作”，这个抽象在链路层交换机和防火墙中都存在；</span><br><br><span class="ruby"><span class="hljs-comment">### 4.3.2 交换结构</span></span><br><br><span class="ruby"><span class="hljs-comment">#### 三种交换技术</span></span><br><br><span class="ruby">&gt; 内存，总线，纵横</span><br><br><span class="ruby">- 经内存交换</span><br><span class="ruby">  - 传统计算机的设计方式，CPU对分组进行在内存的I/O操作；</span><br><span class="ruby">  - 现代内存交换：输入线路卡查找转发表，并将分组放入适当的内存存储位置，也就是输出端口的内存</span><br><span class="ruby">- 经总线交换</span><br><span class="ruby">  - 通过共享总线将分组发送到输出端口</span><br><span class="ruby">    - 输入端口为分组预先计划一个内部标签（首部），该标签用来标识输出端口</span><br><span class="ruby">    - 分组在总线上传送到输出端口</span><br><span class="ruby">    - 所有输出端口都会收到分组，只有与标签匹配的端口才将分组保存，然后标签在输出端口被去除</span><br><span class="ruby">  - 一次只有一个分组可以跨越总线，路由器的交换带宽受到其总线速率的限制；</span><br><span class="ruby">- 经互谅网络交换</span><br><span class="ruby">  - 纵横式交换机是一种由2N条总线组成的互联网络；</span><br><span class="ruby">  - 连接N个输入端口和N个输出端口</span><br><span class="ruby">  - 垂直总线在交叉点和水平总线交叉，交叉点通过交换结构控制器能在任何时候开启和闭合；</span><br><span class="ruby">  - 对于来自不同输入需要达到不同输出端口的分组，纵横网络能够转发多个这样的分组；</span><br><span class="ruby">  - 对于进入相同总线的分组，还是需要排队等待；</span><br><br><span class="ruby"><span class="hljs-comment">### 4.3.3 输出端口</span></span><br><br><span class="ruby">- 输出端口：取出存放在输出端口内存中的分组，并将其发送到输出链路上；</span><br><span class="ruby">- 选择和取出排队分组进行传输，执行链路层和物理层传输功能；</span><br><br><span class="ruby"><span class="hljs-comment">### 4.3.4 排队</span></span><br><br><span class="ruby">- 输入和输出端口处都会形成分组排队</span><br><span class="ruby">- 排队位置和程度：取决于流量负载、交换结构的相对速率、线路速率；</span><br><span class="ruby">- 随着队列增长，路由器的缓存空间最终耗尽，新到达的分组将会出现**丢包** packet loss；</span><br><span class="ruby">- PAGE <span class="hljs-number">218</span> 描述了从理论到实践路由器转发分组的排队情况和路由器缓存配置情况</span><br><br><span class="ruby"><span class="hljs-comment">#### 分组调度程序 packet scheduler</span></span><br><br><span class="ruby">- 服务原则</span><br><span class="ruby">  - 先来先服务 FCFS</span><br><span class="ruby">  - 加权公平排队 WFQ，端到端之间公平的共享输出链路</span><br><span class="ruby">  - 服务质量保证 quality-of-service guarantee</span><br><br><span class="ruby"><span class="hljs-comment">#### 丢弃到达分组的策略</span></span><br><br><span class="ruby">- 弃尾策略</span><br><span class="ruby">- 主动队列管理 Active Queue Management AQM 算法，在缓存满前就丢弃分组的策略</span><br><span class="ruby">- 随机早期检测算法 广泛应用的AQM算法</span><br><span class="ruby">  - 算法思想：为输出队列长度维护一个加权平均值，平均队列长度小于阈值MINth，接纳分组，如果平均长度大于MAXth，则丢弃新到达的分组，如果平均长度处于[MINth MAXth]，则使用函数概率标记或丢弃函数；</span><br><span class="ruby">- 线路前部阻塞，一个输入队列中的排队分组，必须等待通过交换结构发送，即使当前目标的输出端口是空闲的，因为它被位于线路前部的另一个分组所阻塞；</span><br><br><span class="ruby"><span class="hljs-comment">### 4.3.5 路由选择控制平面</span></span><br><br><span class="ruby">路由选择控制平面驻留并运行在路由器选择的处理器上，网络范围的路由选择控制平面是分布式的，不同功能部分执行在不同的路由器上，并且通过彼此发送控制报文进行交互；</span><br><br><span class="ruby"><span class="hljs-comment">## 4.4 网际协议： 转发和编址</span></span><br><br><span class="ruby">- 编址和转发</span><br><span class="ruby">- IPv4 IPv6</span><br><span class="ruby">- 网络层的三个组件</span><br><span class="ruby">  - IP协议</span><br><span class="ruby">  - 路由选择，决定数据报从源地址到目的地址流经的路径</span><br><span class="ruby">  - ICMP协议：报告数据报中的差错，对网络层信息请求进行响应的设施</span><br><span class="ruby">- 视图</span><br><br><span class="ruby"><span class="hljs-params">|                 运输层 TCP、UDP                 |</span></span><br><span class="ruby"><span class="hljs-params">| :---------------------------------------------: |</span></span><br><span class="ruby"><span class="hljs-params">| 路由选择协议 * 路径选择 *RIP OSPF BGP —&gt; 转发表 |</span></span><br><span class="ruby"><span class="hljs-params">|  IP协议 * 编址规则 * 数据报格式 * 分组处理规则  |</span></span><br><span class="ruby"><span class="hljs-params">|       ICMP协议 * 差错报告 * 路由器 ”信令“       |</span></span><br><span class="ruby"><span class="hljs-params">|                     链路层                      |</span></span><br><span class="ruby"><span class="hljs-params">|                     物理层                      |</span></span><br><br><span class="ruby"><span class="hljs-comment">### 4.4.1 数据报格式</span></span><br><br><span class="ruby">- 网络层的分组： **数据报** datagram</span><br><span class="ruby">- IPv4 数据报格式</span><br><br><span class="ruby"><span class="hljs-params">|                IPv4数据报格式 32bit                |</span></span><br><span class="ruby"><span class="hljs-params">| :------------------------------------------------: |</span></span><br><span class="ruby"><span class="hljs-params">| 版本 \|</span> 首部长度 \<span class="hljs-params">| 服务类型 \|</span> 数据报长度（字节） <span class="hljs-params">|</span></span><br><span class="ruby"><span class="hljs-params">|         16比特标识 \|</span> 标志 \<span class="hljs-params">| 13比特片偏移         |</span></span><br><span class="ruby"><span class="hljs-params">|           寿命 \|</span> 上层协议 \<span class="hljs-params">| 首部检验和           |</span></span><br><span class="ruby"><span class="hljs-params">|                   32比特源IP地址                   |</span></span><br><span class="ruby"><span class="hljs-params">|                  32比特目的IP地址                  |</span></span><br><span class="ruby"><span class="hljs-params">|                 选项（如果有的话）                 |</span></span><br><span class="ruby"><span class="hljs-params">|                        数据                        |</span></span><br><br><span class="ruby">- 版本：<span class="hljs-number">4</span>个比特，IP协议版本</span><br><br><span class="ruby">- 首部长度：<span class="hljs-number">4</span>个比特，用来确定数据部分从哪里开始，不包含选项的情况，数据报首部为<span class="hljs-number">20</span>字节</span><br><br><span class="ruby">- 服务类型：TOS，实时数据报，非实时数据报，用来确定数据报的优先级</span><br><br><span class="ruby">- 数据报长度：包括首部的IP数据报的总长度，<span class="hljs-number">16</span>比特，最大理论长度<span class="hljs-number">2</span>^ <span class="hljs-number">16</span>,<span class="hljs-number">65535</span></span><br><br><span class="ruby">- 标识、标志、片偏移：IP分片</span><br><br><span class="ruby">- 寿命：Time-To-Live TTL，每经过一个路由器，该值减<span class="hljs-number">1</span>，TTl为<span class="hljs-number">0</span>时丢弃，取保数据报不会永远在路由选择环路中循环转发；</span><br><br><span class="ruby">- 协议：上层协议，<span class="hljs-number">6</span>为TCP，<span class="hljs-number">17</span>为UDP</span><br><br><span class="ruby">  \&gt; 协议号：网络层与运输层绑定到一起的粘合剂 &gt; &gt; 端口号：运输层与应用层绑定到一起的粘合剂 &gt; &gt; 链路层帧</span><br><br><span class="ruby">- 首部检验和：checksum，检验收到的ip数据报中的比特错误；</span><br><br><span class="ruby">  - 只对首部做检验</span><br><span class="ruby">  - 计算方式：将首部中的每<span class="hljs-number">2</span>个字节，也就是<span class="hljs-number">16</span>个比特相加在进行反码运算；</span><br><span class="ruby">  - 每个路由器都要对每个收到的IP数据报进行首部检验和的计算，检测出差错就丢弃，因为TTL每次都会减<span class="hljs-number">1</span>，所有路由器会每次重新计算检验和并放置到数据报的检验和位置</span><br><span class="ruby">  - IP协议和TCP/UDP协议都需要进行检验和</span><br><span class="ruby">    <span class="hljs-number">1</span>. IP数据报只是对数据报的首部进行检验</span><br><span class="ruby">    <span class="hljs-number">2</span>. TCP/UDP是对整个报文段进行检验，而且报文段就是IP数据报的数据部分</span><br><span class="ruby">    <span class="hljs-number">3</span>. TCP原则上可以运行在其他协议上 如ATM</span><br><br><span class="ruby">- 源和目的IP地址</span><br><br><span class="ruby">- 选项：允许IP首部被扩展，很少使用，已经在IPv6中去除</span><br><br><span class="ruby">- 数据：有效载荷，运输层报文段，或者ICMP报文</span><br><br><span class="ruby">&gt; 对于无 “选项” 的IP数据报首部总长度为<span class="hljs-number">20</span>个字节；</span><br><span class="ruby">&gt;</span><br><span class="ruby">&gt; 如果IP数据报承载了TCP报文段，则数据报承载了<span class="hljs-number">20</span>字节的IP数据报首部，<span class="hljs-number">20</span>字节的运输层TCP报文段的首部，及应用层报文；</span><br><br><span class="ruby"><span class="hljs-comment">#### IP数据报分片</span></span><br><br><span class="ruby">- 对于不同的链路层协议，其能承载的网路层数据报的长度不同，以太网协议能承载<span class="hljs-number">1500</span>字节的数据，某些广域网链路帧可承受不超过<span class="hljs-number">576</span>字节的数据；</span><br><span class="ruby">- **“最大传送单元”**：Maximum Transmission Unit, MTU, 一个链路层数据帧能够承载的最大数据量；</span><br><span class="ruby">- 发送方和接收方的路径上的每段链路可能使用不同的链路层协议，每种协议都可能由不同的MTU；</span><br><span class="ruby">- 对于过大的IP数据报，超过链路MTU的情况下，需要对IP数据报做分片；单独的链路帧将封装这些较小的IP数据报；然后将链路帧发送到链路上，每个较小的数据报为**“片”** fragment</span><br><span class="ruby">- 分片方法：</span><br><span class="ruby">  - 发送端该数据报设置源目的地址的同时，会贴上“标识”，为每个发送的数据报标识加<span class="hljs-number">1</span>；</span><br><span class="ruby">  - 路由器需要对数据报分片时，每个数据报都会由源目的地址和自己的标识号；</span><br><span class="ruby">  - 目的主机通过标识号确定那些数据报（片）是同一个大的数据报；</span><br><span class="ruby">  - 最后一片的标志比特为<span class="hljs-number">0</span>，其他片的标志比特为<span class="hljs-number">1</span>，目的是让目的端确定已经收到了所有的片；</span><br><span class="ruby">  - 偏移字段用来指定该片在数据报中的位置，目的端按照顺序组装，同时也可以确定数据报是否有片丢失；</span><br><span class="ruby">- 目的端，只有当IP层已经完成了重构初始IP数据报时，有效载荷才会被传递给运输层；如果一片或者多片没有到达目的地，则不完整的数据报会被丢弃，不会交给运输层；TCP超时重传、选择重传、快速重传</span><br><span class="ruby">- Jolt2 DoS攻击</span><br><br><span class="ruby"><span class="hljs-comment">### 4.4.2 IPv4 编址</span></span><br><br><span class="ruby">- 主机与路由器连入网络</span><br><br><span class="ruby">  - 一台主机通常只有一条链路连接到网络；</span><br><span class="ruby">  - 主机和物理链路之间的边界叫做**接口 interface**；</span><br><span class="ruby">  - 一个ip地址与一个接口相关联，不与主机及路由器相关联；</span><br><span class="ruby">  - IP地址，32bit，点分十进制法书写；</span><br><span class="ruby">  - 因特网处NAT之外的每台主机的接口都有一个唯一的IP地址；</span><br><span class="ruby">  - IP地址的一部分由连接的子网来决定；</span><br><span class="ruby">  - 例子：</span><br><span class="ruby">    - <span class="hljs-number">3</span>台主机与<span class="hljs-number">1</span>台路由器相连，<span class="hljs-number">4</span>个接口的ip地址的前24bit相同；</span><br><span class="ruby">    - <span class="hljs-number">3</span>个主机的接口与一个路由器的接口形成一个子网（subnet）；</span><br><span class="ruby">    - IP编址为这个子网分配一个地址，**”/<span class="hljs-number">24</span>“**，为子网掩码（network mask），这表示32bit中最左侧的<span class="hljs-number">24</span>比特定义了子网地址；</span><br><span class="ruby">    - 任何需要连入该子网的主机，ip地址都需要具有与前24bit子网地址相同的形式；</span><br><span class="ruby">    - 确定网络中子网的方法：</span><br><span class="ruby">      - 分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口“端接”隔离的网络端点，隔离的网络中的每一个都是一个子网（subnet）</span><br><span class="ruby">    - 一个具有“多个以太网段”和点对点链路的组织将具有多个子网；</span><br><br><span class="ruby">- 地址分配策略：</span><br><br><span class="ruby">  - 无类别域间路由选择（Classless Interdomain Routing，CIDR）</span><br><span class="ruby">  - CIDR将子网地址划分为两部分，表示为a.b.c.d/x，其中x表示地址的第一部分的比特数；</span><br><span class="ruby">  - a.b.c.d/x 的地址的x 最高比特构成了ip地址的网络部分，地址的前缀（prefix）（网络前缀）；</span><br><span class="ruby">  - 路由选择协议，转发只考虑该网络前面的前缀比特x，这就减少了路由器中转发表的长度；</span><br><span class="ruby">  - 实践原则：</span><br><span class="ruby">    - 地址聚合 address aggregation：使用单个网络前缀通告多个网络或多个子网的能力</span><br><span class="ruby">    - 也称作 路由聚合 route aggregation，路由摘要 route summarization</span><br><span class="ruby">  - 一个地址剩余的<span class="hljs-number">32</span>-x比特用来区分内部设备；只有内部设备连接的内部路由器在转发分组时，才会考虑这些剩余的bit；低级的bit可能有另外的子网结构；</span><br><span class="ruby">    - 例如：a.b.c.d/<span class="hljs-number">21</span>中的前<span class="hljs-number">21</span>个比特表示当前组织的网络前缀，a.b.c.d/<span class="hljs-number">24</span>表示组织内部的子网；</span><br><span class="ruby">  - 分类编址，旧方式</span><br><span class="ruby">  - ip广播地址 <span class="hljs-number">255.255</span>.<span class="hljs-number">255.255</span>，当一台主机向广播目的地址发送数据报时，该报文会交付给同一子网内所有的主机；</span><br><br><span class="ruby">- 获取地址</span><br><br><span class="ruby">  - 从ISP获取，因特网名字和编号分配机构获取；（Internet Corporation <span class="hljs-keyword">for</span> Assigned Names <span class="hljs-keyword">and</span> Numbers，ICANN）</span><br><br><span class="ruby">- DHCP 动态主机配置协议</span><br><br><span class="ruby">  - DHCP允许主机自动获取（被分配）IP地址，可以配置，在每次连接外部网络时都能获得相同的IP地址，或者被分配一个**临时的IP地址**（temporary IP address）；</span><br><span class="ruby">  - DHCP还允许主机得知，子网掩码，第一跳路由器地址（默认网关），与本地DNS服务器地址</span><br><span class="ruby">  - DHCP为 **即插即用协议** plug-<span class="hljs-keyword">and</span>-play protocol</span><br><span class="ruby">  - DHCP在主机加入或者 离开网络时，DHCP服务器会更新可用IP地址表；一台机器加入，则从当前可用地址池中分配任意一个地址；主机离开时，地址会回收到该地址池中；</span><br><span class="ruby">  - 客户-服务器协议，客户为新到达的主机，客户需要获取一个自身使用的IP地址和网络配置信息；如果该网络中没有DHCP服务器，则需要一个DHCP中继代理；</span><br><span class="ruby">  - 对于新到达的主机DHCP的四个步骤：</span><br><span class="ruby">    <span class="hljs-number">1</span>. DHCP服务器发现，DHCP发现报文（DHCP discover message)，客户使用UDP的DHCP发现报文，以广播地址<span class="hljs-number">255.255</span>.<span class="hljs-number">255.255</span>作为目的地址，本机源地址<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>作为源地址，<span class="hljs-number">67</span>作为目标端口，DHCP客户将IP数据报传递给链路层，链路层将帧广播到所有与该子网连接的子网；</span><br><span class="ruby">    <span class="hljs-number">2</span>. DHCP服务器提供，DHCP服务器收到报文后，用DHCP提供报文（DHCP offer message）向客户做出响应；仍然使用广播地址</span><br><span class="ruby">       <span class="hljs-number">1</span>. 提供报文包括：发现报文的事务ID，向客户推荐的IP地址、网络掩码及IP地址租用期（address lease time）</span><br><span class="ruby">    <span class="hljs-number">3</span>. DHCP请求，客户从多个DHCP服务器中选择一个，并向服务器发送DHCP请求响应（DHCP request message）进行响应，回显配置参数；</span><br><span class="ruby">    <span class="hljs-number">4</span>. DHCP ACK，服务器用DHCP ACK报文对DHCP请求报文进行确认响应；</span><br><span class="ruby">  - 客户收到DHCP ACK之后，交互完成，客户可用在租用期之内使用分配的IP地址，如果超时后还希望继续使用，DHCP提供一种机制允许用户更新对地址的租用；</span><br><br><span class="ruby">- 网络地址转换 NAT Network Address Translation</span><br><br><span class="ruby">  - NAT**“使能”**路由器对于外部网络来说，就是一台具有单一ip的设备，所有离开这个NAT子网的数据报，都有同一个源地址IP，所有进入该网络的数据报都有同一个相同的目的IP；</span><br><br><span class="ruby">  - 本质：NAT使能路由器对外界隐藏了内部网络的细节；</span><br><br><span class="ruby">  - 在此网络内部，有独立的NAT-DHCP服务为内部的设备分配IP，路由器从ISP的DHCP服务获取外部IP；</span><br><br><span class="ruby">  - **NAT转发表** NAT traslation table</span><br><br><span class="ruby">    - 表中包含了WAN端的IP地址和端口 及 映射的 LAN端 IP地址和端口</span><br><span class="ruby">    - 对于本地子网要发送的数据报，NAT会将内部子网主机的IP地址及端口号，记录在转发表的LAN端，NAT路由器收到数据报后会生成一个新的源端口（选择当前任意一个不在转换表中的端口，支持超过<span class="hljs-number">60</span> <span class="hljs-number">000</span>个并行的广域网IP地址连接），并将**数据报中的端口改为新的源端口，IP地址改为NAT的接口的广域网IP地址，并将数据报发送到目的地址；目的主机无法感知数据报中的源IP和端口都经过NAT协议的改装；</span><br><span class="ruby">    - 目的端响应报文到达NAT路由器时，路由器会使用数据报中的源IP地址和源端口检索出内部子网主机的ip和端口，并改写数据报的目的IP和目的端口，并向主机转发该数据报；</span><br><br><span class="ruby">    &gt; 主机通过DHCP服务器，获取了第一跳路由器的地址（网关），和自己的IP地址、子网掩码、DNS域名解析服务器的IP地址，主机会将包含目的IP和端口号的数据报直接发送到第一跳路由器（中间可能会经过NAT服务，例如家庭路由器上运行的NAT服务），路由器会对分组进行转发；</span><br><br><span class="ruby">  - NAT对P2P应用的影响：连接反转，NAT穿越</span><br><br><span class="ruby">- UPnP，即插即用协议，plug-<span class="hljs-keyword">and</span>-play-protocol</span><br><br><span class="ruby">  - UPnP允许外部之际使用TCP或UDP向NAT化的主机发展期通信会话；UPnP提供了有效的NAT穿越解决方案；</span><br><span class="ruby">  - UPnP协议的主要作用是：允许主机发现并配置NAT协议</span><br><span class="ruby">  - 使用UPnP，在主机上运行的应用程序能够为某些请求的公共端口号，请求一个NAT映射；UPnP让应用程序知道公共IP和公共端口，应用程序就可以将该公共IP和公共端口通知到目的主机，目的主机通过公共IP和公共端口与源主机通信；</span><br><br><span class="ruby"><span class="hljs-comment">### 4.4.3 因特网控制报文协议 ICMP</span></span><br><br><span class="ruby">- **ICMP协议 Internet Control Message Protocol**，用于主机和路由器之间彼此沟通网络层信息，如差错报告；</span><br><br><span class="ruby">  - 例如在通常的应用层协议中收到的“目的网络不可达”的错误报文，就是由ICMP产生的；</span><br><span class="ruby">  - 当路由器无法找到一条路径通向目的地址时，该路由器就会向源主机发出类型<span class="hljs-number">3</span>的ICMP报文；</span><br><br><span class="ruby">- ICMP为IP的一部分，但是在体系机构上位于IP协议之上；ICMP报文段承载在IP数据报中；ICMP报文也时IP有效载荷；</span><br><br><span class="ruby">- 主机收了指明了上层协议为ICMP的IP数据报时，解析出来的数据报内容会发送到ICMP服务；</span><br><br><span class="ruby">- ICMP报文字段包括：</span><br><br><span class="ruby">  - 类型字段</span><br><br><span class="ruby">  - 编码字段</span><br><br><span class="ruby">  - 引起ICMP报文生成的IP数据报的首部和前<span class="hljs-number">8</span>个字节的内容；用于发送方确定出错的数据报</span><br><br><span class="ruby">    - ICMP类型 编码 描述</span><br><span class="ruby">    - <span class="hljs-number">4</span> <span class="hljs-number">0</span> 源抑制 拥塞控制 这里的拥塞控制的方式：路由器向主机发送一个ICMP源抑制报文，强制主机减小其发送速率，TCP有自己的拥塞控制机制；</span><br><br><span class="ruby">    ![img](<span class="hljs-symbol">file:</span>/<span class="hljs-regexp">//</span><span class="hljs-symbol">C:</span>/%5CUsers%5Cteddy%5COneDrive%5C2020%5CCS-Learning-curve%5C%E7%BD%<span class="hljs-number">91</span>%E7%BB%9C%5CICMP%E7%B1%BB%E5%9E%8B.png)</span><br><br><span class="ruby">- ping程序基于ICMP的工作原理</span><br><br><span class="ruby">  - ping程序发送一个 **ICMP** 类型<span class="hljs-number">8</span>编码<span class="hljs-number">0</span>的报文到指定主机</span><br><span class="ruby">  - 目的主机收到回显echo请求，目的主机返回一个**类型<span class="hljs-number">0</span>，编号<span class="hljs-number">0</span>** 的ICMP回显回答；</span><br><span class="ruby">  - linux操作系统支持ping服务器，该服务不是一个进程（[源代码](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/torvalds</span><span class="hljs-regexp">/linux/blob</span><span class="hljs-regexp">/master/net</span><span class="hljs-regexp">/ipv4/ping</span>.c)）</span><br><br><span class="ruby">- IP协议规则：路由器丢弃一个数据报并发送一个ICMP告警报文给源主机，告警报文包含路哟求名称和IP地址；</span><br><br><span class="ruby">- Traceroute使用特定TTL值的UDP报文来探测源和目的之间的路由器的数量和标识，以及两台主机之间的时延，对于到达目的主机的UDP报文段，由于端口不可达，所有目的主机会返回一个ICMP报文；</span><br><br><span class="ruby">&gt; 防火墙和入侵检测系统（IDS），关注安全性PAGE238</span><br><span class="ruby">&gt;</span><br><span class="ruby">&gt; 防火墙可用阻挡ICMP回显请求分组，从而防止ping检测</span><br><span class="ruby">&gt;</span><br><span class="ruby">&gt; 防火墙也可以基于IP地址和端口号配置特殊的过滤策略</span><br><span class="ruby">&gt;</span><br><span class="ruby">&gt; IDS位于网络边界，执行**“深度分组检查”**，检查数据报的首部，检查有效载荷；并分享分组特征数据库</span><br><br><span class="ruby"><span class="hljs-comment">### 4.4.4 IPv6</span></span><br><br><span class="ruby">- IPv6数据报格式</span><br><br><span class="ruby"><span class="hljs-params">|                32bit                 |</span></span><br><span class="ruby"><span class="hljs-params">| :----------------------------------: |</span></span><br><span class="ruby"><span class="hljs-params">|      版本 \|</span> 流量类型 \<span class="hljs-params">| 流标签      |</span></span><br><span class="ruby"><span class="hljs-params">| 有效载荷长度 \|</span> 下一个首部 \<span class="hljs-params">| 跳限制 |</span></span><br><span class="ruby"><span class="hljs-params">|          源地址 （128bit）           |</span></span><br><span class="ruby"><span class="hljs-params">|         目的地址 （128bit）          |</span></span><br><span class="ruby"><span class="hljs-params">|                 数据                 |</span></span><br><br><span class="ruby">- IPv6数据报格式变化</span><br><span class="ruby">  - 扩大的地址容量</span><br><span class="ruby">    - 地址容量从32bit扩大到<span class="hljs-number">128</span>比特，用<span class="hljs-number">16</span>进制表示；</span><br><span class="ruby">    - IPv6引入了**任播地址** （anycast address），用来将数据报交付给一组主机中的任意一个；</span><br><span class="ruby">  - 简化的高效的<span class="hljs-number">40</span>字节首部</span><br><span class="ruby">    - <span class="hljs-number">40</span>字节定长首部，去除IPv4中的选项字段，允许更快的处理IP数据报</span><br><span class="ruby">  - 流标签与优先级</span><br><span class="ruby">    - Flow：给属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流；</span><br><span class="ruby">    - 音频和视频的传输就是一种“流”</span><br><span class="ruby">    - 流量类型字段，类似与IPv4中的TOS字段，用于给出一个流中某些数据报的优先级，用来指示某些应用程序的数据报比其他应用有更高的优先权；</span><br><span class="ruby">- IPv6数据报的结构更简单，更高效：</span><br><span class="ruby">  - 版本：4bit，用于标识IP版本号； <span class="hljs-number">6</span></span><br><span class="ruby">  - 流量类型：8bit，与IPv4中的TOS字段含义相似</span><br><span class="ruby">  - 流标签：20bit，用于标识一条数据报的流</span><br><span class="ruby">  - 有效载荷长度：16bit，给出IPv6数据报中定长<span class="hljs-number">40</span>字节的首部后面的数据部分的比特数；</span><br><span class="ruby">  - 下一个首部：标识数据报中的内容需要交付给，哪个协议（TCP/UDP）与IPv4中的上层协议字段相同</span><br><span class="ruby">  - 跳限制：转发数据报的每台路由器对该值减<span class="hljs-number">1</span>，当计数为<span class="hljs-number">0</span>时，数据报被丢弃；用来限制数据报转发的路由器数量，防止数据报在环路中一直存在；</span><br><span class="ruby">  - 源地址和目的地址：128bit的源地址和目的地址字段</span><br><span class="ruby">  - 数据：有效载荷部分，包括运输层报文段的首部及应用层数据部分</span><br><span class="ruby">- IPv4数据报中的字段在IPv6中已不存在</span><br><span class="ruby">  - 分片/重新组装：IPv6不允许路由器对数据报进行分片和组装；分片和重新组装只在源和目的端执行；当路由器遇到较大分组无法转发到链路时（如超过<span class="hljs-number">1500</span>个字节），直接将数据报丢弃，并向发送方回复“分组太大的” ICMP差错报文，ICMP报文也封装在IP数据报中；这样发送端收到ICMP报文后，将数据报在端系统出进行分片，从而加快了转发速率；</span><br><span class="ruby">  - 首部检验和：为了快速处理IP分组，将检验和去除，数据报中只有运输层报文端有首部检验和做检验；（IPv4的耗时主要体现在每个数据报都有自己的TTL，所有每个路由器进行检验后，还需要更新数据报中的检验和）</span><br><span class="ruby">  - 选项：选项字段去除，但是任然有选项的存在，如“下一个首部”字段指向的位置有可能时“选项”</span><br><span class="ruby">- IPv4到IPv6的迁移</span><br><span class="ruby">  - **双栈**， 有发送和接收IPv4，IPv6两种数据报的能力；</span><br><span class="ruby">  - IPv6/IPv4节点必须有IPv6和IPv4两种地址；</span><br><span class="ruby">  - IPv6数据报可以转换成IPv4数据报，但是会丢失IPv6数据报首部 一些在IPv4中无对应项的字段信息；</span><br><span class="ruby">  - 建隧道（tunneling），两个端系统进行IPv6数据报的交换，但是中间有一个IPv4的路由器，两个IPv6路由器之间的IPv4路由器的集合为 **隧道** Tunnel，借助隧道，在隧道发送端的IPv6结点，将IPv6数据报方到一个IPv4数据报的数据部分（有效载荷），该IPv4数据报通过中间路由被转发到隧道接收端，隧道接收到取出IPv6的数据，然后再为IPv6的数据报提供转发；</span><br><br><span class="ruby"><span class="hljs-comment">### 4.4.5 IP安全性</span></span><br><br><span class="ruby">- IPsec 和 密码学基础</span><br><span class="ruby">- IPsec兼容IPv4，IPv6</span><br><span class="ruby">- IPsec只在端系统中可用，运输模式</span><br><span class="ruby">  - 两个端系统先创建一个IPsec会话，IPsec是面向连接的</span><br><span class="ruby">  - 发送端运输层向IPsec传递一个报文段，IPsec加密该报文段，并在报文段上附加安全性字段，再封装到IP数据报中；</span><br><span class="ruby">  - 目的主机，IPsec将解密报文段并将脱密的报文段发送给运输层；</span><br><span class="ruby">- IPsec会话提供的服务包括：</span><br><span class="ruby">  - 密码技术约定；两台主机之间的加密算法和密钥保持一致</span><br><span class="ruby">  - IP数据报有效载荷加密；</span><br><span class="ruby">  - 数据完整性，IPsec允许主机验证数据报的首部，保证被加密的有效载荷在传输过程中没有被修改过</span><br><span class="ruby">  - 初始鉴别，受信任的源收到IPsec数据报，确信数据报中的源IP是该数据报的实际源</span><br><span class="ruby">- 两台主机之间创建了IPsec会话，两主机之间的所有TCP和UDP的报文段都将会被加密和鉴别；</span><br><br><span class="ruby"><span class="hljs-comment">## 4.5 路由选择算法</span></span><br><br><span class="ruby">- 主机通常直接和一台路由器相连</span><br><br><span class="ruby">  - 该路由器为该主机的 **默认路由器 default router**</span><br><br><span class="ruby">  - **第一跳路由器 first-hop router**</span><br><br><span class="ruby">  - 源主机的默认路由器为：**源路由器(source router)**</span><br><br><span class="ruby">  - 目的主机的默认路由器为**目的路由器 destination router**</span><br><br><span class="ruby">  - 路由选择： 源路由器到目的路由器的路由选择</span><br><br><span class="ruby">    &gt; <span class="hljs-params">| 源主机 —&gt; (默认路由器 |</span> 第一跳路由器 <span class="hljs-params">| 默认网关 |</span> 源路由器) —&gt; &#123;中间链路及路由器&#125; —&gt; 目的路由器 —&gt; 目的主机 <span class="hljs-params">|</span></span><br><span class="ruby">    &gt; <span class="hljs-params">| --------------------- |</span> ------------ <span class="hljs-params">| -------- |</span> --------------------------------------------------------- <span class="hljs-params">|</span></span><br><span class="ruby">    &gt; <span class="hljs-params">|                       |</span>              <span class="hljs-params">|          |</span>                                                           <span class="hljs-params">|</span></span><br><br><span class="ruby">- 路由选择算法的目的：</span><br><br><span class="ruby">  - 给定一组路由器及连接路由器的链路，路由选择算法就是要找到一条从源路由器到目的路由器的**“好”**路径；</span><br><span class="ruby">  - 简单的网络结构抽象可以用“图”graph（无向图）的数据结构来表示，G=（N，E），N表示图中的每个顶点的集合，E表示每条弧也就是每个路由器之间的链路的集合；每条弧上的权值代表这条链路的费用（费用反应出了一条边的物理链路的长度、速度、金融费用）；</span><br><span class="ruby">    - 属于E的一条弧的顶点 (x, y) ，y也被称为x的邻居（neighbor）；</span><br><span class="ruby">    - 路由选择算法的目标是找到**最低费用路径**</span><br><span class="ruby">    - 源路由器和目的路由器之间最少链路数量为**最短路径**；</span><br><span class="ruby">    - 当一个位置或结点有该网络的完整信息，再该节点的路由选择算法就是“集中式的”</span><br><br><span class="ruby">- 分类</span><br><br><span class="ruby">  - 全局式的路由选择算法（global routing algorithm）</span><br><span class="ruby">    - 该算法为“集中式的全局路由选择算法”</span><br><span class="ruby">    - 输入为所有节点的连通性及链路的费用，算法执行前需要获取全局的完整信息；</span><br><span class="ruby">    - 全局状态信息：**链路状态算法**</span><br><span class="ruby">  - 分散式路由选择算法（decentralized routing algorithm）</span><br><span class="ruby">    - 以迭代、分布式的方式计算出最低费用路径，迭代的每个节点逐渐的计算到达某目的节点的最低费用；</span><br><span class="ruby">    - 距离向量算法（Distance-Vector， DV）</span><br><br><span class="ruby">- 第二种广义分类</span><br><br><span class="ruby">  - 静态路由选择算法（static routing algorithm），路由变化缓慢，通常人工调整</span><br><span class="ruby">  - 动态路由选择算法（dynamic routing algorithm），网络流量负载或者拓扑发生变化时改变路由选择路径；动态算法周期性的运行或者对拓扑变化直接响应</span><br><br><span class="ruby">- 第三种分类</span><br><br><span class="ruby">  - 负载敏感算法（load-sensitive algorithm）</span><br><span class="ruby">  - 负载迟钝算法（load-insensitive algorithm），链路费用无法直接反应链路拥塞水平</span><br><br><span class="ruby"><span class="hljs-comment">### 4.5.1 链路状态路由选择算法 Link-State</span></span><br><br><span class="ruby">- 链路状态算法中，网络拓扑和所以的链路状态都是已知的，并且作为LS算法的输入</span><br><span class="ruby">- 实践中</span><br><span class="ruby">  - 让每个结点向网络中所有其他结点广播链路状态分组</span><br><span class="ruby">  - 每个链路状态分组包含它所连接的链路的特征和费用 例如OSPF路由选择协议</span><br><span class="ruby">  - 链路状态广播算法 （link state broadcast）来完成</span><br><span class="ruby">  - 广播的结果是该网络中的所有结点都具有了与该网络等同的、完整的视图</span><br><span class="ruby">  - 每个结点都能运行LS算法计算出最低费用的集合</span><br><span class="ruby">- Dijkstra算法 - Prim算法 O(n^<span class="hljs-number">2</span>)</span><br><span class="ruby">  - Dijkstra算法计算源结点到网络中其他所有结点最低费用路径</span><br><span class="ruby">  - 迭代算法，经过k次迭代后，可以直到k个目的结点的最低费用路径</span><br><span class="ruby">  - 算法思想：</span><br><span class="ruby">    - 保存每个结点的最低费用，和集合N’</span><br><span class="ruby">    - 每次迭代找出不属于N’且最小费用的节点，将它加入N’，并遍历它的所有邻居节点，并更新最小费用；</span><br><span class="ruby">    - 迭代次数为节点总数</span><br><span class="ruby">  - 算法步骤：</span><br><span class="ruby">    <span class="hljs-number">1</span>. 将源节点加入集合N’中，获取和源节点相邻节点，最小费用为链路费用，如果不相邻最为正无穷</span><br><span class="ruby">    <span class="hljs-number">2</span>. 找到上一次所有链路费用最小的点x，将x加入N‘，遍历x的所有邻居节点，并为这些节点更新其最小链路费用</span><br><span class="ruby">  - 通过对每个目的节点存放从源结点到目的结点的最低费用路径上的**”下一跳结点“**，结点中的转发表就能够根据此信息构建；</span><br><span class="ruby">  - 此算法的最差时间复杂都为 O(n^<span class="hljs-number">2</span>)，使用堆的数据结构，可以将时间复杂度降低到logn级别</span><br><span class="ruby">  - 当链路的费用依赖于当前链路所承载的流量时，链路状态选择算法会出现**”振荡“**，解决方式是确保路由器不同时运行LS算法；</span><br><br><span class="ruby"><span class="hljs-comment">### 4.5.2 距离向量路由选择算法</span></span><br><br><span class="ruby">- **距离向量 （Distance-Vector）**算法</span><br><br><span class="ruby">  - 迭代：获取信息和执行计算的过程需要持续到邻居之间无更多的信息交换为止</span><br><span class="ruby">  - 异步：不要求所有结点步骤一致的进行操作</span><br><span class="ruby">  - 分布式：每个结点要从一个或者多个直接相邻的结点获取信息，执行计算，将结果分发给邻居</span><br><br><span class="ruby">  \&gt; Bellman-Ford方程： &gt; &gt; dx (y) = min v &#123; c(x, v) + d v (y) &#125; &gt; &gt; 获取x到所有邻结点的费用，取从这些邻结点v到目标结点y的最小费用，则x到y的最小费用是所以邻居v的 **c(x, v) + d v (y)** 的最小值 &gt; &gt; 详见：Page <span class="hljs-number">258</span></span><br><br><span class="ruby">- **DV算法的基本思想**</span><br><br><span class="ruby">  - 每个结点x，对N中的所有结点，估计从自己到结点y的最低费用；</span><br><span class="ruby">  - 每个结点x，维护的信息如下：</span><br><span class="ruby">    - 对于每个邻居v，从x到直接邻居v的费用 c(x, v)</span><br><span class="ruby">    - 结点x的距离向量，包含了x到N中所有目的地y的费用估计值</span><br><span class="ruby">    - 每个邻居的距离向量，x的每个邻居v</span><br><span class="ruby">  - 算法思想的理解：</span><br><span class="ruby">    - 该算法以分布式的方式，在网络中，每个结点接收相邻结点的距离向量副本，每次更新都会触发结点向响铃结点广播自己最新的距离向量；</span><br><span class="ruby">    - 每个结点根据B-F方程的思想不断更新自己缓存的到其他每个结点的最小距离；（最低费用）</span><br><span class="ruby">    - 当所有结点触发的更新完成后，也就是不再有异步更新时，该网络中的路由选择表趋于稳定；</span><br><span class="ruby">  - [路由器](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/zh.wikipedia.org/wiki</span><span class="hljs-regexp">/路由器)需要周期性与相邻的路由器交换更新通告（routing updates），动态建立路由表，以决定最短路径。</span></span><br><br><span class="ruby">- 伪代码：</span><br><br></code></pre></td></tr></table></figure>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 对每个路由结点x的算法 Initialization: for all destination y in N:     Dx(y) = c(x,y)    // 获取结点到网络中其他结点的距离向量（如果y和x不相邻，则初始化为正无穷）    for each neighbor w:     Dw(y) = ? for all for all destination y in N  //初始化每个邻居结点w到每个结点y的距离向量    for each neighbor w:     send distance vector Dx = [Dx(y): y in N] to w // 将当前结点x到其他结点y的距离向量发送给每个邻居结点 Loop    wait //一直处于等待状态。等待结束的条件：1. 发现与当前结点相连的链路费用发生变化 2. 接收到邻居结点发送来的距离向量集合           for each y in N:     Dx(y) = minv &#123;c(x, v), Dv(y)&#125;      // 结点对收到的邻居结点的距离向量集合，x到y的最小费用是，x到邻居结点v+邻居结点v到y的距离向量的最小值，从所有邻居中找到这个最小值     if Dx(y) changed for any destination y        send distance vector Dx = [Dx(y): y in N] to all neighbors // 如果当前链路有费用改变，则直接向邻居结点发送距离向量集合 </code></pre></li><li><p>再该分布式、异步的算法中，每个结点不时的向它的每个邻居发送它的距离向量副本，当结点x从它的任意一个邻居v接收到新的距离向量，保持v的距离向量，然后使用Bellman-Ford方程更新他自己的距离向量，对每个节点；结点x的距离向量更新后，向每个邻居发送更新后的向量；最终结果会收敛到最低费用路径；</p></li><li><p><strong>TODO</strong> ： PAGE258</p></li></ul><blockquote><p>Dijkstra算法，LS算法是全局的，在运行之前需要先获取整改网络的完整信息</p><p>DV算法是分布式和异步的，每个结点具有的信息是他到直接相邻结点的链路费用，和它收到的这些邻居发给它的信息；</p><p>DV算法的实践： RIP、BGP、ISO IDRP、Novell IPX</p></blockquote><ul><li>从邻居接收更新的距离向量、重新计算<strong>路由选择表</strong> 和通知邻居到目的地的最低费用路径的费用已经发送变化，这个过程会持续下去，直到无更新报文发送为止；这时算法进入等待状态，直到再次有线路费用变化触发算法；</li></ul><h5 id="1-距离向量算法：链路费用改变与链路故障"><a href="#1-距离向量算法：链路费用改变与链路故障" class="headerlink" title="1. 距离向量算法：链路费用改变与链路故障"></a>1. 距离向量算法：链路费用改变与链路故障</h5><ul><li>在链路费用变化的过程中，如果某个结点接受了邻居结点的信息后，路由选择表并没有更新，则该结点不再向其邻居结点发送信息；</li><li><strong>路由选择环路 routing loop</strong><ul><li>分组将在两个结点之间不停的转发，例子见Page262</li><li>无穷级数问题 count-to-infinity</li></ul></li></ul><h5 id="2-距离向量算法：增加毒性逆转"><a href="#2-距离向量算法：增加毒性逆转" class="headerlink" title="2. 距离向量算法：增加毒性逆转"></a>2. 距离向量算法：增加毒性逆转</h5><ul><li><strong>毒性逆转 （poisoned reverse）</strong>，可以避免路由环路</li><li>思想：例子PAGE 262</li><li>无法解决3个或者更多系欸但的环路问题</li></ul><h5 id="3-LS与DB路由选择算法的比较"><a href="#3-LS与DB路由选择算法的比较" class="headerlink" title="3. LS与DB路由选择算法的比较"></a>3. LS与DB路由选择算法的比较</h5><ul><li><p>DV和LS算法采用互补的方法来解决路由选择计算问题；</p></li><li><p>比较 N为结点集合（路由器） E是边（链路）集合</p><ul><li><p>报文复杂性</p><ul><li><table><thead><tr><th>LS算法要求每个结点都知道网络中每条链路的费用，要求发送O(</th><th>N</th><th></th><th>E</th><th>)个报文；一条链路如果发生了改变，则需要向所有结点发送新报文；</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>DV算法要求每次迭代时，在两个直接相邻的结点之间交换报文；当链路费用发生变化时，DV算法仅在新的链路费用，导致与该链路相连的结点的最低费用改变时，才会向其他相邻结点传播费用信息，如果不在发生改变则不会在向相邻结点发送；</p></li></ul></li><li><p>收敛速度</p><ul><li><table><thead><tr><th>LS算法实现的时一个O(</th><th>N</th><th></th><th>E</th><th>)个报文的O(n^2)的时间复杂度</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>DV算法收敛较慢，而且遇到路由选择环路时，会遇到无穷计数的问题；</p></li></ul></li><li><p>健壮性</p><ul><li>LS：一个结点可以会损坏或者丢弃它收到的LS广播分组，但是LS结点只计算自己的转发表，每个结点各自接收广播分组，各自进行计算，提供了一定程度的健壮性；</li><li>DV算法：一个结点如果产生了错误的链路费用，会通知它所有的相邻结点，这个错误会一直扩散到整个网络的所有路由器上；</li></ul></li></ul></li></ul><h5 id="4-其他路由选择算法"><a href="#4-其他路由选择算法" class="headerlink" title="4. 其他路由选择算法"></a>4. 其他路由选择算法</h5><ul><li>因特网实践中仅有的两种类型的算法：LS算法和DV算法</li></ul><h3 id="4-5-4-层次路由选择"><a href="#4-5-4-层次路由选择" class="headerlink" title="4.5.4 层次路由选择"></a>4.5.4 层次路由选择</h3><ul><li><p>实践和路由选择算法模型</p><ul><li>规模，当前的因特网上路由器需要巨大容量的内存存储路由选择信息；路由器的LS广播的开销会导致没有剩余的带宽用来发送数据分组，大量路由器中算法将永远无法收敛；</li><li>管理自治，网络需要按照意愿进行管理，还需要和外部其他网络连接；</li></ul></li><li><p>自治系统 Autonomous System AS</p><ul><li><p>每个AS由一组通常处于相同管理控制下的路由器组成</p></li><li><p>相同的AS中的路由器全都运行的同样的路由选择算法（如一种LS或一种DV）,且拥有彼此信息；</p></li><li><p>在一个自治系统内运的路由选择算法：<strong>自治系统内部路由选择协议 intra-autonomous system routing protocol</strong></p></li><li><p>在AS内部有<strong>一台或者多台</strong>路由器 <strong>”网关路由器 gateway router“</strong>，负责向本AS之外的目的地转发分组；</p></li><li><p>源AS只有一台网关路由器，且只有一条通向外部AS的链路时，分组会直接通过该链路传输；</p></li><li><p>自治系统之间的路由选择协议（inter-autonomous system routing protocol），AS间路由选择协议</p><p>BGP4</p><ul><li>从AS间协议知道经过多个网关可达子网x</li><li>使用来自AS内部协议的路由选择信息，以决定到每个网关的 <strong>最低费用路径</strong> 的费用</li><li>热土豆路由选择（hot potato routing），选择具有最低费用的网关</li><li>从转发表确定通向最低费用网关的接口I，将（x，I）项田间道转发表中</li></ul></li></ul></li></ul><h2 id="4-6-因特网中的路由选择"><a href="#4-6-因特网中的路由选择" class="headerlink" title="4.6 因特网中的路由选择"></a>4.6 因特网中的路由选择</h2><blockquote><p>一个AS是一个处于相同的管理与技术控制下的路由器集合，在AS之间都运行相同的路由选择协议；每个AS通常又都包含多个子网；</p></blockquote><h3 id="4-6-1-自治系统内部的路由选择：RIP"><a href="#4-6-1-自治系统内部的路由选择：RIP" class="headerlink" title="4.6.1 自治系统内部的路由选择：RIP"></a>4.6.1 自治系统内部的路由选择：RIP</h3><ul><li><p>AS内部的路由选择方式，用于确定在AS内执行路由选择的方式</p></li><li><p>AS内路由选择协议，又称为：</p><p>内部网关协议 interior gateway protocol</p><p>，包括：</p><ul><li><strong>路由选择信息协议 Routing information Protocol RIP</strong></li><li><strong>开放最短路优先 Open Shortest Path First，OSPF</strong></li></ul></li></ul><h5 id="RIP-Routing-information-Protocol-RIP"><a href="#RIP-Routing-information-Protocol-RIP" class="headerlink" title="RIP Routing information Protocol RIP"></a>RIP Routing information Protocol RIP</h5><blockquote><p>最早使用的AS内部的路由选择协议，广泛应用</p></blockquote><ul><li><p><strong>距离向量协议</strong>，运行方式类似DV</p></li><li><p>RIP中费用从源路由器到目的子网；</p></li><li><p>RIP使用 <strong>”跳“</strong>，跳是沿着源路由器到目的子网的最短路径经过的<strong>子网数量</strong>；</p></li><li><p>一条路径的最大费用被限制为15，RIP的使用限制在网络直径不超过15跳的自治系统内；</p></li><li><p>DV协议：任何一台路由器的距离向量是从这台路由器到该AS中子网的最短路径距离的当前估计值；</p></li><li><p>路由器和相邻路由器的信息交换使用：<strong>RIP 响应报文 RIP response message</strong> 来交换，大约没30秒交换一i此；</p></li><li><p>由一台路由器发送的响应报文，包含该AS内多达25个目的子网列表，及发送方到每个子网的距离；</p></li><li><p>RIP响应报文：<strong>RIP通告 RIP advertisement</strong></p></li><li><p>每台路由器维护一张<strong>“路由选择表 routing table“</strong>；</p></li><li><p>路由选择表包括</p><ul><li>距离向量</li><li>转发表<ol><li>第一列：目的子网</li><li>第二列：沿最短路径到目的子网的路由器标识</li><li>第三列：到达目的地的跳数</li></ol></li></ul><table><thead><tr><th>目的子网</th><th>下一台路由器</th><th>到达目的地的跳数</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table></li><li><p>RIP每30秒相互交互一次，如果一台路由器180秒都没有从邻居收到报文，则认为邻居不再可达，RIP修改本地路由选择表，然后向其他邻居发送通告来传播该信息；</p></li><li><p>路由器也可以通过使用RIP报文，请求邻居到指定的目的地的费用；</p></li><li><p>路由器在UDP上使用端口520互相发送RIP请求与响应报文；</p></li><li><p><strong>RIP使用一个位于网络层IP协议之上的运输层UDP协议来实现网络层的路由选择功能</strong></p><ul><li>工作原理<ul><li>RIP在路由器操作系统中，以routed名称的进程运行，来维护路由选择信息和相邻的路由器上的routed进程交换报文；</li><li>因为RIP的实现是一个应用层进程，所有它能在标准的套接字上发送和接收报文，并使用标准的运输层协议；</li><li>RIP是一个运行在UDP上的应用层协议，但他实现的功能是网络层的功能；</li></ul></li></ul></li></ul><h3 id="4-6-2-自治系统内部的路由选择：-OSPF-Open-Shortest-Path-First，OSPF"><a href="#4-6-2-自治系统内部的路由选择：-OSPF-Open-Shortest-Path-First，OSPF" class="headerlink" title="4.6.2 自治系统内部的路由选择： OSPF Open Shortest Path First，OSPF"></a>4.6.2 自治系统内部的路由选择： OSPF Open Shortest Path First，OSPF</h3><ul><li><p>OSPF通常设置在上层的ISP中，RIP被设置在下层ISP和企业网中；</p></li><li><p>OSPF的路由协议规范是公众可用的；</p></li><li><p>OSPF核心：</p><ul><li>一个使用洪泛链路状态信息的链路状态协议</li><li>一个Dijkstra最低费用路径算法</li><li>使用OSPF，一台路由器构建了一副关于整个自治系统的完整拓扑图，路由器运行Dijkstra最短路径算法，以确定一个以自身 为根节点的到所有子网的最短路径数；</li><li>OSPF提供机制，为“给定链路权值集合”确定最低费用路劲路由选择</li></ul></li><li><p>原理</p><ul><li>OSPF，路由器向自治系统内所有其他路由器广播路由选择信息；</li><li>当一条链路发生变化，路由器就会广播链路状态信息，当链路状态未发生变化，路由器会周期性的广播链路状态信息（至少每30min）</li><li>OSPF报文，由IP协议承载，上层协议值为<strong>89</strong>，OSPF协议自己实现可靠报文传输、链路状态广播等功能</li><li>OSPF要检查链路正在运行，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库</li></ul></li><li><p>OSPF的优点</p><ul><li>安全；能够鉴别OSPF路由器之间的交换；使用鉴别，只有受到信任的路由器能参与AS内的OSPF协议；MD5散列值计算；</li><li>多条相同费用的路径；出现多条相同费用路径时，OSPF允许使用多条路径；</li><li>对单播和多播路由选择的综合支持；多播：使用现有的OSPF链路数据，为现有的OSPF链路状态广播机制增加了新型的链路状态通告；</li><li>支持在单个路由选择域内的层次结构；<strong>具有按层次结构构建一个自治系统的能力</strong></li></ul></li><li><p>一个OSPF自治系统可用配置成多个区域，每个区域都运行自己的OSPF链路状态路由选择算法；</p><ul><li><p>一个区域内每台路由器都向该区域其他所有路由器广播其链路状态</p></li><li><p>一个区域内，有一台或者多台<strong>区域边界路由器 area border router</strong>，负责为流向该区域以外的分组提供路由选择；</p></li><li><p>AS内只有一个OSPF区域配置成</p><p>主干（backbone）</p><p>区域；</p><ul><li>主干区域的主要作用是，为AS内其他区域之间的流量提供路由选择；</li><li>主干包含：AS内的所有区域边界路由器，和一些非边界路由器</li><li>在AS内的区域间的<strong>路由选择</strong>要求，分组首先到达一个<strong>区域边界路由器</strong>，再通过<strong>主干路由器</strong>到位于目的区域的区域边界路由器，然后再到最终目的地；</li></ul></li></ul></li><li><p>实践原则：设置OSPF链路权值，PAGE270</p></li></ul><h3 id="4-6-3-自治系统间的路由选择：BGP"><a href="#4-6-3-自治系统间的路由选择：BGP" class="headerlink" title="4.6.3 自治系统间的路由选择：BGP"></a>4.6.3 自治系统间的路由选择：BGP</h3><ul><li><p>RIP 和 OSPF 来决定位于相同AS内部的源和目的之间的路由选择路径；</p></li><li><p>跨越多个AS的源和目的之间的路由选择，<strong>边界网络协议 Border Gateway Protocol, BGP</strong></p></li><li><p>当今因特网中域间选择协议事实上的标准；BGP4或BGP</p></li><li><p>工作手段</p><ul><li>从相邻AS处获得子网可达信息</li><li>向本AS内部的所有路由器传播这些可达信息</li><li>基于可达性信息和AS策略，决定到达子网的 “好” 路由</li></ul><p>&gt; BGP 使得每个子网向因特网的其余部分通告自己的存在； &gt; &gt; BGP保证在因特网中的所有AS直到该子网以及如何到达；</p></li></ul><h5 id="1-BGP基础"><a href="#1-BGP基础" class="headerlink" title="1. BGP基础"></a>1. BGP基础</h5><ul><li>路由器通过使用<strong>”179“</strong>端口的半永久TCP连接，来交换”路由选择“信息；</li><li>半永久TCP连接：该连接位于两个不同AS的路由器的链路；</li><li>一个AS内部的路由器之间的BGP TCP连接：在AS内部形成网状TCP连接；</li><li>对于每条TCP连接，位于连接端点的两台路由器为<strong>“BGP对等放 BGP-peers”</strong>，沿着连接发送的BGP报文的TCP连接为<strong>BGP会话 BGP session</strong>，跨越两个AS的BGP会话为<strong>外部BGP会话 eBGP external BGP session</strong>，同一个AS中的会话为<strong>”内部BGP会话 iBGP internal BGP session”</strong></li></ul><blockquote><p>实践原则：PAGE 272</p></blockquote><ul><li>BGP使得每个AS直到经过其相邻AS可以到达那些目的地，BGP中，目的地不是主机而是Classless Inter-Domain Routing、<strong>CIDR</strong>化的前缀prefix，每个前缀代表一个子网或者一个子网的集合</li><li>任何AS中的<strong>网关路由器</strong>，接受到eBGP学习到的前缀后，该网关路由器使用它的iBGP会话来向该AS中的其他路由器发布这些前缀；</li><li>当路由器得知一个新前缀时，它为<strong>该前缀</strong>在其<strong>转发表</strong>中创建一个项；</li></ul><h5 id="2-路径属性和BGP路由"><a href="#2-路径属性和BGP路由" class="headerlink" title="2. 路径属性和BGP路由"></a>2. 路径属性和BGP路由</h5><ul><li><p>BGP中，一个自治系统由其全局唯一的<strong>自治系统号 Autonomous system Number ASN</strong>所标识；例如<strong>桩 stub</strong>AS通常没有ASN，桩AS仅仅承载源地址或者目的地址为本AS的流量；</p></li><li><p>类似与IP地址，AS号由ICANN地区注册机构分配</p></li><li><p>路由器通过BGP会话通告一个前缀，前缀中包含BGP属性（BGP attribute），带有属性的前缀叫做 一条BGP<strong>路由 route</strong>，BGP对等方彼此通告路由；</p><ul><li><p>属性 AS-PATH</p><ul><li>包含来前缀通告已经通过的AS</li><li>当一个前缀传送到一个AS时，该AS将它的ASN怎加到AS-PATH属性中；</li></ul></li><li><p>属性 NEXT-HOP</p><ul><li>是一个开始某AS-PATH的路由器接口</li><li>路由器利用NEXT-HOP属性正确的配置他们的转发表</li></ul></li><li><p>对于两条路由具有到前缀x的相同AS-PATH，但有不同的NEXT-HOP值对应于不同的对等链路；使用NEXT-HOP值的AS内部路由选择算法，路由器能够确定到每条对等链路的费用，使用热土豆路由选择来决定适当的接口；</p><blockquote><p>WIKI: 热马铃薯路由选择（Hot-potato routing）是在当前<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F">AS</a>接收到一个数据包后，使其停留在该AS中的时间尽可能短。在“热马铃薯路由”这个名字中，数据包被类比成了你手中的一个滚烫的马铃薯，因为它很烫，所以你想要尽可能快地把它传递给另一个人（另一个AS）</p></blockquote></li></ul></li><li><p>其他属性</p><ul><li><p>允许路由器对路由分配偏好测度的属性</p></li><li><p>指示前缀如何插入位于起始AS的BGP属性</p></li><li><p>当一台网关路由器接收到一台路由器的通告时，它使用其</p><p>输入策略（import policy）</p><p>来决定是否接收或者过滤该路由，是否设置某种属性；</p><ul><li>输入策略可能会过滤一条路由，因为AS可能不希望通过该路由AS-PATH中的某个AS来发送流量；</li><li>网关路由器也可能过滤一条路由，因为已经知道了一条相同前缀的<strong>偏好路由</strong></li></ul></li></ul></li></ul><h5 id="3-BGP路由选择"><a href="#3-BGP路由选择" class="headerlink" title="3. BGP路由选择"></a>3. BGP路由选择</h5><blockquote><p>BGP使用eBGP和外部建立会话，向外部路由器发布路由</p><p>BGP使用iBGP和内部路由器建立会话，向内部路由器发布路由</p><p>路由：带有BGP属性的ip前缀</p></blockquote><ul><li><p>对于BGP发布的路由，路由器可能到达任何一条前缀的多条路由，路由器进入路由选择进程，输入为路由器接收的所有的路由集合；</p></li><li><p>BGP顺序调用下列消除规则：</p><ul><li><p>路由被指定一个本地偏好值作为路由的属性；</p><ul><li>本地偏好，会被同一AS中其他路由器学习到；</li><li><strong>具有最高本地偏好的路由将被选择</strong></li></ul></li><li><p>在所有具有</p><p>相同本地偏好值</p><p>的路由中，具有最短AS-PATH的路由将被选择；</p><ul><li>BGP使用距离向量算法，距离测度使用AS跳数目；</li></ul></li><li><p>在所有具有</p><p>相同本地偏好值和相同AS-PATH长度</p><p>，选择最靠近NEXT-HOP路由器的路由；</p><ul><li>最靠近，指到达NEXT-HOP接口最低费用路由路径，使用AS内部算法来决定，热土豆路由选择；</li></ul></li><li><p>仍然留下多条路由，该路由器使用BGP标识符来选择路由；</p></li></ul></li><li><p>时间原则：PAGE275</p></li></ul><h5 id="4-路由选择策略"><a href="#4-路由选择策略" class="headerlink" title="4. 路由选择策略"></a>4. 路由选择策略</h5><blockquote><p>桩网络(stub network): 不会进行流量转发，所有离开AS进入桩网络的流量，必然是去往桩网络，所有离开桩网络的流量，必然是进入其他AS；</p></blockquote><ul><li>通过控制BGP路由的方式可以实现，两个连入桩网络的网络流量不会被该桩网络转发，原因就是这两个连入的网络不会将转发链路通告给桩网路；</li><li>ISP之间的路由选择：任何穿越莫ISP主干网的流量必须是其源地址或者目的，位于该ISP的某个客户网络中；不然这些流量将会免费搭车通过该ISP的网络；</li><li>AS和AS之间的路由选择目标之间的差别：<ul><li>策略</li><li>规模</li><li>性能</li><li>PAGE277</li></ul></li></ul><h2 id="4-7-广播和多播路由选择"><a href="#4-7-广播和多播路由选择" class="headerlink" title="4.7 广播和多播路由选择"></a>4.7 广播和多播路由选择</h2><ul><li>广播路由选择 broadcast routing<ul><li>网络层提供了从一个源结点到网络中其他所有结点交付分组的服务</li></ul></li><li>多播路由选择 multicast routing<ul><li>使单个源结点能向其他网络结点的一个子集发送分组的副本</li></ul></li></ul><h3 id="4-7-1-广播路由选择算法"><a href="#4-7-1-广播路由选择算法" class="headerlink" title="4.7.1 广播路由选择算法"></a>4.7.1 广播路由选择算法</h3><ul><li>N次单播<ul><li>源结点产生分组的N份副本，对不同目的地的每个副本进行编址，并用单播路由器选择向N个目的地传输N份副本；</li><li>无需网络层路由选择协议以及分组复制或转发功能；</li><li>缺陷<ul><li>生成了太多冗余副本，让接收结点再去生成冗余副本更加有效</li><li>需要另外的协议，如广播成员或目的地注册协议，会怎加更多开销，且协议变得复杂；</li><li>单播路由情况下，选择基础设施来取得广播并不明智；</li></ul></li></ul></li></ul><h4 id="1-无控制洪泛"><a href="#1-无控制洪泛" class="headerlink" title="1. 无控制洪泛"></a>1. 无控制洪泛</h4><ul><li>洪泛 flooding<ul><li>源结点向所有的邻居结点发送分组副本，当某个结点接收到一个广播分组时，复制该分组并向所有的邻居转发；（不会再次给发送方邻居转发）</li><li>缺陷<ul><li>此连通图具有圈，一个或者多个广播分组将会无休止的循环下去，例如R2，R3，R4互相连通为圈，则R2向3和4广播，3和4复制后又像4和3广播，4和3复制后又像2广播；</li><li><strong>广播风暴 broadcast storm</strong>，导致无休止的广播分组的复制；</li></ul></li></ul></li></ul><h4 id="2-受控洪泛-controlled-flooding"><a href="#2-受控洪泛-controlled-flooding" class="headerlink" title="2. 受控洪泛 controlled flooding"></a>2. 受控洪泛 controlled flooding</h4><ul><li>序号控制洪泛 sequence-number-controlled flooding<ul><li>源结点，将<strong>其地址和广播序号 broadcast sequence number</strong>放入广播分组；再向邻居发送副本；</li><li>每个结点维护一个收到分组标示的列表</li><li>收到广播分组后，首先检查是否存在列表中，如果再，直接丢弃，如果不再，则更新列表，并复制发送给邻居结点；</li></ul></li><li>反向路经转发 reverse path forwarding，RPF 反向路经广播<ul><li>当一台路由器接收到一个“源”的广播分组时，只有分组到达的路经 = 路由器到“源”的最短单播路经时，路由器才会接收该广播分组并向其他邻居转发；</li></ul></li></ul><h4 id="3-生成树广播"><a href="#3-生成树广播" class="headerlink" title="3. 生成树广播"></a>3. 生成树广播</h4><blockquote><p>序号控制洪泛和RPF避免了广播风暴，但是无法完全避免冗余分组的传输；</p></blockquote><ul><li><strong>生成树 spanning tree</strong></li><li><strong>所有生成树中费用最小的生成树：最小生成树</strong></li><li>广播方法<ul><li>最网络结点构造一颗生成树</li><li>源结点向所有属于生成树的特定链路发送分组</li><li>接收广播分组的结点则向生成树中所有邻居转发该分组（接收该分组的邻居除外）</li></ul></li><li>生成树生成算法<ul><li>基于中心的方法 center-based approach<ul><li>定义一个中心点为汇合点 rendezvous point 或者 核 core</li><li>结点向中心结点单播加入树 tree-join 报文，加入树报文使用单播路由选择朝中心结点转发，直到到达一个已经属于生成树的结点或者中心结点；</li><li>加入树报文经过的路经定义了发起加入树报文的边缘结点和中心结点之间的分支，新的分支已经被认为能够嫁接到现有的生成树上了；</li><li>生成过程：PAGE281</li></ul></li></ul></li></ul><h4 id="4-实践中的广播算法"><a href="#4-实践中的广播算法" class="headerlink" title="4. 实践中的广播算法"></a>4. 实践中的广播算法</h4><ul><li>实践中，广播协议被应用于：<strong>网络层和应用层</strong></li><li>在Gnutella网络中，使用应用级的广播；</li><li>在OSPF路由选择算法和 中间系统到中间系统 IS-IS路由选择算法中，使用一种序号来靠内阁制洪泛；<ul><li>OSPF使用一个32bit的序号和一个16bit的age字段来标识LSA 广播链路状态通知；</li></ul></li><li>详情: PAGE 281 282</li></ul><h3 id="4-7-2-多播"><a href="#4-7-2-多播" class="headerlink" title="4.7.2 多播"></a>4.7.2 多播</h3><ul><li><p>多播（multicast）服务</p><p>，多播服务将分组交付给网络中一个结点的子集；</p><ul><li>应用程序要求将分组从一个或多个发送方交付给一组接收方；<ul><li>批量数据传输</li><li>流媒体服务</li><li>数据共享应用</li><li>Web缓存更新</li><li>交互式游戏</li></ul></li></ul></li><li><p>多播数据报，使用<strong>间接地址 address indirection</strong>来编址，用一个标识来表示一组接收方，寻址到该组的分组副本被交付给所有与该分组相关联的多播接收方，且使用单一标识符；</p></li><li><p><strong>D类多播地址</strong></p></li><li><p>与D类多播地址，相关联的接收方小组为<strong>多播组 multicast group</strong></p></li><li><p>每台主机由一个唯一的单播IP地址，且完全独立于主机所参与的多播地址</p></li><li><p>IGMP （因特网组管理协议，与ICMP因特网连接管理协议完全不同）</p></li></ul><h4 id="1-因特网组管理协议-IGMP"><a href="#1-因特网组管理协议-IGMP" class="headerlink" title="1. 因特网组管理协议 IGMP"></a>1. 因特网组管理协议 IGMP</h4><ul><li>IGMP为主机提供手段，通知与其相连的路由器</li><li>主机上的应用程序想要加入一个特定的多播组，IGMP与多播路由选择协议 互补组成；</li></ul><h5 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h5><ul><li>IGMP三种报文类型<ul><li>membership_query<ul><li>确定主机已经加入所有的多播集合</li></ul></li><li>membership_report<ul><li>响应membership_query报文</li><li>主机首次加入多播组，主机产生membership_report报文，无需等到路由器的membership_query报文</li></ul></li><li>leave_group<ul><li>可选</li></ul></li><li>路由器检测主机离开多播组，使用membership_query，当无主机响应具体组地址membership_query报文时，路由器推断出没有任何主机在当前多播组了</li><li>软状态<ul><li>IGMP中，多播组未被 “来自主机的membership_report” 报文显示的更新，通过超时事件将主机从多播组中删除；</li><li>软状态来源：PAGE284</li></ul></li></ul></li><li>IGMP报文和ICMP报文类似，封装在一个IP数据报中，使用IP上层协议号为2；</li></ul><h4 id="2-多播路由选择算法"><a href="#2-多播路由选择算法" class="headerlink" title="2. 多播路由选择算法"></a>2. 多播路由选择算法</h4><ul><li><p>选择方法</p><ul><li>多播路由器选择的目标就是发现一颗链路树，这些链路连接了所有属于该多播组的相连主机的路由器；</li><li>多播分组 将 <strong>沿着这颗树从发送方路由到所有属于该多播树的主机；</strong></li></ul></li><li><p>确定多播路由选择树的方法：</p><ul><li><p>使用一棵组共享树的多播路由选择；</p><ul><li>使用基于中心的方法来构建多播路由选择树；</li><li>属于多播组的主机，与主机相连的边缘路由将用“单播的方式”向中的结点发送加入报文；</li><li>关键：中心选择算法</li></ul></li><li><p>使用一颗基于源的树的多播路由选择；</p><ul><li><p>为多播组中的源构建一个多播路由选择树；</p></li><li><p>使用RPF算法，来构造一个多播转发树；</p><ul><li><p>缺陷与接近方法：</p><ul><li><p>数千台下游路由器都将收到一个不想要的多播分组；</p></li><li><p>剪枝</p><ul><li><p>一台接收到多播分组的多播路由器，如果它没有要加入多播组的相连主机，则向上游返回一个剪枝报文；</p></li><li><p>对一个路由器来说，如果它收到了来自下游每台路由器的剪枝报文，那么它会向自己上游的路由器发送剪枝报告；</p><blockquote><p>反向路经广播算法 RPF</p></blockquote></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="3-因特网中的多播路由选择"><a href="#3-因特网中的多播路由选择" class="headerlink" title="3. 因特网中的多播路由选择"></a>3. 因特网中的多播路由选择</h4><ul><li><p>距离向量多播路由选择协议 Distance Vector Multicast Routing Protocol, DVMRP</p><ul><li>实现了反向路经转发</li><li>实现了剪枝算法的基于源的树</li><li>使用RFP算法</li></ul></li><li><p>协议无关的多播路由选择协议 Protocol Independent Multicast, PIM</p><ul><li>稠密模式 Dense mode</li><li>稀疏模式 sparse mode</li></ul></li><li><p>不同域间的多播，使用域间BGP；</p></li><li><p>详情：PAGE 286</p></li></ul><h1 id="5-链路层和局域网"><a href="#5-链路层和局域网" class="headerlink" title="5.链路层和局域网"></a>5.链路层和局域网</h1><h2 id="5-1概述"><a href="#5-1概述" class="headerlink" title="5.1概述"></a>5.1概述</h2><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-aus-image-20230228154622539.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1"></p><ul><li><p>节点：运行链路层协议的任何设备</p></li><li><p>链路：物理通道</p></li><li><p>数据链路：逻辑通道</p></li><li><p>帧：链路层分组，封装网络层数据报</p></li><li><p>作用：在物理层服务基础上向网络层提供服务，将物理层提供的可能出错的链接改造成一条无差错的链接</p></li><li><p>功能：成帧、链路接入、可靠交付、差错检测和纠错</p></li></ul><h2 id="5-2封装成帧及透明传输"><a href="#5-2封装成帧及透明传输" class="headerlink" title="5.2封装成帧及透明传输"></a>5.2封装成帧及透明传输</h2><h2 id="5-3差错控制及纠正技术"><a href="#5-3差错控制及纠正技术" class="headerlink" title="5.3差错控制及纠正技术"></a>5.3差错控制及纠正技术</h2><ul><li><p>差错：位错、帧错</p></li><li><p>差错控制：检错编码和纠错编码</p><ul><li><p>检错编码：奇偶校验码和循环冗余码CRC</p><ul><li><p>奇偶校验码</p></li><li><p>CRC：<strong>异或计算（同0异1）</strong></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228164052122.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230228164052122"></p></li></ul></li><li><p>纠错编码：海明码</p></li></ul></li></ul><h2 id="5-4流量控制与可靠传输机制"><a href="#5-4流量控制与可靠传输机制" class="headerlink" title="5.4流量控制与可靠传输机制"></a>5.4流量控制与可靠传输机制</h2><h2 id="5-5多路访问链路和协议"><a href="#5-5多路访问链路和协议" class="headerlink" title="5.5多路访问链路和协议"></a>5.5多路访问链路和协议</h2><h3 id="5-5-1信道划分协议"><a href="#5-5-1信道划分协议" class="headerlink" title="5.5.1信道划分协议"></a>5.5.1信道划分协议</h3><ul><li><p>TDM时分多路复用</p></li><li><p>FDM频分多路复用</p></li><li><p>CDMA码分多址：类似于时隙和频隙的一种划分方式，仅作了解</p></li></ul><h3 id="5-5-2随机接入协议"><a href="#5-5-2随机接入协议" class="headerlink" title="5.5.2随机接入协议"></a>5.5.2随机接入协议</h3><ul><li><p>时隙ALOHA：ALOHA的改进版，把时间分为相同大小的时间片SLOT，不监听信道、按时间槽发送、随机重发（时间片开始）、想发就发，碰撞概率仍然很大</p></li><li><p>ALOHA：不监听信道、不按时间槽发送、随机重发、想发就发，碰撞概率很大</p></li><li><p>CSMA载波监听：先听再发，几种方式如下：</p><ul><li>1坚持：空闲时可能有多个计算机同时发送，可能导致冲突</li><li>非坚持：如果监听到忙，就放弃监听，等待随机时间后再监听</li><li>p坚持：和1坚持的区别就是发送数据的概率，产生冲突的概率小一点</li></ul></li><li><p>CSMA/CD：碰撞检测，先听再发，边听边发，冲突停发，随机重发。最小帧长的规定。</p><ul><li>如何重发：截断二进制指数退避算法 P300：第一次在{0，1}中等概率选择一个，第二次在{0，1，2，3}中等概率选择一个… …第十次在{0，1，……，1023}中等概率选择一个。</li></ul></li></ul><h3 id="5-5-3轮流协议"><a href="#5-5-3轮流协议" class="headerlink" title="5.5.3轮流协议"></a>5.5.3轮流协议</h3><ul><li>轮询协议</li><li>令牌传递协议<h2 id="5-4交换局域网"><a href="#5-4交换局域网" class="headerlink" title="5.4交换局域网"></a>5.4交换局域网</h2></li></ul><h3 id="5-4-1链路层寻址和ARP"><a href="#5-4-1链路层寻址和ARP" class="headerlink" title="5.4.1链路层寻址和ARP"></a>5.4.1链路层寻址和ARP</h3><ul><li><p>发送数据报到子网以内</p><ul><li>局域网，不使用IP地址寻址，通过链路层地址MAC寻址</li><li>如果ARP表中有对应的项，那么正常发送即可。</li><li><strong>如果ARP表中没有对应IP的MAC地址，那么发送方向他的适配器传输一个ARP查询分组，指示适配器用MAC广播地址将这个分组发送出去，然后局域网中其他设备检查自己的ARP表，将与之匹配的ARP项返回给查询主机，查询主机再进行后续的操作。</strong></li></ul></li><li><p>发送数据报到子网以外</p><ul><li><strong>子网1向子网2发送数据报，子网1中的设备向子网1中的设备查询，子网1中的路由器发现该地址是向它寻址的，因此把这个帧传给路由器的网络层。路由器通过查询转发表将该帧转发到子网2的路由器接口，然后该接口把包传递给他的适配器，再通过查询ARP来查询到MAC地址封装到一个新的帧，最后将帧转发到目的地。</strong></li></ul></li></ul><h3 id="5-4-2以太网"><a href="#5-4-2以太网" class="headerlink" title="5.4.2以太网"></a>5.4.2以太网</h3><p>以太网是目前最流行的有线局域网技术</p><ul><li><p>以太网帧结构</p><ul><li>前同步码|目的地址|源地址|类型|数据| |CRC<ul><li>数据：这个字段承载了IP数据报</li><li>目的地址：包含目的适配器的MAC地址</li><li>源地址：包含了源MAC地址</li></ul></li></ul></li><li><p>以太网技术</p><ul><li><p>以太网向网络层提供不可靠服务：帧没有通过CRC校验时只是舍弃该帧</p></li><li><p>以太网向网络层提供无连接服务：不事先握手</p></li></ul></li></ul><h3 id="5-4-3链路层交换机"><a href="#5-4-3链路层交换机" class="headerlink" title="5.4.3链路层交换机"></a>5.4.3链路层交换机</h3><ul><li><p>交换机转发和过滤</p><ul><li>过滤：决定一个帧是否转发和是否丢弃 </li><li>转发：决定一个帧被导向哪个接口</li><li>交换机的转发和过滤借助于交换机表</li></ul></li><li><p>自学习</p><ul><li><p>交换机表是自动、动态、自治的建立的，即插即用设备</p></li><li><p>交换机表初始为空</p></li><li><p>对于每个接口接收到的入帧，交换机将其存储</p></li><li><p>老化器：一段时间，该地址不活跃，交换机就将其删除</p></li></ul></li><li><p>链路层交换机的性质 p315</p><ul><li>消除碰撞</li><li>异质的链路：交换机将链路隔离，因此局域网中不同的链路能一不一样的速度、介质存在。</li><li>管理：交换机可以为网络管理提供便捷</li></ul></li><li><p>交换机和路由器的比较</p><ul><li><p>交换机基于MAC地址转发（第二层）、路由器基于IP地址转发（第三层），现代交换机两种都有。</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>交换机</td><td>1、即插即用。2、相对高的分组过滤和转发速率。</td><td>为了防止广播帧的循环，交换网络的活跃拓扑严格限制成一棵树，但是交换机对这个没有限制，有可能导致以太网的崩溃。</td></tr><tr><td>路由器</td><td>1、一般分组不会被循环。允许了非常丰富的拓扑结构来构建因特网。2、对第二层的广播风暴构建了防火墙。</td><td>处理时间比交换机更长</td></tr></tbody></table></li></ul></li></ul><h3 id="5-4-4虚拟局域网VLAN"><a href="#5-4-4虚拟局域网VLAN" class="headerlink" title="5.4.4虚拟局域网VLAN"></a>5.4.4虚拟局域网VLAN</h3><p>在一个单一的物理局域网中定义多个虚拟局域网，支持VLAN的交换机的端口被管理员划分为组</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230302151151787.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" alt="image-20230302151151787"></p><p>这些端口中的广播流量仅能到达该组中的其他端口</p><ul><li>怎么解决完全隔离带来的组与组之间传递的问题呢：VLAN干线连接</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notebook</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对方拍一拍你|在它的下面有一片红光承着它。它升高，红光也跟着伸长。</title>
    <link href="/2021/12/14/photo20211214/"/>
    <url>/2021/12/14/photo20211214/</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=31529024&auto=0&height=32"></iframe><table><thead><tr><th><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211215/DSCF5435.JPG?imageMogr2/format/webp"></th></tr></thead><tbody><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211215/DSCF5508.JPG?imageMogr2/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211215/DSCF5509.JPG?imageMogr2/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211215/DSCF5510.JPG?imageMogr2/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211215/DSCF5534.JPG?imageMogr2/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211215/DSCF5536.JPG?imageMogr2/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211215/DSCF5541.JPG?imageMogr2/format/webp"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211215/DSCF5545.JPG?imageMogr2/format/webp"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>对方拍一拍你</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对方拍一拍你|这是属于他的故事。是一颗流星，拂晓的旅途。</title>
    <link href="/2021/12/14/meteor/"/>
    <url>/2021/12/14/meteor/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em>“当流星划过天际，人们纷纷许下愿望，</em></p><p><em>只因他的光芒如此耀眼。</em></p><p><em>但那颗星星也曾迷失方向，</em></p><p><em>在夜色中踽踽独行。</em></p><p><em>可他依然在飞，</em></p><p><em>努力飞过这片冰冷孤寂的长夜。</em></p><p><em>这是属于他的故事。</em></p><p><em>是一颗流星，</em></p><p><em>拂晓的旅途。”</em></p></blockquote><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/col.jpg?imageMogr2/format/webp"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/_DSC3779.jpg?imageMogr2/format/webp"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/_DSC3771.jpg?imageMogr2/format/webp"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/_DSC3779.jpg?imageMogr2/format/webp"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/_DSC3651.jpg?imageMogr2/format/webp"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/_DSC3647.jpg?imageMogr2/format/webp"></p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/_DSC3639.jpg?imageMogr2/format/webp"></p><p><video src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/%E6%B5%81%E6%98%9F.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"> your browser does not support the video tag </video></p>]]></content>
    
    
    <categories>
      
      <category>对方拍一拍你</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|socket通信的python实现</title>
    <link href="/2021/12/09/cnet-python-socket/"/>
    <url>/2021/12/09/cnet-python-socket/</url>
    
    <content type="html"><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><em>编写一个员工考勤打卡网络应用程序。要求使用可靠的、面向连接的网络通信完成客户端提交工号及打卡时间，服务器端将接收到的工号和打卡时间显示到屏幕上。(编程语言不限）。</em></p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><br>serverPort = <span class="hljs-number">12000</span><br>serverSocket = socket(AF_INET, SOCK_STREAM)<br>serverSocket.bind((<span class="hljs-string">&#x27;192.168.64.1&#x27;</span>, serverPort))<br>serverSocket.listen(<span class="hljs-number">1</span>)<br>print(<span class="hljs-string">&quot;The server is ready to receive&quot;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    connectionSocket, addr = serverSocket.accept()<br>    sentence = connectionSocket.recv(<span class="hljs-number">1024</span>).decode()<br><br>    <span class="hljs-keyword">while</span> sentence:<br>        print(sentence)<br>        <span class="hljs-keyword">break</span><br><br>    capitalizedSentence = sentence.upper()<br>    connectionSocket.send(capitalizedSentence.encode())<br>    connectionSocket.close()<br><br></code></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> ttk<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendPack</span>():</span><br>    serverName = <span class="hljs-string">&#x27;192.168.64.1&#x27;</span><br>    sentence = ent1.get()<br>    serverPort = <span class="hljs-number">12000</span><br>    clientSocket = socket(AF_INET, SOCK_STREAM)<br>    clientSocket.connect((serverName, serverPort))<br>    <span class="hljs-comment"># sentence = input(&#x27;Input Your ID:&#x27;)</span><br>    now = datetime.datetime.now()<br>    sentence = sentence + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">str</span>(now)<br>    clientSocket.send(sentence.encode())<br>    modifiedSentence = clientSocket.recv(<span class="hljs-number">1024</span>)<br>    print(<span class="hljs-string">&#x27;From Server: &#x27;</span>, modifiedSentence.decode())<br>    clientSocket.close()<br><br>root = Tk()<br>frm = ttk.Frame(root, padding=<span class="hljs-number">10</span>)<br>frm.grid()<br>ttk.Label(frm, text=<span class="hljs-string">&quot;工号&quot;</span>).grid(column=<span class="hljs-number">0</span>, row=<span class="hljs-number">0</span>)<br>ent1 = ttk.Entry(frm)<br>ent1.grid(column=<span class="hljs-number">1</span>, row=<span class="hljs-number">0</span>)<br>ttk.Button(frm, text=<span class="hljs-string">&quot;打卡&quot;</span>, command=<span class="hljs-keyword">lambda</span>: sendPack()).grid(column=<span class="hljs-number">2</span>, row=<span class="hljs-number">0</span>)<br>root.mainloop()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践|每日300首自动网易云升级</title>
    <link href="/2021/11/28/netmusic/"/>
    <url>/2021/11/28/netmusic/</url>
    
    <content type="html"><![CDATA[<h1 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h1>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载|计算机网络原理自顶向下第七版中文答案（不要看）</title>
    <link href="/2021/11/27/cn-top-down-method-answers-in-chinese/"/>
    <url>/2021/11/27/cn-top-down-method-answers-in-chinese/</url>
    
    <content type="html"><![CDATA[<p>仅供自己使用~~~</p><p>怕原文无了，在这里线上保存一份方便自己查看。</p><div class="row">    <embed src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/pdf/cn_top_down_method_answers_in_chinese.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>实践|BJTU选课冲冲冲</title>
    <link href="/2021/11/27/bjtuchooselesson/"/>
    <url>/2021/11/27/bjtuchooselesson/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/aosiweixin/BJTU-CC">项目地址</a></p><p><strong><font color=red size=5>在2021年上半年可以使用，下半年不好说。</font></strong></p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><table><thead><tr><th><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/1.png"></th></tr></thead><tbody><tr><td></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/2.png"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/3.png"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/4.png"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/5.png"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/6.png"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/7.png"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/8.png"></td></tr><tr><td><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/9.png"></td></tr></tbody></table><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214-jc/10.png"></p><p><strong>如果想要修改代码可以看下面的</strong></p><p><strong>如果想要修改代码可以看下面的</strong></p><p><strong>如果想要修改代码可以看下面的</strong></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>主要单独需要下载一个selenium用于模拟浏览器，安装起来稍微有一点麻烦，要注意对应版本，网上搜教程就好啦~~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.options <span class="hljs-keyword">import</span> Options<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.common.exceptions <span class="hljs-keyword">import</span> TimeoutException<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>第一部分需要修改这些参数</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">type</span> = <span class="hljs-number">1</span>  <span class="hljs-comment"># 1为本方案课程 2为其他方案课程</span><br><span class="hljs-attr">type2</span> = <span class="hljs-number">1</span>  <span class="hljs-comment"># 1为搜索 0为不搜索</span><br><span class="hljs-attr">user_id_str</span> = <span class="hljs-string">&#x27;1928****&#x27;</span>  <span class="hljs-comment"># 学号</span><br><span class="hljs-attr">password_str</span> = <span class="hljs-string">&#x27;********&#x27;</span>  <span class="hljs-comment"># 密码</span><br><span class="hljs-attr">xpath_str</span> = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">delta</span> = <span class="hljs-number">0.9</span><br><span class="hljs-attr">course_number</span> = <span class="hljs-string">&#x27;A121006B&#x27;</span><br></code></pre></td></tr></table></figure><p>自动读取验证码需要使用<a href="http://www.ttshitu.com/">图鉴</a>的api</p><p>进入图鉴之后，注册账号</p><p><a href="https://pic.imgdb.cn/item/61a2456d2ab3f51d9138e3dd.jpg"><img src="https://pic.imgdb.cn/item/61a2456d2ab3f51d9138e3dd.jpg"></a></p><p>非常便宜，充值1元可以用四年。</p><p><a href="http://www.ttshitu.com/docs/python.html#pageTitle">图鉴使用文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 一、图片文字类型(默认 3 数英混合)：</span><br><span class="hljs-comment"># 1 : 纯数字</span><br><span class="hljs-comment"># 1001：纯数字2</span><br><span class="hljs-comment"># 2 : 纯英文</span><br><span class="hljs-comment"># 1002：纯英文2</span><br><span class="hljs-comment"># 3 : 数英混合</span><br><span class="hljs-comment"># 1003：数英混合2</span><br><span class="hljs-comment">#  4 : 闪动GIF</span><br><span class="hljs-comment"># 7 : 无感学习(独家)</span><br><span class="hljs-comment"># 11 : 计算题</span><br><span class="hljs-comment"># 1005:  快速计算题</span><br><span class="hljs-comment"># 16 : 汉字</span><br><span class="hljs-comment"># 32 : 通用文字识别(证件、单据)</span><br><span class="hljs-comment"># 66:  问答题</span><br><span class="hljs-comment"># 49 :recaptcha图片识别</span><br><span class="hljs-comment"># 二、图片旋转角度类型：</span><br><span class="hljs-comment"># 29 :  旋转类型</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 三、图片坐标点选类型：</span><br><span class="hljs-comment"># 19 :  1个坐标</span><br><span class="hljs-comment"># 20 :  3个坐标</span><br><span class="hljs-comment"># 21 :  3 ~ 5个坐标</span><br><span class="hljs-comment"># 22 :  5 ~ 8个坐标</span><br><span class="hljs-comment"># 27 :  1 ~ 4个坐标</span><br><span class="hljs-comment"># 48 : 轨迹类型</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 四、缺口识别</span><br><span class="hljs-comment"># 18 : 缺口识别（需要2张图 一张目标图一张缺口图）</span><br><span class="hljs-comment"># 33 : 单缺口识别（返回X轴坐标 只需要1张图）</span><br><span class="hljs-comment"># 五、拼图识别</span><br><span class="hljs-comment"># 53：拼图识别</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base64_api</span>(<span class="hljs-params">uname, pwd, img, typeid</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(img, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        base64_data = base64.b64encode(f.read())<br>        b64 = base64_data.decode()<br>    data = &#123;<span class="hljs-string">&quot;username&quot;</span>: uname, <span class="hljs-string">&quot;password&quot;</span>: pwd, <span class="hljs-string">&quot;typeid&quot;</span>: typeid, <span class="hljs-string">&quot;image&quot;</span>: b64&#125;<br>    result = json.loads(requests.post(<span class="hljs-string">&quot;http://api.ttshitu.com/predict&quot;</span>, json=data).text)<br>    <span class="hljs-keyword">if</span> result[<span class="hljs-string">&#x27;success&#x27;</span>]:<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;result&quot;</span>]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-string">&quot;message&quot;</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    img_path = <span class="hljs-string">&quot;C:/Users/Administrator/Desktop/file.jpg&quot;</span><br>    result = base64_api(uname=<span class="hljs-string">&#x27;你的账号&#x27;</span>, pwd=<span class="hljs-string">&#x27;你的密码&#x27;</span>, img=img_path, typeid=<span class="hljs-number">3</span>)<br>    print(result)<br></code></pre></td></tr></table></figure><p>也可以选择不使用自动识别（自动识别稍微有一点慢，需要看运气）</p><p>如果可以抽空盯着，看到验证码弹出来手输也还可以。</p><p>但最近选课平台没开就没法贴使用截图了，但在上学期期末，已经测试好了，可用！</p>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对方拍一拍你|贴一些觉得还可以的照片“2</title>
    <link href="/2021/10/31/photo2/"/>
    <url>/2021/10/31/photo2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pic.imgdb.cn/item/61a780222ab3f51d91e5dbe0.jpg"><img src="https://pic.imgdb.cn/item/61a780222ab3f51d91e5dbe0.jpg"></a></p><p><a href="https://pic.imgdb.cn/item/61a780222ab3f51d91e5dbe6.jpg"><img src="https://pic.imgdb.cn/item/61a780222ab3f51d91e5dbe6.jpg"></a></p><p><a href="https://pic.imgdb.cn/item/61a780222ab3f51d91e5dbed.jpg"><img src="https://pic.imgdb.cn/item/61a780222ab3f51d91e5dbed.jpg"></a></p>]]></content>
    
    
    <categories>
      
      <category>对方拍一拍你</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小技巧|自动更新github-DNS解析(全)</title>
    <link href="/2021/10/27/githubdns/"/>
    <url>/2021/10/27/githubdns/</url>
    
    <content type="html"><![CDATA[<p>很多时候都需要修改DNS来稳定网络，但手动更新实在不方便。</p><p>自动更新可以选择<strong>shell</strong>脚本或者<strong>SwitchHosts</strong></p><p>DNS选的是<a href="https://cdn.jsdelivr.net/gh/521xueweihan/GitHub520@main/hosts">helloGitHub的DNS文件下载地址</a></p><h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><ol><li>下载switchhosts</li><li>新建host</li><li>添加自动更新的地址</li><li>设置周期即可</li></ol><p><em>详细如下：</em></p><p>下载地址：</p><p>官方下载可能会有点慢，下面也贴个百度云的4.0.3版本</p><p><a href="https://github.com/oldj/SwitchHosts/releases">官方下载</a>||<a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://pan.baidu.com/s/1iVl-jPVN6P3i8juRKogLiw">exe版本百度云：提取码：hhhh </a>||Linux版本在官网下叭</p><p>只需要新建一个DNS，在自动配置里加上下面这个链接：</p><p><code>https://cdn.jsdelivr.net/gh/521xueweihan/GitHub520@main/hosts</code></p><p>设置好更新频率，然后等他自动更新即可。</p><p>Linux<strong>注意</strong>要修改switchhosts软件的权限</p><p>可以先在/usr/share/applications这个目录下看看有没有switchhosts，然后直接给这个文件权限即可：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> chmod <span class="hljs-number">600</span> ××× （只有所有者有读和写的权限） <br><span class="hljs-attribute">sudo</span> chmod <span class="hljs-number">644</span> ××× （所有者有读和写的权限，组用户只有读的权限） <br><span class="hljs-attribute">sudo</span> chmod <span class="hljs-number">700</span> ××× （只有所有者有读和写以及执行的权限） <br><span class="hljs-attribute">sudo</span> chmod <span class="hljs-number">666</span> ××× （每个人都有读和写的权限） <br><span class="hljs-attribute">sudo</span> chmod <span class="hljs-number">777</span> ××× （每个人都有读和写以及执行的权限）<br></code></pre></td></tr></table></figure><p>下面是近期的DNS，也可以手动添加：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"># GitHub520 Host Start<br><span class="hljs-number">140.82.114.26</span>                 alive.github.com<br><span class="hljs-number">140.82.114.26</span>                 live.github.com<br><span class="hljs-number">185.199.108.154</span>               github.githubassets.com<br><span class="hljs-number">140.82.114.22</span>                 central.github.com<br><span class="hljs-number">185.199.108.133</span>               desktop.githubusercontent.com<br><span class="hljs-number">185.199.108.153</span>               assets-cdn.github.com<br><span class="hljs-number">185.199.108.133</span>               camo.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               github.map.fastly.net<br><span class="hljs-number">199.232.69.194</span>                github.global.ssl.fastly.net<br><span class="hljs-number">140.82.114.3</span>                  gist.github.com<br><span class="hljs-number">185.199.111.153</span>               github.io<br><span class="hljs-number">140.82.113.4</span>                  github.com<br><span class="hljs-number">192.0.66.2</span>                    github.blog<br><span class="hljs-number">140.82.114.6</span>                  api.github.com<br><span class="hljs-number">185.199.108.133</span>               raw.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               user-images.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               favicons.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               avatars5.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               avatars4.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               avatars3.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               avatars2.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               avatars1.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               avatars0.githubusercontent.com<br><span class="hljs-number">185.199.108.133</span>               avatars.githubusercontent.com<br><span class="hljs-number">140.82.113.9</span>                  codeload.github.com<br><span class="hljs-number">52.217.139.73</span>                 github-cloud.s3.amazonaws.com<br><span class="hljs-number">52.216.104.27</span>                 github-com.s3.amazonaws.com<br><span class="hljs-number">52.217.108.108</span>                github-production-release-asset-2e65be.s3.amazonaws.com<br><span class="hljs-number">52.216.142.228</span>                github-production-user-asset-6210df.s3.amazonaws.com<br><span class="hljs-number">52.217.81.148</span>                 github-production-repository-file-5c1aeb.s3.amazonaws.com<br><span class="hljs-number">185.199.108.153</span>               githubstatus.com<br><span class="hljs-number">64.71.144.202</span>                 github.community<br><span class="hljs-number">23.100.27.125</span>                 github.dev<br><span class="hljs-number">185.199.108.133</span>               media.githubusercontent.com<br><br><br># Update time: <span class="hljs-number">2021</span>-<span class="hljs-number">11</span>-27T12:<span class="hljs-number">05</span>:<span class="hljs-number">26</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br># Update url: https://raw.hellogithub.com/hosts<br># Star me: https://github.com/521xueweihan/GitHub520<br># GitHub520 Host End<br></code></pre></td></tr></table></figure><h2 id="Shell脚本（不用看）"><a href="#Shell脚本（不用看）" class="headerlink" title="Shell脚本（不用看）"></a>Shell脚本（不用看）</h2><p>可以通过ubuntu的shell脚本去自动更新（不推荐），主要是通过date、test、tail、sed这几个命令做的。</p><blockquote><p>date命令顾名思义，用于获取当前系统时间，使用+%H选项时可以单独返回当前小时（24小时制）。例如，当前时间为8:48，返回值为08.</p><p>test命令用于测试各种内容，关于test命令的用法大家可以自己查一下。需要注意的是，不同格式数据的比较方法不同。我刚开始写脚本的时候，进行比较的两个数据分别是字符串格式和整数格式，总是提示参数过多，后来将格式改为一致，并使用相应的比较符才可以正常使用。当对字符串进行大于或小于比较时，需要写为”&gt;“或”&lt;“，以避免shell将”&lt;”和”&gt;”符号理解为输入输出符号。</p><p>tail命令返回文件的最后几行信息。</p><p>sed命令可以对输入的字符串进行编辑替换。当使用-i选项调用sed命令时，可以直接修改目标文件。</p></blockquote><p>具体可以自己试试啦。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#! /bin/bash</span><br><span class="hljs-comment"># change the hosts file to make sure some website couldn`t accessed in worktime</span><br><br><span class="hljs-keyword">if</span>   test $(date +%H) \&gt; <span class="hljs-string">&quot;08&quot;</span> -a $(date +%H) \&lt; <span class="hljs-string">&quot;22&quot;</span><br>thentail -<span class="hljs-number">7</span> <span class="hljs-regexp">/etc/</span>hosts | sed -i <span class="hljs-regexp">/etc/</span>hosts  -e <span class="hljs-string">&quot;s/# 127.0.0.1/ 127.0.0.1/g&quot;</span><br>    cat <span class="hljs-regexp">/etc/</span>hosts<br><span class="hljs-keyword">else</span> <br>    tail -<span class="hljs-number">7</span> <span class="hljs-regexp">/etc/</span>hosts | sed -i <span class="hljs-regexp">/etc/</span>hosts  -e <span class="hljs-string">&quot;s/ 127.0.0.1/# 127.0.0.1/g&quot;</span><br>    cat <span class="hljs-regexp">/etc/</span>hosts<br>fi<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对方拍一拍你|你看过七夕的星星嘛</title>
    <link href="/2021/08/15/2021-8-starofphoto/"/>
    <url>/2021/08/15/2021-8-starofphoto/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p0.meituan.net/dpgroup/f40156feb8b3f813d276dcb82f19b9f18633601.jpg" alt="dsc02891.jpg"></p><p><img src="https://p0.meituan.net/dpgroup/8a65b16059047a20ff86b5323519483e8264704.jpg" alt="dsc02893.jpg"></p><p><img src="https://p0.meituan.net/dpgroup/4b376738718e0afcf5f670ef77fdc4ba7256688.jpg" alt="dsc02894.jpg"></p><p><img src="https://pic.imgdb.cn/item/61a783ce2ab3f51d91e8ff6b.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>对方拍一拍你</category>
      
    </categories>
    
    
    <tags>
      
      <tag>photo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|安卓小学期一周合作开发小记</title>
    <link href="/2021/08/10/2021-8-androidassignment/"/>
    <url>/2021/08/10/2021-8-androidassignment/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li><p>一个人创建仓库，其他人fork。</p></li><li><p><strong>然后将这个代码仓库 “Clone”（克隆）到你的本地机器中，</strong>。<strong>“Clone”</strong> 成功之后你就可以自主修改里面的内容，然后 <strong>“Push”</strong> 到远程仓库中，注意，这是你自己的远程仓库。**但是不使用 “Fork”，而是直接 “Clone”（克隆）原作者的仓库的话，你会得到一个 “fatal: unable to access” 的提示，无法访问。之后的提交都是提交在你个人fork的仓库之中，不会对源仓库产生影响。</p></li><li><p>如果是小组合作，自然不用读issues，可以提前将每个人的部分分一下，避免发生冲突。在开发时建议新建一个分支而不是在fork下来的分支开发，开发完毕后可以直接合并进本地的主分支然后push上去。dev是我们远端的库，feature是本地新建开发分支。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">上传<br>（本来在feature）<br>git <span class="hljs-keyword">add</span> .<br>git checkout dev<br>git <span class="hljs-keyword">merge</span> feature<br>git <span class="hljs-keyword">commit</span>  –m ”本次提交描述”<br>git push<br>然后去github上面提交pull request<br>–––––––––––––––––––––<br>下载<span class="hljs-operator">/</span>更新<br>现在github上面<span class="hljs-keyword">check</span>一下<br>然后到cmd里（此时应该在自己的dev）<br>git pull<br>git checkout feature<br>git <span class="hljs-keyword">merge</span> dev<br></code></pre></td></tr></table></figure></li><li><p>push之后就可以pull request，将修改提交到作者的库，等待他合并即可。</p></li></ol><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p><a href="https://github.com/aosiweixin/Petime">github地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对方拍一拍你|贴一些觉得还可以的照片“</title>
    <link href="/2021/08/01/2021-8-photooooo/"/>
    <url>/2021/08/01/2021-8-photooooo/</url>
    
    <content type="html"><![CDATA[<p><img src="https://pic.imgdb.cn/item/6105ebc05132923bf82812bd.jpg"></p><p><img src="https://pic.imgdb.cn/item/6105f1b25132923bf83e15bd.jpg"></p><p><img src="https://pic.imgdb.cn/item/6105f1e65132923bf83edb5f.jpg"></p><p><img src="https://pic.imgdb.cn/item/6105f2105132923bf83f7cde.jpg"></p><p><img src="https://pic.imgdb.cn/item/6105f23d5132923bf84025ed.jpg"></p><p><img src="https://picture-hoset-1252275196.cos.ap-nanjing.myqcloud.com/DSC02601.jpg"></p><p><img src="https://picture-hoset-1252275196.cos.ap-nanjing.myqcloud.com/%E5%9B%BE%E5%BA%8A/DSC02796.jpg"></p><p><img src="https://picture-hoset-1252275196.cos.ap-nanjing.myqcloud.com/%E5%9B%BE%E5%BA%8A/DSC02798.jpg"></p><p><img src="https://picture-hoset-1252275196.cos.ap-nanjing.myqcloud.com/%E5%9B%BE%E5%BA%8A/DSC02841.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>对方拍一拍你</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Assignment|OpenCV车道线检测</title>
    <link href="/2021/07/22/2021-7-opencvdetect/"/>
    <url>/2021/07/22/2021-7-opencvdetect/</url>
    
    <content type="html"><![CDATA[<h1 id="关于OpenCV的车道线检测"><a href="#关于OpenCV的车道线检测" class="headerlink" title="关于OpenCV的车道线检测"></a>关于OpenCV的车道线检测</h1><h1 id="前期芝士"><a href="#前期芝士" class="headerlink" title="前期芝士"></a>前期芝士</h1><h2 id="1-1基本方法"><a href="#1-1基本方法" class="headerlink" title="1.1基本方法"></a>1.1基本方法</h2><h3 id="1-1-1图像处理"><a href="#1-1-1图像处理" class="headerlink" title="1.1.1图像处理"></a>1.1.1图像处理</h3><p>图像处理主要是先对图像进行灰度处理，高斯模糊，然后对其进行canny边缘检测，最后对得到的图像进行roi掩膜处理，进一步缩小范围。</p><h3 id="1-1-2霍夫变换"><a href="#1-1-2霍夫变换" class="headerlink" title="1.1.2霍夫变换"></a>1.1.2霍夫变换</h3><p>霍夫变换(Hough)是一个检测间断点边界形状的方法。它通过将图像坐标空间变换到参数空间，来实现直线与曲线的拟合。</p><p>在图像坐标空间中，经过点的直线表示为：</p><p>(1)</p><p>其中，参数a为斜率，b为截矩。其中，参数a为斜率，b为截矩。</p><p>通过点 点的直线有无数条，且对应于不同的a和b值。</p><p>如果将和视为常数，而将原本的参数a和b看作变量，则式子(1)可以表示为：</p><p>(2)</p><p>这样就变换到了参数平面a−b。这个变换就是直角坐标中对于点的Hough变换。</p><p>该直线是图像坐标空间中的点在参数空间的唯一方程。考虑到图像坐标空间中的另一点，它在参数空间中也有相应的一条直线，表示为：</p><p>(3)</p><p>这条直线与点在参数空间的直线相交于一点，如图所示：</p><p><img src="https://pic.imgdb.cn/item/60f934565132923bf8eee8fd.png" alt="这里写图片描述"></p><p>图 3直角变换中的直线霍夫变换</p><p>图像坐标空间中过点和点的直线上的每一点在参数空间a−b上各自对应一条直线，这些直线都相交于点,而a0、b0就是图像坐标空间x−y中点和点所确定的直线的参数。</p><p>反之，在参数空间相交于同一点的所有直线，在图像坐标空间都有共线的点与之对应。根据这个特性，给定图像坐标空间的一些边缘点，就可以通过Hough变换确定连接这些点的直线方程。</p><p>具体计算时，可以将参数空间视为离散的。建立一个二维累加数组,第一维的范围是图像坐标空间中直线斜率的可能范围，第二维的范围是图像坐标空间中直线截矩的可能范围。开始时初始化为0，然后对图像坐标空间的每一个前景点,将参数空间中每一个的离散值代入式子(2)中，从而计算出对应的值。每计算出一对都将对应的数组元素加1，即。所有的计算结束之后，在参数计算表决结果中找到的最大峰值，所对应的、就是源图像中共线点数目最多(共个共线点)的直线方程的参数；接下来可以继续寻找次峰值和第3峰值和第4峰值等等，它们对应于原图中共线点略少一些的直线。</p><p>对于上图的Hough变换空间情况如下图所示。</p><p><img src="https://pic.imgdb.cn/item/60f934485132923bf8eec0b2.png"></p><p>图 4直角坐标下的霍夫变换</p><h3 id="1-1-3离群变换和最小二乘拟合"><a href="#1-1-3离群变换和最小二乘拟合" class="headerlink" title="1.1.3离群变换和最小二乘拟合"></a>1.1.3离群变换和最小二乘拟合</h3><p>设置delta值，将不合理的斜率从斜率集中剔除。</p><p>利用numpy的最小二乘拟合将所有斜率大于0的点集和斜率小于0的点集分别拟合成两条直线。</p><h3 id="1-1-4视频流的读写"><a href="#1-1-4视频流的读写" class="headerlink" title="1.1.4视频流的读写"></a>1.1.4视频流的读写</h3><p>对视频流逐帧读取并且逐帧处理，最后在进行逐帧播放即可。</p><h2 id="1-2实验基本流程"><a href="#1-2实验基本流程" class="headerlink" title="1.2实验基本流程"></a>1.2实验基本流程</h2><ol><li><p> Canny边缘检测</p></li><li><p> 手动分割路面区域</p></li><li><p> 霍夫变换得到车道线</p></li><li><p> 获取车道线并叠加到原始图像中</p></li></ol><h1 id="局部代码"><a href="#局部代码" class="headerlink" title="局部代码"></a>局部代码</h1><h2 id="2-1图像处理"><a href="#2-1图像处理" class="headerlink" title="2.1图像处理"></a>2.1图像处理</h2><h3 id="2-1-1局部二值化处理"><a href="#2-1-1局部二值化处理" class="headerlink" title="2.1.1局部二值化处理"></a>2.1.1局部二值化处理</h3><p>要对图像进行边缘检测，首先对图像进行灰度变换，使图像只包含一个通道的信息，然后比较各相邻像素间的亮度差别，亮度产生突变的地方就是边缘像素，将这些边缘像素点连接到一起就形成了边缘图像。</p><p>那么首先要知道如何检测出边缘：</p><p>边缘有方向和幅值两个要素，通常对图像相邻域像素求取梯度来描述和检测边缘。</p><p>在进行边缘检测之前至少要将图像灰度化，因为梯度运算并不能反映色彩的变化差异，所以转换成只有一种颜色通道的灰度图像能够更好地进行边缘检测。</p><p>深入了解过图像二值化和边缘检测之后，我认为既可以直接使用灰度图像进行边缘检测，也可以二值化之后再进行边缘检测，二值化的目的是进一步简化灰度图像，使图像中的信息更加纯粹，边缘亮度变化更加明显。如果阈值选的较好还可以滤除不需要的弱边缘，使边缘处理后的图像轮廓更加清晰，效果如图。</p><p><img src="https://pic.imgdb.cn/item/60f9345c5132923bf8eefba5.png"></p><p>图 5局部二值化图像得到的边缘检测图像</p><p><img src="https://pic.imgdb.cn/item/60f934485132923bf8eec0a4.png"></p><p>图 6灰度图的边缘检测图像</p><p>可以明显发现对二值化图像进行边缘检测比直接对灰度图进行边缘检测的效果要好，得到的边更宽，可以方便后续操作。</p><p>同时，显然局部二值化处理的结果要比全局二值化处理的结果好，效果如图：</p><p><img src="https://pic.imgdb.cn/item/60f9345c5132923bf8eefc03.png"></p><p><img src="https://pic.imgdb.cn/item/60f934485132923bf8eec0d5.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python">明显全局二值化的图像已经不能看了。代码如下：<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_bin_img_1</span>(<span class="hljs-params">*color_img*</span>):</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">局部自适应阈值二值化</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>gray_img = cv2.cvtColor(*color_img*, cv2.COLOR_BGR2GRAY)<br><br>binary = cv2.adaptiveThreshold(<br><br>gray_img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="hljs-number">25</span>, <span class="hljs-number">10</span><br><br>)<br><br><span class="hljs-keyword">return</span> binary<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_bin_img_2</span>(<span class="hljs-params">*image*</span>):</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">全局自适应阈值二值化</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>gray = cv2.cvtColor(*image*, cv2.COLOR_RGB2GRAY) \<span class="hljs-comment"># 把输入图像灰度化</span><br><br>ret, binary = cv2.threshold(<br><br>gray, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY \| cv2.THRESH_TRIANGLE<br><br>) <span class="hljs-comment"># 直接阈值化是对输入的单通道矩阵逐像素进行阈值分割。</span><br><br><span class="hljs-keyword">return</span> binary<br><br>最后又测试了对边缘处理的图像二值化处理后再计算，效果也还可以，不过似乎差距不大，代码如下：<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_b_e</span>(<span class="hljs-params">*color_img*</span>):</span><br><br><span class="hljs-string">&quot;&quot;&quot;先边缘再二值化&quot;&quot;&quot;</span><br><br>img = do_do_do(*color_img*)<br><br>binary = cv2.adaptiveThreshold(<br><br>img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="hljs-number">25</span>, <span class="hljs-number">10</span><br><br>)<br><br>mask_img_gray = roi_mask(binary)<br><br>lines = get_lines(mask_img_gray)<br><br>draw_lines(*color_img*, lines)<br><br><span class="hljs-comment"># return edge_img</span><br><br><span class="hljs-keyword">return</span> *color_img*<br><br><span class="hljs-keyword">return</span> binary<br></code></pre></td></tr></table></figure><p>最后权衡之下选择了对边缘处理的图像二值化处理后再计算的这种方法。</p><h3 id="2-1-2高斯滤波参数选择"><a href="#2-1-2高斯滤波参数选择" class="headerlink" title="2.1.2高斯滤波参数选择"></a>2.1.2高斯滤波参数选择</h3><p>经过多次尝试，我选择gaussian_ksize=5, gaussian_sigmax=1，</p><p>代码如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">gaussian = cv2.GaussianBlur(<br><br>*color_img*, <span class="hljs-comment">(*gaussian_ksize*, *gaussian_ksize*)</span>, *gaussian_sigmax*<br><br>)<br></code></pre></td></tr></table></figure><h3 id="2-1-3对图像的roi掩膜处理"><a href="#2-1-3对图像的roi掩膜处理" class="headerlink" title="2.1.3对图像的roi掩膜处理"></a>2.1.3对图像的roi掩膜处理</h3><p>对图像进行了较为精确的测算，得出了视频对应的roi范围，效果如图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span>* <span class="hljs-title">roi_mask</span>(<span class="hljs-params">*gray_img*</span>):</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">对gray_img进行掩膜</span><br><span class="hljs-string"></span><br><span class="hljs-string">:param gray_img: 灰度图,channels=1</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># poly_pts = np.array([[[125, 324], [235, 259], [325, 259], [435, 324]]])</span><br><span class="hljs-comment">#视频1</span><br><br>poly_pts = np.array([[[<span class="hljs-number">118</span>, <span class="hljs-number">243</span>], [<span class="hljs-number">293</span>, <span class="hljs-number">112</span>], [<span class="hljs-number">365</span>, <span class="hljs-number">110</span>], [<span class="hljs-number">575</span>, <span class="hljs-number">243</span>]]]) \<span class="hljs-comment">#视频2</span><br><br>mask = np.zeros_like(*gray_img*)<br><br>mask = cv2.fillPoly(mask, *pts*=poly_pts, *color*=<span class="hljs-number">255</span>)<br><br>img_mask = cv2.bitwise_and(*gray_img*, mask)<br><br><span class="hljs-keyword">return</span> img_mask<br></code></pre></td></tr></table></figure><h2 id="2-2车道线计算"><a href="#2-2车道线计算" class="headerlink" title="2.2车道线计算"></a>2.2车道线计算</h2><h3 id="2-2-1剔除离群点"><a href="#2-2-1剔除离群点" class="headerlink" title="2.2.1剔除离群点"></a>2.2.1剔除离群点</h3><p>利用斜率的合理性，剔除误差较大的点，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span>* <span class="hljs-title">reject_abnormal_lines</span>(<span class="hljs-params">*lines*, *threshold*=<span class="hljs-number">0.2</span></span>):</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">剔除不一致的线段</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>slopes = [calculate_slope(line) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> *lines*]<br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(*lines*) \&gt; <span class="hljs-number">0</span>:<br><br>mean = np.mean(slopes)<br><br>diff = [<span class="hljs-built_in">abs</span>(s - mean) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> slopes]<br><br>idx = np.argmax(diff)<br><br><span class="hljs-keyword">if</span> diff[idx] \&gt; *threshold*:<br><br>slopes.pop(idx)<br><br>*lines*.pop(idx)<br><br><span class="hljs-keyword">else</span>:<br><br><span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">return</span> *lines<br></code></pre></td></tr></table></figure><h3 id="合理性判断"><a href="#合理性判断" class="headerlink" title="合理性判断"></a>合理性判断</h3><p>在绘制直线之前，对将要绘制的直线进行合理性判断，因为车道线不会突变，所以主要是利用上一帧的斜率以及大致斜率来排除，代码如下：</p><p>*</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span>* <span class="hljs-title">draw_lines</span>(<span class="hljs-params">*img*, *lines*</span>):</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">绘制线段</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">try</span>:<br><br>x = <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">global</span> pre_lines<br><br>left_line, right_line = *lines*<br><br>\<span class="hljs-comment"># print(left_line)</span><br><br>\<span class="hljs-comment"># print((left_line[0][1] - left_line[1][1]) / (left_line[0][0] -</span><br>left_line[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))<br><br><span class="hljs-keyword">if</span> (<br><br>(left_line[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - left_line[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) / (left_line[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - left_line[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br><br>) \&gt; <span class="hljs-number">0.5</span>:<br><br><span class="hljs-string">&quot;&quot;&quot;print(</span><br><span class="hljs-string"></span><br><span class="hljs-string">(left_line[0][1] - left_line[1][1])</span><br><span class="hljs-string"></span><br><span class="hljs-string">/ (left_line[0][0] - left_line[1][0])</span><br><span class="hljs-string"></span><br><span class="hljs-string">)&quot;&quot;&quot;</span><br><br>cv2.line(<br><br>img,<br><br><span class="hljs-built_in">tuple</span>(left_line[<span class="hljs-number">0</span>]),<br><br><span class="hljs-built_in">tuple</span>(left_line[<span class="hljs-number">1</span>]),<br><br>color*=(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>),<br><br>thickness*=<span class="hljs-number">4</span>,<br><br>)<br><br>x = <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">else</span>:<br><br>left_line, right_line = pre_lines<br><br><span class="hljs-keyword">if</span> (<br><br>(left_line[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - left_line[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br><br>/ (left_line[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - left_line[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br><br>) &gt; <span class="hljs-number">0.5</span>:<br><br>cv2.line(<br><br>*img*,<br><br><span class="hljs-built_in">tuple</span>(left_line[<span class="hljs-number">0</span>]),<br><br><span class="hljs-built_in">tuple</span>(left_line[<span class="hljs-number">1</span>]),<br><br>*color*=(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>),<br><br>*thickness*=<span class="hljs-number">4</span>,<br><br>)<br><br>x = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># print(right_line)</span><br><br><span class="hljs-keyword">if</span> (<br><br>(right_line[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - right_line[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br><br>/ (right_line[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - right_line[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br><br>) &lt; -<span class="hljs-number">0.5</span>:<br><br>cv2.line(<br><br>*img*,<br><br><span class="hljs-built_in">tuple</span>(right_line[<span class="hljs-number">0</span>]),<br><br><span class="hljs-built_in">tuple</span>(right_line[<span class="hljs-number">1</span>]),<br><br>*color*=(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>),<br><br>*thickness*=<span class="hljs-number">4</span>,<br><br>)<br><br>x = <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">else</span>:<br><br>left_line, right_line = pre_lines<br><br><span class="hljs-keyword">if</span> (<br><br>(right_line[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - right_line[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br><br> (right_line[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - right_line[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br><br>) &lt; -<span class="hljs-number">0.5</span>:<br><br>cv2.line(<br><br>img,<br><br><span class="hljs-built_in">tuple</span>(right_line[<span class="hljs-number">0</span>]),<br><br><span class="hljs-built_in">tuple</span>(right_line[<span class="hljs-number">1</span>]),<br><br>color=(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>),<br><br>thickness*=<span class="hljs-number">4</span>,<br><br>)<br><br>x = <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">True</span>:<br><br>pre_lines = lines<br><br><span class="hljs-keyword">except</span> BaseException:<br><br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=e3313m96b1n" allowFullScreen="true"></iframe><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=j3313u5gt5d" allowFullScreen="true"></iframe>]]></content>
    
    
    <categories>
      
      <category>Assignment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小芝士|Python语法糖和一些自己常用的修饰器</title>
    <link href="/2021/01/15/2021-1-pythonsuger/"/>
    <url>/2021/01/15/2021-1-pythonsuger/</url>
    
    <content type="html"><![CDATA[<h1 id="Syntactic-Suger"><a href="#Syntactic-Suger" class="headerlink" title="Syntactic Suger"></a>Syntactic Suger</h1><p>🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬🍬</p><blockquote><p>语法糖：写代码时的有趣易用的写法</p></blockquote><ol><li><p>大数的分隔符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1_000_000</span><br></code></pre></td></tr></table></figure></li><li><p>交换变量值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">100</span><br>b = <span class="hljs-number">50</span><br>a , b = b , a<br></code></pre></td></tr></table></figure></li><li><p>if else</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> (<span class="hljs-number">100</span> &lt; a &lt; <span class="hljs-number">150</span> ):<br></code></pre></td></tr></table></figure></li><li><p>字符串快速构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;QAQ&quot;</span>*<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li><p>列表相加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>b = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>c = a + b<br></code></pre></td></tr></table></figure></li><li><p>列表切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>c = a[<span class="hljs-number">2</span> : -<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li><li><p>打包解包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>x,y,z = a<br></code></pre></td></tr></table></figure></li><li><p>with语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>data = f.read()<br><span class="hljs-comment"># with会自带close和异常处理 </span><br></code></pre></td></tr></table></figure></li><li><p>列表推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [e+<span class="hljs-number">233</span> <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> a]<br></code></pre></td></tr></table></figure><h1 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h1></li><li><p>计时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@cal_time </span><span class="hljs-comment"># 可以很好的实现函数的计时功能</span><br></code></pre></td></tr></table></figure></li><li><p>递归加速</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@memoize</span><br></code></pre></td></tr></table></figure></li><li></li><li></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>小芝士</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践|pygame贪吃蛇</title>
    <link href="/2021/01/13/2021-1-pygame/"/>
    <url>/2021/01/13/2021-1-pygame/</url>
    
    <content type="html"><![CDATA[<h1 id="创建界面"><a href="#创建界面" class="headerlink" title="创建界面"></a>创建界面</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&quot;创建游戏窗口&quot;</span>)<br>    <span class="hljs-comment"># 导入GUI</span><br>    pygame.init()<br>    <span class="hljs-comment"># 设置窗口尺寸</span><br>    screen = pygame.display.set_mode((<span class="hljs-number">800</span>, <span class="hljs-number">600</span>))<br>    <span class="hljs-comment"># 设置窗口标题</span><br>    pygame.display.set_caption(<span class="hljs-string">&quot;贪吃蛇&quot;</span>)<br>    running = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">while</span> running:<br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.quit():<br>                running = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h1 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>:</span><br>    row = <span class="hljs-number">0</span><br>    clo = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, row, clo</span>):</span><br>        self.row = row<br>        self.clo = clo<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> Point(row=self.row, clo=self.clo)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">pygame.init()<br><span class="hljs-comment"># 初始化图形界面大小</span><br>GUI_width = <span class="hljs-number">800</span><br>GUI_height = <span class="hljs-number">400</span><br><br>ROW = <span class="hljs-number">30</span><br>CLO = <span class="hljs-number">40</span><br><span class="hljs-comment"># 初始化分数</span><br>game_score = <span class="hljs-number">0</span><br><br>direct = <span class="hljs-string">&#x27;left&#x27;</span><br>GUI_screen = pygame.display.set_mode((GUI_width, GUI_height))<br>pygame.display.set_caption(<span class="hljs-string">&#x27;贪吃蛇游戏&#x27;</span>)<br><br><span class="hljs-comment"># 蛇头</span><br>head = Point(row=<span class="hljs-built_in">int</span>(ROW / <span class="hljs-number">2</span>), clo=<span class="hljs-built_in">int</span>(CLO / <span class="hljs-number">2</span>))<br><span class="hljs-comment"># 蛇身</span><br>snake = [<br>    Point(row=head.row, clo=head.clo + <span class="hljs-number">1</span>),<br>    Point(row=head.row, clo=head.clo + <span class="hljs-number">2</span>),<br>    Point(row=head.row, clo=head.clo + <span class="hljs-number">3</span>)<br>]<br></code></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python">running = <span class="hljs-literal">True</span><br><span class="hljs-comment"># 设置帧频率</span><br>clock = pygame.time.Clock()<br>display_score_text = <span class="hljs-string">&#x27;得分:&#x27;</span> + <span class="hljs-built_in">str</span>(game_score)<br><span class="hljs-keyword">try</span>:<br>    score_font = pygame.font.SysFont(<span class="hljs-string">&#x27;bahnschrift&#x27;</span>, <span class="hljs-number">30</span>)  <span class="hljs-comment"># 创建一个font对象，显示结果</span><br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    print(<span class="hljs-string">&quot;没有这个字体,下面是已安装的字体&quot;</span>)<br>    print(pygame.font.get_fonts())<br>    score_font = pygame.font.Font(<span class="hljs-literal">None</span>, <span class="hljs-number">30</span>)<br>WhiteFont = (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)<br><span class="hljs-keyword">while</span> running:<br>    <span class="hljs-comment"># 处理帧频 锁帧</span><br>    clock.tick(<span class="hljs-number">30</span>)<br>    <span class="hljs-comment"># pygame.event.get()获取当前事件的队列 可以同时发生很多事件</span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            running = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>            GUI_screen.blit(score_surface, (<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 将结果绘制出来</span><br>            <span class="hljs-comment"># 这里小细节蛇不可以直接左右上下 要判断当前是在什么状态下前行</span><br>            <span class="hljs-keyword">if</span> event.key == <span class="hljs-number">273</span> <span class="hljs-keyword">or</span> event.key == <span class="hljs-number">119</span>:<br>                <span class="hljs-keyword">if</span> direct == <span class="hljs-string">&#x27;left&#x27;</span> <span class="hljs-keyword">or</span> direct == <span class="hljs-string">&#x27;right&#x27;</span>:<br>                    direct = <span class="hljs-string">&#x27;top&#x27;</span><br>            <span class="hljs-keyword">if</span> event.key == <span class="hljs-number">274</span> <span class="hljs-keyword">or</span> event.key == <span class="hljs-number">115</span>:<br>                <span class="hljs-keyword">if</span> direct == <span class="hljs-string">&#x27;left&#x27;</span> <span class="hljs-keyword">or</span> direct == <span class="hljs-string">&#x27;right&#x27;</span>:<br>                    direct = <span class="hljs-string">&#x27;bottom&#x27;</span><br>            <span class="hljs-keyword">if</span> event.key == <span class="hljs-number">276</span> <span class="hljs-keyword">or</span> event.key == <span class="hljs-number">97</span>:<br>                <span class="hljs-keyword">if</span> direct == <span class="hljs-string">&#x27;top&#x27;</span> <span class="hljs-keyword">or</span> direct == <span class="hljs-string">&#x27;bottom&#x27;</span>:<br>                    direct = <span class="hljs-string">&#x27;left&#x27;</span><br>            <span class="hljs-keyword">if</span> event.key == <span class="hljs-number">275</span> <span class="hljs-keyword">or</span> event.key == <span class="hljs-number">100</span>:<br>                <span class="hljs-keyword">if</span> direct == <span class="hljs-string">&#x27;top&#x27;</span> <span class="hljs-keyword">or</span> direct == <span class="hljs-string">&#x27;bottom&#x27;</span>:<br>                    direct = <span class="hljs-string">&#x27;right&#x27;</span><br>    <span class="hljs-comment"># 吃东西</span><br>    eat = (head.row == snake_food_location.row <span class="hljs-keyword">and</span> head.clo == snake_food_location.clo)<br><br>    <span class="hljs-keyword">if</span> eat:<br>        snake_food_location = Point(row=random.randint(<span class="hljs-number">0</span>, ROW - <span class="hljs-number">1</span>), clo=random.randint(<span class="hljs-number">0</span>, CLO - <span class="hljs-number">1</span>))<br>        game_score = game_score + <span class="hljs-number">1</span><br>    snake.insert(<span class="hljs-number">0</span>, head.copy())<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> eat:<br>        snake.pop()<br><br>    <span class="hljs-comment"># 移动一下</span><br>    <span class="hljs-keyword">if</span> direct == <span class="hljs-string">&#x27;left&#x27;</span>:<br>        head.clo -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> direct == <span class="hljs-string">&#x27;right&#x27;</span>:<br>        head.clo += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> direct == <span class="hljs-string">&#x27;top&#x27;</span>:<br>        head.row -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> direct == <span class="hljs-string">&#x27;bottom&#x27;</span>:<br>        head.row += <span class="hljs-number">1</span><br>    dead = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> head.clo &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> head.row &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> head.clo &gt;= CLO <span class="hljs-keyword">or</span> head.row &gt;= ROW:<br>        dead = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> body <span class="hljs-keyword">in</span> snake:<br>        <span class="hljs-keyword">if</span> head.clo == body.clo <span class="hljs-keyword">and</span> head.row == body.row:<br>            dead = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">break</span><br>    game_over = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> dead:<br>        print(<span class="hljs-string">&#x27;Game Over&#x27;</span>)<br>        game_over = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 背景画图</span><br>    pygame.draw.rect(GUI_screen, (<span class="hljs-number">245</span>, <span class="hljs-number">135</span>, <span class="hljs-number">155</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, GUI_width, GUI_height))<br>    score_surface = score_font.render(<span class="hljs-string">&quot;Score : %s&quot;</span> % <span class="hljs-built_in">str</span>(game_score), <span class="hljs-literal">True</span>, WhiteFont)<br>    <span class="hljs-comment"># 图像，绘制的位置，绘制的截面框</span><br>    GUI_screen.blit(score_surface, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), score_surface.get_rect())<br>    <span class="hljs-comment"># 蛇头</span><br>    rect(head, head_color)<br>    <span class="hljs-comment"># 绘制食物</span><br>    rect(snake_food_location, snake_food_color)<br>    <span class="hljs-comment"># 绘制蛇的身子</span><br>    <span class="hljs-keyword">for</span> body <span class="hljs-keyword">in</span> snake:<br>        rect(body, snake_color)<br>    <span class="hljs-keyword">if</span> game_over:<br>        running = <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># pygame.quit()</span><br>        <span class="hljs-comment"># break</span><br>        <span class="hljs-comment"># quit()</span><br><br>    pygame.display.flip()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践|Spider_BQG(爬书)</title>
    <link href="/2021/01/11/2021-1-Spider-BQG/"/>
    <url>/2021/01/11/2021-1-Spider-BQG/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_content</span>(<span class="hljs-params">target</span>):</span><br>    req = requests.get(url=target)<br>    req.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>    html = req.text<br>    bf = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>    texts = bf.find(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;content&#x27;</span>)<br>    content = texts.text.strip().split(<span class="hljs-string">&#x27;\xa0&#x27;</span> * <span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">return</span> content<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">spider</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, book_name, target</span>):</span><br>        self.__book_name = book_name<br>        self.__target = target<br>        self.__server = <span class="hljs-string">&#x27;https://www.xsbiquge.com&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_project</span>(<span class="hljs-params">self</span>):</span><br>        req = requests.get(url=self.__target)<br>        req.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>        html = req.text<br>        chapter_bs = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>        chapters = chapter_bs.find(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;list&#x27;</span>)<br>        chapters = chapters.find_all(<span class="hljs-string">&#x27;a&#x27;</span>)<br>        <span class="hljs-keyword">for</span> chapter <span class="hljs-keyword">in</span> tqdm(chapters):<br>            chapter_name = chapter.string<br>            url = self.__server + chapter.get(<span class="hljs-string">&#x27;href&#x27;</span>)<br>            content = get_content(url)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.__book_name, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(chapter_name)<br>                f.write(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                f.write(<span class="hljs-string">&#x27;\n&#x27;</span>.join(content))<br>                f.write(<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    spider1 = spider(<span class="hljs-string">&quot;book_name.txt&quot;</span>, <span class="hljs-string">&quot;https://www.xsbiquge.com/88_88080/&quot;</span>)<br>    spider1.do_project()<br>    print(<span class="hljs-string">&quot;运行结束&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践|Spider-豆瓣top500</title>
    <link href="/2021/01/01/2021-1-Spider/"/>
    <url>/2021/01/01/2021-1-Spider/</url>
    
    <content type="html"><![CDATA[<h1 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h1><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><p>终端打开scripts根目录，’.\pip install ***’安装库</p><p>常用库: bs4 re urllib xlwt sqlite3</p><h2 id="引用库"><a href="#引用库" class="headerlink" title="引用库"></a>引用库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*-codeing:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> bs4  <span class="hljs-comment">#网页解析、获取数据</span><br><span class="hljs-keyword">import</span> re  <span class="hljs-comment">#正则表达式</span><br><span class="hljs-keyword">import</span> urllib.request, urllib.error  <span class="hljs-comment">#指定url、获取网页数据</span><br><span class="hljs-keyword">import</span> xlwt  <span class="hljs-comment">#进行excel操作</span><br><span class="hljs-keyword">import</span> sqlite3  <span class="hljs-comment">#进行sqlit数据库操作</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aom</span>():</span><br>    print(<span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    aom()<br></code></pre></td></tr></table></figure><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>baseurl=”<a href="https://movie.douban.com/top250?start=0&filter=">https://movie.douban.com/top250?start=0&amp;filter=</a>“</p><p><a href="https://movie.douban.com/top250?start=0&filter=">豆瓣电影 Top 250</a></p><p>savepath=”E:/py/douban.xls”</p><ol><li><p>爬取网页</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">datalist=GetData(baseurl)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetData</span>(<span class="hljs-params">baseurl</span>):</span><br><span class="hljs-built_in">list</span>=[]<br><span class="hljs-comment">#逐一解析</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure></li><li><p>解析数据</p></li><li><p>保存数据</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SaveData</span>(<span class="hljs-params">savepath</span>)</span><br></code></pre></td></tr></table></figure><h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">AskUrl</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-comment">#head用于伪装、向服务端发消息</span><br>    head = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>:<br>        <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Edg/87.0.664.66&quot;</span><br>    &#125;<br>    request = urllib.request.Request(url, headers=head)<br>    html = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        response = urllib.request.urlopen(request)<br>        html = response.read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        print(html)<br>    <span class="hljs-keyword">except</span> urllib.error.URLError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(e, <span class="hljs-string">&quot;code&quot;</span>):<br>            print(e.code)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(e, <span class="hljs-string">&quot;reason&quot;</span>):<br>            print(e.reason)<br>    <span class="hljs-keyword">return</span> html<br></code></pre></td></tr></table></figure><h1 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h1><h2 id="补充bs4"><a href="#补充bs4" class="headerlink" title="补充bs4"></a>补充bs4</h2><p>bs4将Html文档转换成一个复杂的树形结构，每个节点都是python对象，所有对象可以归纳为4种</p><ol><li><p>-Tag</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read()<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><span class="hljs-comment">#会把第一个标签打印出来</span><br><br>print(bs.title)<br>print(bs.a)<br>print(bs.link)<br>print(<span class="hljs-built_in">type</span>(bs.link))<br></code></pre></td></tr></table></figure><p> 会拿到第一个标签</p></li><li><p>-NavigableString</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read()<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br>print(bs.title.string)<br>print(<span class="hljs-built_in">type</span>(bs.title.string))<br></code></pre></td></tr></table></figure><p> 上面的会打印注释</p><p> 下面会打印出字典</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read()<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br>print(bs.a.attrs)<br>print(<span class="hljs-built_in">type</span>(bs.a.attrs))<br></code></pre></td></tr></table></figure></li><li><p>-BeautifulSoup</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read()<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br>print(bs)<br></code></pre></td></tr></table></figure></li><li><p>-comment</p><p> 第一种打印出注释就是comment</p></li></ol><h2 id="节点的获取"><a href="#节点的获取" class="headerlink" title="节点的获取"></a>节点的获取</h2><h3 id="文档的遍历"><a href="#文档的遍历" class="headerlink" title="文档的遍历"></a>文档的遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read()<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br>print(bs.head.contents[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>contents是个列表，可以通过下标访问元素</p><h3 id="文档的搜索"><a href="#文档的搜索" class="headerlink" title="文档的搜索"></a>文档的搜索</h3><ol><li><p>find_all—字符串过滤、会查找与字符串完全一致的标签</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br>t_list = bs.find_all(<span class="hljs-string">&quot;a&quot;</span>)<br>print(t_list)<br></code></pre></td></tr></table></figure><ol><li><p>正则表达式搜索、使用search()方法搜索、把包含a的都拿出来</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> re<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br>t_list = bs.find_all(re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>print(t_list)<br></code></pre></td></tr></table></figure></li><li><p>方法：传入一个函数，根据函数的要求来搜索</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> re<br>    <br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_name_exist</span>(<span class="hljs-params">tag</span>):</span><br>    <span class="hljs-keyword">return</span> tag.<span class="hljs-built_in">hasattr</span>(<span class="hljs-string">&quot;name&quot;</span>)<br>    <br>t_list = bs.find_all(is_name_exist)<br>    <br>print(t_list)<br></code></pre></td></tr></table></figure></li></ol></li><li><p>kwargs_____参数</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> re<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\baidu.html&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>html = f.read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>bs = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br>t_list = bs.find_all(<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;head&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="补充正则表达式"><a href="#补充正则表达式" class="headerlink" title="补充正则表达式"></a>补充正则表达式</h2></li></ol><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=22"></a></p><p><a href="https://www.cnblogs.com/dreamingbaobei/p/9717234.html">史上最全常用正则表达式大全</a></p><p><a href="Spider%2074d04c2785984ec0a50e036a4a41e102/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%206ef815be95ee46bc90e8b2a4e93d312b.csv">常用操作符</a></p><p><a href="Spider%2074d04c2785984ec0a50e036a4a41e102/Re%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%20bc8815fda34b42e083b77b30d2b77a90.csv">Re库的使用</a></p><p><a href="Spider%2074d04c2785984ec0a50e036a4a41e102/Re%E5%BA%93%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%20fe84e1a330d64ec7b0aa3f61523264c1.csv">Re库的修饰符</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>pat = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&quot;AA&quot;</span>)  <span class="hljs-comment">#此处AA是正则表达式</span><br>m = pat.search(<span class="hljs-string">&quot;ABCFFFAA&quot;</span>)  <span class="hljs-comment">#被匹配的</span><br>print(m) <span class="hljs-comment">#左闭右开</span><br></code></pre></td></tr></table></figure><p>上面的search只会找到第一个匹配的串，下面是第二种写法，前面是正则表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>print(re.search(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;fsaa&quot;</span>))<br></code></pre></td></tr></table></figure><p>下面是findall</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>print(re.findall(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;faasaa&quot;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>print(re.findall(<span class="hljs-string">&quot;[A-Z]&quot;</span>, <span class="hljs-string">&quot;faCasBaaAA&quot;</span>))<br></code></pre></td></tr></table></figure><p>sub的使用，在第三个字符串中，用第二个字符替换掉第一个字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>print(re.sub(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;asdfagfsg&quot;</span>))<br></code></pre></td></tr></table></figure><p>建议在正则表达式前面加上r，不用担心转义字符的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>print(re.sub(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">r&quot;/A/&quot;</span>, <span class="hljs-string">&quot;asdfagfsg&quot;</span>))  <br></code></pre></td></tr></table></figure><h2 id="正则提取"><a href="#正则提取" class="headerlink" title="正则提取"></a>正则提取</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?t=7&p=23"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">findlink = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;</span>)  <span class="hljs-comment">#创建正则表达式对象、表示规则字符串的模式</span><br>findImgsrc = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;img.*src=&quot;(.*?)&quot;&#x27;</span>, re.S)<br>findMovieName = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findScore = re.<span class="hljs-built_in">compile</span>(<br>    <span class="hljs-string">r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findIformation = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findDitail = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;p class=&quot;&quot;&gt;(.*)&lt;/p&gt;&#x27;</span>, re.S)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetData</span>(<span class="hljs-params">baseurl</span>):</span><br>    datalist = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>):<br>        url = baseurl + <span class="hljs-built_in">str</span>(i)<br>        html = AskUrl(url)  <span class="hljs-comment">#保存</span><br>        <span class="hljs-comment">#解析</span><br>        soup = bs4.BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&quot;item&quot;</span>):<br>            <span class="hljs-comment">#print(item)  #下面是保存</span><br>            <span class="hljs-comment">#break</span><br>            data = []<br>            item = <span class="hljs-built_in">str</span>(item)<br>            link = re.findall(findlink, item)[<span class="hljs-number">0</span>]  <span class="hljs-comment">#通过正则表达式查找字符串,0表示两个里面的第一个</span><br>            <span class="hljs-comment">#print(link)</span><br>            img = re.findall(findImgsrc, item)[<span class="hljs-number">0</span>]<br>            <span class="hljs-comment">#print(img)</span><br>            name = re.findall(findMovieName, item)[<span class="hljs-number">0</span>]<br>            <span class="hljs-comment">#print(name)</span><br>            score = re.findall(findScore, item)[<span class="hljs-number">0</span>]<br>            print(score)<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> datalist<br></code></pre></td></tr></table></figure><h2 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetData</span>(<span class="hljs-params">baseurl</span>):</span><br>    datalist = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>):<br>        url = baseurl + <span class="hljs-built_in">str</span>(i)<br>        html = AskUrl(url)  <span class="hljs-comment">#保存</span><br>        <span class="hljs-comment">#解析</span><br>        soup = bs4.BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&quot;item&quot;</span>):<br>            <span class="hljs-comment">#print(item)  #下面是保存</span><br>            <span class="hljs-comment">#break</span><br>            data = []<br>            item = <span class="hljs-built_in">str</span>(item)<br>            link = re.findall(findlink, item)[<span class="hljs-number">0</span>]  <span class="hljs-comment">#通过正则表达式查找字符串,0表示两个里面的第一个</span><br>            data.append(link)<br>            <span class="hljs-comment">#print(link)</span><br>            img = re.findall(findImgsrc, item)[<span class="hljs-number">0</span>]<br>            data.append(img)<br>            <span class="hljs-comment">#print(img)</span><br>            name = re.findall(findMovieName, item)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(name) == <span class="hljs-number">2</span>):<br>                ctitle = name[<span class="hljs-number">0</span>]<br>                data.append(ctitle)<br>                otitle = name[<span class="hljs-number">1</span>].replace(<span class="hljs-string">&quot;\xa0/\xa0&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>                <span class="hljs-comment">#print(otitle)</span><br>                data.append(otitle)<br>            <span class="hljs-keyword">else</span>:<br>                data.append(name[<span class="hljs-number">0</span>])<br>                data.append(<span class="hljs-string">&quot; &quot;</span>)<br>            <span class="hljs-comment">#print(name)</span><br>            score = re.findall(findScore, item)[<span class="hljs-number">0</span>]<br>            data.append(score)<br>            <span class="hljs-comment">#print(score)</span><br>            information = re.findall(findIformation, item)[<span class="hljs-number">0</span>]<br>            data.append(information.replace(<span class="hljs-string">&quot;。&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br><br>            datalist.append(data)<br>            print(datalist)<br>    <span class="hljs-keyword">return</span> datalist<br></code></pre></td></tr></table></figure><h1 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h1><h2 id="保存到excel中"><a href="#保存到excel中" class="headerlink" title="保存到excel中"></a>保存到excel中</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwt<br>wookbook = xlwt.Workbook()<br>wooksheet = wookbook.add_sheet(<span class="hljs-string">&quot;sheet1&quot;</span>)<br>wooksheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Hello&quot;</span>)<br>wookbook.save(<span class="hljs-string">&quot;text.xls&quot;</span>)<br></code></pre></td></tr></table></figure><p>下面是九九乘法表，示例python的xlwt的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwt<br>wookbook = xlwt.Workbook()<br>wooksheet = wookbook.add_sheet(<span class="hljs-string">&quot;sheet1&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>):<br>        wooksheet.write(i, j, <span class="hljs-string">&quot;%d*%d=%d&quot;</span> % (i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, (j + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">1</span>)))<br>wookbook.save(<span class="hljs-string">&quot;1.xls&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*-codeing:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> bs4  <span class="hljs-comment">#网页解析、获取数据</span><br><span class="hljs-keyword">import</span> re  <span class="hljs-comment">#正则表达式</span><br><span class="hljs-keyword">import</span> urllib.request, urllib.error  <span class="hljs-comment">#指定url、获取网页数据</span><br><span class="hljs-keyword">import</span> xlwt  <span class="hljs-comment">#进行excel操作</span><br><span class="hljs-keyword">import</span> sqlite3  <span class="hljs-comment">#进行sqlit数据库操作</span><br><br>baseurl = <span class="hljs-string">&quot;https://movie.douban.com/top250?start=&quot;</span><br><br>datalist = []<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    GetData(baseurl)<br>    SaveData(datalist)<br><br>findlink = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;</span>)  <span class="hljs-comment">#创建正则表达式对象、表示规则字符串的模式</span><br>findImgsrc = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;img.*src=&quot;(.*?)&quot;&#x27;</span>, re.S)<br>findMovieName = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findScore = re.<span class="hljs-built_in">compile</span>(<br>    <span class="hljs-string">r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findIformation = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetData</span>(<span class="hljs-params">baseurl</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>):<br>        url = baseurl + <span class="hljs-built_in">str</span>(i)<br>        html = AskUrl(url)  <span class="hljs-comment">#保存</span><br>        <span class="hljs-comment">#解析</span><br>        soup = bs4.BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&quot;item&quot;</span>):<br>            <span class="hljs-comment">#print(item)  #下面是保存</span><br>            <span class="hljs-comment">#break</span><br>            data = []<br>            item = <span class="hljs-built_in">str</span>(item)<br>            link = re.findall(findlink, item)[<span class="hljs-number">0</span>]  <span class="hljs-comment">#通过正则表达式查找字符串,0表示两个里面的第一个</span><br>            data.append(link)<br>            <span class="hljs-comment">#print(link)</span><br>            img = re.findall(findImgsrc, item)[<span class="hljs-number">0</span>]<br>            data.append(img)<br>            <span class="hljs-comment">#print(img)</span><br>            name = re.findall(findMovieName, item)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(name) == <span class="hljs-number">2</span>):<br>                ctitle = name[<span class="hljs-number">0</span>]<br>                data.append(ctitle)<br>                otitle = name[<span class="hljs-number">1</span>].replace(<span class="hljs-string">&quot;\xa0/\xa0&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>                <span class="hljs-comment">#print(otitle)</span><br>                data.append(otitle)<br>            <span class="hljs-keyword">else</span>:<br>                data.append(name[<span class="hljs-number">0</span>])<br>                data.append(<span class="hljs-string">&quot; &quot;</span>)<br>            <span class="hljs-comment">#print(name)</span><br>            score = re.findall(findScore, item)[<span class="hljs-number">0</span>]<br>            data.append(score)<br>            <span class="hljs-comment">#print(score)</span><br>            information = re.findall(findIformation, item)[<span class="hljs-number">0</span>]<br>            data.append(information.replace(<span class="hljs-string">&quot;。&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br><br>            datalist.append(data)<br>            <span class="hljs-comment">#print(datalist)</span><br>    <span class="hljs-keyword">return</span> datalist<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">AskUrl</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-comment">#head用于伪装、向服务端发消息</span><br>    head = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>:<br>        <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Edg/87.0.664.66&quot;</span><br>    &#125;<br>    request = urllib.request.Request(url, headers=head)<br>    html = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        response = urllib.request.urlopen(request)<br>        html = response.read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        <span class="hljs-comment">#print(html)</span><br>    <span class="hljs-keyword">except</span> urllib.error.URLError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(e, <span class="hljs-string">&quot;code&quot;</span>):<br>            print(e.code)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(e, <span class="hljs-string">&quot;reason&quot;</span>):<br>            print(e.reason)<br>    <span class="hljs-keyword">return</span> html<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SaveData</span>(<span class="hljs-params">datalist</span>):</span><br>    wookbook = xlwt.Workbook(encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment">#创建</span><br>    wooksheet = wookbook.add_sheet(<span class="hljs-string">&quot;sheet1&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">250</span>):<br>        print(<span class="hljs-string">&quot;第%d条&quot;</span> % (i + <span class="hljs-number">1</span>))<br>        data = datalist[i]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>):<br>            wooksheet.write(i, j, data[j])<br>    wookbook.save(<span class="hljs-string">&quot;douban.xls&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h1 id="SQlite部分"><a href="#SQlite部分" class="headerlink" title="SQlite部分"></a>SQlite部分</h1><p>结构如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">**<span class="hljs-keyword">import</span> sqlite3<br>conn = sqlite3.connect(<span class="hljs-string">&quot;test.db&quot;</span>)<br>print(<span class="hljs-string">&quot;Successfully open&quot;</span>)<br>c = conn.cursor()<br>sql = <span class="hljs-string">&quot;&quot;</span><br>c.execute(sql)<br>conn.commit()<br>conn.close()<br>print(<span class="hljs-string">&quot;Successfully create&quot;</span>)**<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UE4学习笔记|unrealengine4-1</title>
    <link href="/2020/08/20/2021-8-unrealengine4-1/"/>
    <url>/2020/08/20/2021-8-unrealengine4-1/</url>
    
    <content type="html"><![CDATA[<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="地图关卡快捷键"><a href="#地图关卡快捷键" class="headerlink" title="地图关卡快捷键"></a>地图关卡快捷键</h3><table><thead><tr><th align="center">键位</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">W、E、R</td><td align="center">分别是位移、旋转、缩放</td></tr><tr><td align="center">Alt+P</td><td align="center">开始游戏</td></tr><tr><td align="center">Alt+S</td><td align="center">模拟运行</td></tr><tr><td align="center">Ctrl+W</td><td align="center">快速复制</td></tr><tr><td align="center">F11</td><td align="center">全屏视口</td></tr><tr><td align="center">shift+F11</td><td align="center">全屏ue4</td></tr><tr><td align="center">G</td><td align="center">游戏视图</td></tr><tr><td align="center">L+左键</td><td align="center">生成点光源</td></tr><tr><td align="center">Ctrl+B</td><td align="center">查找选中的物体路径</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="蓝图快捷键"><a href="#蓝图快捷键" class="headerlink" title="蓝图快捷键"></a>蓝图快捷键</h3><table><thead><tr><th align="center">键位</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">C</td><td align="center">comment</td></tr><tr><td align="center">B +左击</td><td align="center">Branch Node（分支节点）</td></tr><tr><td align="center">D + 左击</td><td align="center">Delay Node（延迟节点）</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1>]]></content>
    
    
    <categories>
      
      <category>Notebook</category>
      
      <category>UE4学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UE4学习笔记|水一年虚幻引擎的遇到的那些坑”</title>
    <link href="/2020/07/30/2021-7-holeofue4/"/>
    <url>/2020/07/30/2021-7-holeofue4/</url>
    
    <content type="html"><![CDATA[<p>…待填</p><h3 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h3><div class="row">    <embed src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/pdf/report.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Notebook</category>
      
      <category>UE4学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践|如何拥有一个hexo博客</title>
    <link href="/2020/01/29/2021-1-howtogethexo/"/>
    <url>/2020/01/29/2021-1-howtogethexo/</url>
    
    <content type="html"><![CDATA[<h1 id="如何拥有一个hexo博客"><a href="#如何拥有一个hexo博客" class="headerlink" title="如何拥有一个hexo博客"></a>如何拥有一个<em>hexo</em>博客</h1><p><strong>Hexo 是一个快速、简洁且高效的博客框架。</strong></p><p>Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。一般我们可以使用github pages提供的免费服务器</p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>安装<a href="https://nodejs.org/en/">Node.js</a>-&gt;打开cmd，输入node -v和npm -v，都出现版本号就表示安装成功</p><blockquote><p>Node.js是一个JavaScript的运行环境，使电脑能够成功运行hexo</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> -v<br></code></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>安装<a href="https://git-scm.com/">Git</a>-&gt;这里是教程<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">&gt;_&lt;</a></p><blockquote><p>Git可以让我们向GitHub pages上传我们的博客</p></blockquote><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>必备应用安装完成后，就可以动手使用npm安装hexo啦！打开cmd，输入以下</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>安装完成再输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo -v</span><br></code></pre></td></tr></table></figure><p>出现版本号表示成功</p><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>在GitHub的your repository中新建一个名为GitHub用户名.github.io 的repository</p><p>新建完成点开clone or download压缩包到本地-&gt;解压并且放置在一个自己新建的文件夹中，这个文件夹就是你的博客存储的位置-&gt;放置好了就用cmd在该路径建站，输入</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>这样完成之后，指定的文件夹中会出现以下内容</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><blockquote><p>_config.yml是网站的配置信息，可在这里配置大部分参数</p><p>package.json是应用程序信息，一般无需改动</p><p>scaffolds是模板文件夹，改动这个的front-matter以后所有新建的post都会包含这部分</p><p>themes是主题文件夹，hexo会根据主题生成页面</p><p>source文件夹存一些页面，我们的博文会存在/source/_posts中</p></blockquote><p>点击这个查看hexo官网的详细描述<a href="https://hexo.io/zh-cn/docs/configuration">&gt;_&lt;</a></p><p>常用的hexo命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">hexo g  <span class="hljs-regexp">//</span>生成网页<br>hexo s  <span class="hljs-regexp">//</span>预览网页<br>hexo d  <span class="hljs-regexp">//</span>上传部署<br>hexo new <span class="hljs-string">&quot;title&quot;</span> <span class="hljs-regexp">//</span>生成新文章<br></code></pre></td></tr></table></figure><h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>最基本的已经完成了，现在我们要做的就是发表一篇自己的博文：</p><p>​    我们博文要用markdown语法写成，可以选择简洁又舒服的<a href="https://www.typora.io/">typora</a>来进行编辑，编辑完成后就可以生成上传预览。</p><h2 id="推荐修改"><a href="#推荐修改" class="headerlink" title="推荐修改"></a>推荐修改</h2><p>配置如下命令，即可让新建的文章默认按照年月去分类。<br>在<code>_config.yml</code>文件中修改下面的命令<br><code>new_post_name: :year/:month/:title.md</code></p><p>这玩意可太好用了，如果一开始不分类，后期文章多了就非常麻烦。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>hexo<a href="https://hexo.io/docs/">官方文档</a></p></blockquote><blockquote><p>Fluid<a href="https://hexo.fluid-dev.com/docs/guide/#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">主题文档</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HELLO WORLD</title>
    <link href="/2020/01/28/2021-1-hello-world/"/>
    <url>/2020/01/28/2021-1-hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="食用指南"><a href="#食用指南" class="headerlink" title="食用指南"></a>食用指南</h1><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/45f65abd9f266d8daaaa946f5c788d8.png"></p><p>hahaha，2024 年回头看，真正做到了“<strong>年更</strong>”，在现在技术迭代这么快的时候，还是希望能够多多留下一下自己的记录～</p><p>2023 年，刚读研究生的一年，在这一年慢慢寻找到自己要致力的方向～</p><h2 id="首页篇"><a href="#首页篇" class="headerlink" title="首页篇"></a>首页篇</h2><p>首页从上往下的顺序是按照发布时间先后顺序来排列的（置顶除外）</p><p>每页会显示十篇的呦</p><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/20211214/b9272e64d3415c0dbf37c66723de718.png"></p><p>如上图举例：</p><p><strong>黑框：文章标题都是XXX|YYYYY的形式，XXX是博文的分类，YYYYY是博文的名字</strong>。</p><p><font color=green><strong>绿框：文章的摘要是绿框标注出来的部分。</strong></font></p><p><font color=red><strong>红框：文章的发布日期在这里呦。</strong></font></p><p><font color=orange><strong>黄框：文章的分类部分</strong></font></p><p><font color=blue><strong>蓝框：文章的小标签</strong></font></p><h2 id="归档篇"><a href="#归档篇" class="headerlink" title="归档篇"></a>归档篇</h2><p>这个页面严格按照时间分类，以年为单位划分。hexo 在这一点上真的很好用，虽然用的别人的模板，但是还是很容易就可以做出一些很有用的修改，比如这个时间分类。</p><h2 id="分类篇"><a href="#分类篇" class="headerlink" title="分类篇"></a>分类篇</h2><p>这个页面按照分类划分，现有的分类有以下：</p><ul><li>实践——写一些自己做的或者模仿别人做的一些有趣的小玩意</li><li>对方拍一拍你——拍 照 片</li><li>Assignment——上学期间做过的一些值得纪念的作业</li><li>小技巧——一些学习生活中用的上的小技巧（主要还是电脑方面啦）</li><li>小芝士——知识类的都在这里</li><li>Intership——记录一些实习过程的心得历程</li></ul><h2 id="标签篇"><a href="#标签篇" class="headerlink" title="标签篇"></a>标签篇</h2><p>目前的 tag 非常混乱，经过思考重新整理成以下的形式</p><table><thead><tr><th>Category</th><th>Tags</th></tr></thead><tbody><tr><td><strong>Theory</strong></td><td>Compilers, Architecture, Networks, HPC</td></tr><tr><td><strong>AI</strong></td><td>Ai-infra, ML, DL</td></tr><tr><td><strong>Language</strong></td><td>Python, C++</td></tr><tr><td><strong>Other</strong></td><td>Tools, Envs</td></tr></tbody></table><p>但是之前很多的文章 tag都没有修改，未来所有的都考虑采用这种</p><h2 id="关于篇"><a href="#关于篇" class="headerlink" title="关于篇"></a>关于篇</h2><p>关于自己</p><h2 id="友链篇"><a href="#友链篇" class="headerlink" title="友链篇"></a>友链篇</h2><p>朋友们的博客链接。</p><p>也欢迎大家交换友链~~</p><p>我的友链如下：</p><ul><li><strong>url:</strong> <a href="https://www.aooxin.cn/">https://www.aooxin.cn/</a></li><li><strong>blog:</strong> Aoxin`s Blog</li><li>**<del>没用的</del>话：对于一个 J 人来说，踩中每一个关键节点带来的喜悦是什么都无法比拟的！</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
